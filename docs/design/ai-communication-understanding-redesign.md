# AIç†è§£äººç±»æ²Ÿé€šå¹¶å®æ—¶è°ƒæ•´å‡ºç‰Œç­–ç•¥ - è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ è®¾è®¡æ¦‚è¿°

è®¾è®¡ä¸€ä¸ª**æ™ºèƒ½æ²Ÿé€šç³»ç»Ÿ**ï¼Œè®©AIç©å®¶èƒ½å¤Ÿç†è§£äººç±»ç©å®¶çš„å¯¹è¯å†…å®¹ï¼Œä»ä¸­æå–ç­–ç•¥æ„å›¾å’Œç‰Œä¿¡æ¯ï¼Œå¹¶å®æ—¶è°ƒæ•´å‡ºç‰Œç­–ç•¥ã€‚è¿™åˆ›é€ äº†çœŸæ­£çš„"å›¢é˜Ÿé…åˆ"å’Œ"å¿ƒç†åšå¼ˆ"ä½“éªŒã€‚

---

## ğŸ¯ æ ¸å¿ƒéœ€æ±‚

### 1. äººç±»ç©å®¶å¯ä»¥"è¯´è¯"

- âœ… æ–‡å­—è¾“å…¥
- âœ… è¯­éŸ³è¾“å…¥ï¼ˆå¯é€‰ï¼‰
- âœ… å¿«æ·çŸ­è¯­ï¼ˆå¯é€‰ï¼‰

### 2. AIç†è§£äººç±»çš„è¯

- âœ… ç†è§£ç­–ç•¥æ„å›¾ï¼ˆå¦‚"ä¿ç•™å¤§ç‰Œ"ã€"æˆ‘æ¥æ‹¿åˆ†"ï¼‰
- âœ… æå–ç‰Œä¿¡æ¯ï¼ˆå¦‚"æˆ‘æœ‰ç‚¸å¼¹"ã€"æˆ‘æ²¡æœ‰å¤§ç‰Œ"ï¼‰
- âœ… è¯†åˆ«é…åˆè¯·æ±‚ï¼ˆå¦‚"ä½ æ¥å‡º"ã€"æˆ‘ä¿æŠ¤"ï¼‰

### 3. å®æ—¶è°ƒæ•´å‡ºç‰Œç­–ç•¥

- âœ… æ ¹æ®ç†è§£çš„ä¿¡æ¯è°ƒæ•´MCTSç­–ç•¥
- âœ… æ ¹æ®ç­–ç•¥æ„å›¾è°ƒæ•´è¯„ä¼°å‡½æ•°æƒé‡
- âœ… å®æ—¶å“åº”ï¼Œç«‹å³ç”Ÿæ•ˆ

---

## âŒ ç°æœ‰ç³»ç»Ÿçš„é—®é¢˜

### 1. èŠå¤©ç³»ç»Ÿæ˜¯å•å‘çš„

**ç°æœ‰ç³»ç»Ÿ**ï¼š
- AIç”ŸæˆèŠå¤©å†…å®¹
- äººç±»ç©å®¶åªèƒ½çœ‹ï¼Œä¸èƒ½è¾“å…¥

**é—®é¢˜**ï¼š
- âŒ äººç±»ç©å®¶æ— æ³•ä¸»åŠ¨æ²Ÿé€š
- âŒ AIæ— æ³•ç†è§£äººç±»ç©å®¶çš„æ„å›¾
- âŒ æ²¡æœ‰å›¢é˜Ÿé…åˆæœºåˆ¶

### 2. AIå‡ºç‰Œç­–ç•¥æ˜¯é™æ€çš„

**ç°æœ‰ç³»ç»Ÿ**ï¼š
- AIæŒ‰ç…§å›ºå®šçš„MCTSç­–ç•¥å‡ºç‰Œ
- ä¸è€ƒè™‘äººç±»ç©å®¶çš„æ„å›¾

**é—®é¢˜**ï¼š
- âŒ æ— æ³•é…åˆäººç±»ç©å®¶
- âŒ æ— æ³•å“åº”äººç±»ç©å®¶çš„ç­–ç•¥è¦æ±‚

---

## âœ… æ–°ç³»ç»Ÿè®¾è®¡

### æ ¸å¿ƒæµç¨‹

```
äººç±»ç©å®¶è¾“å…¥ â†’ AIç†è§£ â†’ ä¿¡æ¯æå– â†’ ç­–ç•¥è°ƒæ•´ â†’ å®æ—¶ç”Ÿæ•ˆ
     â†“           â†“         â†“          â†“          â†“
  "æˆ‘æ¥å‡º"    NLUåˆ†æ   ç­–ç•¥æ„å›¾   è°ƒæ•´æƒé‡   æ›´æ–°MCTS
  "æˆ‘æœ‰ç‚¸å¼¹"  æå–ä¿¡æ¯   ç‰Œä¿¡æ¯    è°ƒæ•´å‚æ•°   ç«‹å³å“åº”
```

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šäººç±»ç©å®¶è¾“å…¥ç³»ç»Ÿ

### 1.1 è¾“å…¥æ–¹å¼

#### æ–¹å¼1ï¼šæ–‡å­—è¾“å…¥

```typescript
interface ChatInputProps {
  onSend: (message: string) => void;
  placeholder?: string;
  maxLength?: number;
}
```

**UIè®¾è®¡**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¬ å’Œé˜Ÿå‹æ²Ÿé€š                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚ [è¾“å…¥æ¡†ï¼šæˆ‘æ¥å‡ºï¼Œä½ ä¿ç•™å¤§ç‰Œ]            â”‚
â”‚                                         â”‚
â”‚ [å¿«æ·çŸ­è¯­]                              â”‚
â”‚ [æˆ‘æ¥] [ä½ æ¥] [ä¿ç•™å¤§ç‰Œ] [æˆ‘æœ‰ç‚¸å¼¹]    â”‚
â”‚                                         â”‚
â”‚ [å‘é€]                                  â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ–¹å¼2ï¼šå¿«æ·çŸ­è¯­

```typescript
interface QuickPhrase {
  text: string;        // æ˜¾ç¤ºæ–‡æœ¬
  meaning: string;     // å®é™…å«ä¹‰
  category: 'strategy' | 'information' | 'cooperation';
}

const quickPhrases: QuickPhrase[] = [
  { text: 'æˆ‘æ¥', meaning: 'è®©æˆ‘æ¥å‡ºç‰Œ', category: 'strategy' },
  { text: 'ä½ æ¥', meaning: 'ä½ æ¥å‡ºç‰Œ', category: 'strategy' },
  { text: 'ä¿ç•™å¤§ç‰Œ', meaning: 'ä¿ç•™å¤§ç‰Œç”¨äºå…³é”®æ—¶åˆ»', category: 'strategy' },
  { text: 'æˆ‘æœ‰ç‚¸å¼¹', meaning: 'æˆ‘æœ‰ç‚¸å¼¹ï¼Œå¯ä»¥æ”¯æ´', category: 'information' },
  { text: 'æˆ‘æ²¡æœ‰å¤§ç‰Œ', meaning: 'æˆ‘æ²¡æœ‰å¤§ç‰Œï¼Œéœ€è¦å¸®åŠ©', category: 'information' },
  { text: 'æˆ‘æ¥æ‹¿åˆ†', meaning: 'è®©æˆ‘æ¥æ‹¿è¿™ä¸€è½®çš„åˆ†', category: 'cooperation' },
  { text: 'ä½ ä¿æŠ¤', meaning: 'ä½ æ¥ä¿æŠ¤åˆ†ç‰Œ', category: 'cooperation' },
];
```

### 1.2 æ¶ˆæ¯åˆ›å»º

```typescript
interface HumanChatMessage extends ChatMessage {
  playerId: number;           // äººç±»ç©å®¶ID
  content: string;            // åŸå§‹è¾“å…¥
  timestamp: number;
  type: 'human_input';        // äººç±»è¾“å…¥ç±»å‹
  processed?: ProcessedMessage;  // AIå¤„ç†åçš„ç†è§£ç»“æœ
}

interface ProcessedMessage {
  intent: CommunicationIntent;      // æ²Ÿé€šæ„å›¾
  extractedInfo: ExtractedInfo;     // æå–çš„ä¿¡æ¯
  confidence: number;                // ç†è§£ç½®ä¿¡åº¦
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šAIç†è§£ç³»ç»Ÿï¼ˆNLUï¼‰

### 2.1 ç†è§£æ¶æ„

```
äººç±»è¾“å…¥æ–‡æœ¬
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   NLUåˆ†ææ¨¡å—         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æ„å›¾è¯†åˆ«        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ä¿¡æ¯æå–        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ç½®ä¿¡åº¦è¯„ä¼°      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
ç†è§£ç»“æœ â†’ ç­–ç•¥è°ƒæ•´
```

### 2.2 æ„å›¾è¯†åˆ«

```typescript
interface CommunicationIntent {
  type: IntentType;
  parameters: IntentParameters;
  confidence: number;
}

type IntentType = 
  | 'strategy_request'      // ç­–ç•¥è¯·æ±‚ï¼ˆ"æˆ‘æ¥å‡º"ã€"ä½ æ¥å‡º"ï¼‰
  | 'information_reveal'    // ä¿¡æ¯é€éœ²ï¼ˆ"æˆ‘æœ‰ç‚¸å¼¹"ã€"æˆ‘æ²¡æœ‰å¤§ç‰Œ"ï¼‰
  | 'cooperation_request'   // é…åˆè¯·æ±‚ï¼ˆ"æˆ‘æ¥æ‹¿åˆ†"ã€"ä½ ä¿æŠ¤"ï¼‰
  | 'tactical_suggestion'   // æˆ˜æœ¯å»ºè®®ï¼ˆ"ä¿ç•™å¤§ç‰Œ"ã€"æ‹†ç‰Œå‡º"ï¼‰
  | 'warning'               // è­¦å‘Šï¼ˆ"å°å¿ƒ"ã€"æœ‰å±é™©"ï¼‰
  | 'general'               // ä¸€èˆ¬å¯¹è¯

interface IntentParameters {
  action?: 'play' | 'pass' | 'hold' | 'break';
  target?: 'me' | 'teammate' | 'opponent';
  cardInfo?: CardInfo;
  strategy?: StrategyHint;
}

// æ„å›¾è¯†åˆ«å‡½æ•°
async function recognizeIntent(
  text: string,
  gameContext: GameContext
): Promise<CommunicationIntent> {
  // 1. ä½¿ç”¨LLMç†è§£æ„å›¾
  const llmResult = await analyzeIntentWithLLM(text, gameContext);
  
  // 2. ä½¿ç”¨è§„åˆ™å¼•æ“éªŒè¯
  const ruleResult = analyzeIntentWithRules(text, gameContext);
  
  // 3. ç»¼åˆç»“æœ
  return combineIntentResults(llmResult, ruleResult);
}
```

### 2.3 LLMæ„å›¾åˆ†æ

```typescript
async function analyzeIntentWithLLM(
  text: string,
  gameContext: GameContext
): Promise<CommunicationIntent> {
  const prompt = `
ä½ æ˜¯ä¸€ä¸ªè¿‡ç‚¸ç‰Œæ¸¸æˆçš„åˆ†æç³»ç»Ÿï¼Œéœ€è¦ç†è§£äººç±»ç©å®¶çš„å¯¹è¯æ„å›¾ã€‚

## æ¸¸æˆä¸Šä¸‹æ–‡
- å½“å‰è½®æ¬¡åˆ†æ•°ï¼š${gameContext.roundScore}åˆ†
- æˆ‘çš„é˜Ÿå‹ï¼š${gameContext.teammate?.name}
- ä¸Šå®¶å‡ºç‰Œï¼š${formatPlay(gameContext.lastPlay)}

## äººç±»ç©å®¶è¯´çš„è¯
"${text}"

## ä»»åŠ¡
åˆ†æè¿™å¥è¯çš„æ„å›¾ï¼Œä»ä»¥ä¸‹ç±»å‹ä¸­é€‰æ‹©ï¼š
1. strategy_request - ç­–ç•¥è¯·æ±‚ï¼ˆå¦‚"æˆ‘æ¥å‡º"ã€"ä½ æ¥å‡º"ï¼‰
2. information_reveal - ä¿¡æ¯é€éœ²ï¼ˆå¦‚"æˆ‘æœ‰ç‚¸å¼¹"ã€"æˆ‘æ²¡æœ‰å¤§ç‰Œ"ï¼‰
3. cooperation_request - é…åˆè¯·æ±‚ï¼ˆå¦‚"æˆ‘æ¥æ‹¿åˆ†"ã€"ä½ ä¿æŠ¤"ï¼‰
4. tactical_suggestion - æˆ˜æœ¯å»ºè®®ï¼ˆå¦‚"ä¿ç•™å¤§ç‰Œ"ã€"æ‹†ç‰Œå‡º"ï¼‰
5. warning - è­¦å‘Šï¼ˆå¦‚"å°å¿ƒ"ã€"æœ‰å±é™©"ï¼‰
6. general - ä¸€èˆ¬å¯¹è¯

## è¾“å‡ºæ ¼å¼ï¼ˆJSONï¼‰
{
  "type": "æ„å›¾ç±»å‹",
  "parameters": {
    "action": "åŠ¨ä½œï¼ˆå¦‚æœæœ‰ï¼‰",
    "target": "ç›®æ ‡ï¼ˆå¦‚æœæœ‰ï¼‰",
    "cardInfo": {
      "hasBomb": true/false,
      "hasBigCards": true/false,
      "handCount": "æ‰‹ç‰Œæ•°é‡ï¼ˆå¦‚æœæåˆ°ï¼‰"
    },
    "strategy": {
      "suggestion": "å»ºè®®çš„ç­–ç•¥"
    }
  },
  "confidence": 0.0-1.0
}

è¯·è¿”å›JSONæ ¼å¼çš„åˆ†æç»“æœã€‚
  `;
  
  const response = await callLLM(prompt);
  return parseIntentResponse(response);
}
```

### 2.4 è§„åˆ™å¼•æ“åˆ†æ

```typescript
function analyzeIntentWithRules(
  text: string,
  gameContext: GameContext
): CommunicationIntent {
  const lowerText = text.toLowerCase();
  
  // ç­–ç•¥è¯·æ±‚æ¨¡å¼
  const strategyPatterns = [
    { pattern: /æˆ‘æ¥|è®©æˆ‘æ¥|æˆ‘å‡º/, intent: { type: 'strategy_request', action: 'play', target: 'me' } },
    { pattern: /ä½ æ¥|ä½ å‡º/, intent: { type: 'strategy_request', action: 'play', target: 'teammate' } },
    { pattern: /è¦ä¸èµ·|ä¸è¦/, intent: { type: 'strategy_request', action: 'pass' } },
    { pattern: /ä¿ç•™|ç•™ç€/, intent: { type: 'strategy_request', action: 'hold' } },
  ];
  
  // ä¿¡æ¯é€éœ²æ¨¡å¼
  const infoPatterns = [
    { pattern: /æˆ‘æœ‰ç‚¸å¼¹|ç‚¸å¼¹/, intent: { type: 'information_reveal', cardInfo: { hasBomb: true } } },
    { pattern: /æ²¡æœ‰å¤§ç‰Œ|æ²¡å¤§ç‰Œ/, intent: { type: 'information_reveal', cardInfo: { hasBigCards: false } } },
    { pattern: /æˆ‘æœ‰.*å¼ /, intent: { type: 'information_reveal', cardInfo: { handCount: extractNumber(text) } } },
  ];
  
  // é…åˆè¯·æ±‚æ¨¡å¼
  const cooperationPatterns = [
    { pattern: /æˆ‘æ¥æ‹¿åˆ†|æˆ‘æ‹¿åˆ†/, intent: { type: 'cooperation_request', action: 'play', strategy: { suggestion: 'get_score' } } },
    { pattern: /ä½ ä¿æŠ¤|ä½ é˜²å®ˆ/, intent: { type: 'cooperation_request', action: 'play', target: 'teammate', strategy: { suggestion: 'protect' } } },
  ];
  
  // åŒ¹é…æ¨¡å¼
  for (const pattern of [...strategyPatterns, ...infoPatterns, ...cooperationPatterns]) {
    if (pattern.pattern.test(lowerText)) {
      return {
        type: pattern.intent.type,
        parameters: pattern.intent,
        confidence: 0.8  // è§„åˆ™åŒ¹é…çš„ç½®ä¿¡åº¦
      };
    }
  }
  
  // é»˜è®¤ï¼šä¸€èˆ¬å¯¹è¯
  return {
    type: 'general',
    parameters: {},
    confidence: 0.5
  };
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šä¿¡æ¯æå–ç³»ç»Ÿ

### 3.1 æå–çš„ä¿¡æ¯ç±»å‹

```typescript
interface ExtractedInfo {
  // ç‰Œä¿¡æ¯
  cardInfo?: {
    hasBomb?: boolean;           // æ˜¯å¦æœ‰ç‚¸å¼¹
    hasBigCards?: boolean;        // æ˜¯å¦æœ‰å¤§ç‰Œ
    handCount?: number;           // æ‰‹ç‰Œæ•°é‡
    hasScoreCards?: boolean;      // æ˜¯å¦æœ‰åˆ†ç‰Œ
  };
  
  // ç­–ç•¥ä¿¡æ¯
  strategyInfo?: {
    preferredAction?: 'play' | 'pass' | 'hold';
    suggestion?: string;          // ç­–ç•¥å»ºè®®
    priority?: 'high' | 'medium' | 'low';
  };
  
  // é…åˆä¿¡æ¯
  cooperationInfo?: {
    requestType?: 'support' | 'attack' | 'defend';
    target?: 'me' | 'teammate';
    urgency?: 'high' | 'medium' | 'low';
  };
  
  // ç½®ä¿¡åº¦
  confidence: number;
}
```

### 3.2 ä¿¡æ¯æå–é€»è¾‘

```typescript
function extractInfoFromText(
  text: string,
  intent: CommunicationIntent,
  gameContext: GameContext
): ExtractedInfo {
  const extracted: ExtractedInfo = {
    confidence: intent.confidence
  };
  
  // æ ¹æ®æ„å›¾ç±»å‹æå–ä¿¡æ¯
  switch (intent.type) {
    case 'information_reveal':
      extracted.cardInfo = extractCardInfo(text, intent);
      break;
      
    case 'strategy_request':
      extracted.strategyInfo = extractStrategyInfo(text, intent);
      break;
      
    case 'cooperation_request':
      extracted.cooperationInfo = extractCooperationInfo(text, intent);
      break;
  }
  
  // é¢å¤–çš„ä¿¡æ¯æå–ï¼ˆæ— è®ºæ„å›¾ç±»å‹ï¼‰
  extracted.cardInfo = {
    ...extracted.cardInfo,
    ...extractCardInfoFromText(text)
  };
  
  return extracted;
}

// ä»æ–‡æœ¬ä¸­æå–ç‰Œä¿¡æ¯
function extractCardInfoFromText(text: string): Partial<ExtractedInfo['cardInfo']> {
  const lowerText = text.toLowerCase();
  const cardInfo: any = {};
  
  // æ£€æµ‹ç‚¸å¼¹
  if (/ç‚¸å¼¹|bomb/.test(lowerText)) {
    cardInfo.hasBomb = true;
  }
  
  // æ£€æµ‹å¤§ç‰Œ
  if (/å¤§ç‰Œ|å¤§ç‚¹/.test(lowerText)) {
    cardInfo.hasBigCards = true;
  } else if (/æ²¡æœ‰å¤§ç‰Œ|æ²¡å¤§ç‰Œ/.test(lowerText)) {
    cardInfo.hasBigCards = false;
  }
  
  // æ£€æµ‹æ‰‹ç‰Œæ•°é‡
  const countMatch = lowerText.match(/(\d+)å¼ /);
  if (countMatch) {
    cardInfo.handCount = parseInt(countMatch[1]);
  }
  
  // æ£€æµ‹åˆ†ç‰Œ
  if (/åˆ†ç‰Œ|æœ‰åˆ†/.test(lowerText)) {
    cardInfo.hasScoreCards = true;
  }
  
  return cardInfo;
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šå®æ—¶ç­–ç•¥è°ƒæ•´ç³»ç»Ÿ

### 4.1 ç­–ç•¥è°ƒæ•´æ¶æ„

```typescript
interface StrategyAdjustment {
  type: 'weight' | 'parameter' | 'preference';
  target: string;              // è°ƒæ•´ç›®æ ‡
  value: number;               // è°ƒæ•´å€¼
  duration?: number;           // æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œundefinedè¡¨ç¤ºæ°¸ä¹…
  priority: number;            // ä¼˜å…ˆçº§
}

interface AIDynamicStrategy {
  // åŸºç¡€ç­–ç•¥ï¼ˆMCTSé…ç½®ï¼‰
  baseConfig: MCTSConfig;
  
  // åŠ¨æ€è°ƒæ•´
  adjustments: StrategyAdjustment[];
  
  // ç†è§£çš„ä¿¡æ¯
  understoodInfo: ExtractedInfo;
  
  // æœ€åæ›´æ–°æ—¶é—´
  lastUpdateTime: number;
}
```

### 4.2 ç­–ç•¥è°ƒæ•´è§„åˆ™

#### è§„åˆ™1ï¼šæ ¹æ®ç­–ç•¥è¯·æ±‚è°ƒæ•´

```typescript
function adjustStrategyFromIntent(
  intent: CommunicationIntent,
  extractedInfo: ExtractedInfo,
  currentStrategy: AIDynamicStrategy
): StrategyAdjustment[] {
  const adjustments: StrategyAdjustment[] = [];
  
  if (intent.type === 'strategy_request') {
    if (intent.parameters.action === 'play' && intent.parameters.target === 'me') {
      // äººç±»ç©å®¶è¯´"æˆ‘æ¥å‡º"
      adjustments.push({
        type: 'preference',
        target: 'action_preference',
        value: -50,  // é™ä½AIå‡ºç‰Œçš„å€¾å‘
        priority: 10
      });
    } else if (intent.parameters.action === 'play' && intent.parameters.target === 'teammate') {
      // äººç±»ç©å®¶è¯´"ä½ æ¥å‡º"
      adjustments.push({
        type: 'preference',
        target: 'action_preference',
        value: +50,  // æé«˜AIå‡ºç‰Œçš„å€¾å‘
        priority: 10
      });
    } else if (intent.parameters.action === 'hold') {
      // äººç±»ç©å®¶è¯´"ä¿ç•™å¤§ç‰Œ"
      adjustments.push({
        type: 'weight',
        target: 'bigCardPreservationWeight',
        value: +0.3,  // æé«˜ä¿ç•™å¤§ç‰Œçš„æƒé‡
        priority: 8
      });
    }
  }
  
  return adjustments;
}
```

#### è§„åˆ™2ï¼šæ ¹æ®ç‰Œä¿¡æ¯è°ƒæ•´

```typescript
function adjustStrategyFromCardInfo(
  cardInfo: ExtractedInfo['cardInfo'],
  currentStrategy: AIDynamicStrategy
): StrategyAdjustment[] {
  const adjustments: StrategyAdjustment[] = [];
  
  if (cardInfo?.hasBomb) {
    // äººç±»ç©å®¶æœ‰ç‚¸å¼¹ï¼ŒAIå¯ä»¥æ›´æ¿€è¿›
    adjustments.push({
      type: 'weight',
      target: 'aggressiveWeight',
      value: +0.2,
      priority: 7
    });
    adjustments.push({
      type: 'preference',
      target: 'supportHuman',
      value: +30,  // æé«˜æ”¯æ´äººç±»ç©å®¶çš„å€¾å‘
      priority: 9
    });
  }
  
  if (cardInfo?.hasBigCards === false) {
    // äººç±»ç©å®¶æ²¡æœ‰å¤§ç‰Œï¼ŒAIåº”è¯¥æ›´ä¸»åŠ¨
    adjustments.push({
      type: 'preference',
      target: 'action_preference',
      value: +40,  // æé«˜AIå‡ºç‰Œçš„å€¾å‘
      priority: 9
    });
  }
  
  if (cardInfo?.handCount !== undefined) {
    // æ ¹æ®äººç±»ç©å®¶æ‰‹ç‰Œæ•°é‡è°ƒæ•´
    if (cardInfo.handCount < 8) {
      // äººç±»ç©å®¶æ‰‹ç‰Œå°‘ï¼ŒAIåº”è¯¥æ”¯æ´
      adjustments.push({
        type: 'weight',
        target: 'supportWeight',
        value: +0.3,
        priority: 8
      });
    }
  }
  
  return adjustments;
}
```

#### è§„åˆ™3ï¼šæ ¹æ®é…åˆè¯·æ±‚è°ƒæ•´

```typescript
function adjustStrategyFromCooperation(
  cooperationInfo: ExtractedInfo['cooperationInfo'],
  currentStrategy: AIDynamicStrategy
): StrategyAdjustment[] {
  const adjustments: StrategyAdjustment[] = [];
  
  if (cooperationInfo?.requestType === 'support') {
    // äººç±»ç©å®¶è¯·æ±‚æ”¯æ´
    adjustments.push({
      type: 'weight',
      target: 'supportWeight',
      value: +0.4,  // å¤§å¹…æé«˜æ”¯æ´æƒé‡
      priority: 10
    });
    adjustments.push({
      type: 'preference',
      target: 'action_preference',
      value: +50,  // æé«˜AIå‡ºç‰Œçš„å€¾å‘
      priority: 10
    });
  } else if (cooperationInfo?.requestType === 'attack') {
    // äººç±»ç©å®¶è¯·æ±‚æ”»å‡»
    adjustments.push({
      type: 'weight',
      target: 'aggressiveWeight',
      value: +0.3,
      priority: 9
    });
  }
  
  return adjustments;
}
```

### 4.3 åº”ç”¨åˆ°MCTSè¯„ä¼°å‡½æ•°

```typescript
function evaluateActionWithAdjustments(
  action: Card[],
  hand: Card[],
  lastPlay: Play | null,
  state: GameState,
  dynamicStrategy: AIDynamicStrategy
): number {
  // åŸºç¡€è¯„ä¼°
  let score = evaluateActionQuality(action, hand, lastPlay, state);
  
  // åº”ç”¨åŠ¨æ€è°ƒæ•´
  for (const adjustment of dynamicStrategy.adjustments) {
    switch (adjustment.type) {
      case 'weight':
        score = applyWeightAdjustment(score, adjustment, action, state);
        break;
        
      case 'preference':
        score = applyPreferenceAdjustment(score, adjustment, action, state);
        break;
        
      case 'parameter':
        score = applyParameterAdjustment(score, adjustment, action, state);
        break;
    }
  }
  
  // åº”ç”¨ç†è§£çš„ä¿¡æ¯
  score = applyUnderstoodInfo(score, dynamicStrategy.understoodInfo, action, state);
  
  return score;
}

// åº”ç”¨æƒé‡è°ƒæ•´
function applyWeightAdjustment(
  baseScore: number,
  adjustment: StrategyAdjustment,
  action: Card[],
  state: GameState
): number {
  if (adjustment.target === 'bigCardPreservationWeight') {
    // å¦‚æœä¿ç•™äº†å¤§ç‰Œï¼ŒåŠ åˆ†
    const preservesBigCards = checkPreservesBigCards(action, state);
    if (preservesBigCards) {
      return baseScore + (adjustment.value * 50);  // æŒ‰æƒé‡è°ƒæ•´
    }
  }
  
  if (adjustment.target === 'supportWeight') {
    // å¦‚æœæ”¯æ´äº†äººç±»ç©å®¶ï¼ŒåŠ åˆ†
    const supportsHuman = checkSupportsHuman(action, state);
    if (supportsHuman) {
      return baseScore + (adjustment.value * 50);
    }
  }
  
  return baseScore;
}

// åº”ç”¨åå¥½è°ƒæ•´
function applyPreferenceAdjustment(
  baseScore: number,
  adjustment: StrategyAdjustment,
  action: Card[],
  state: GameState
): number {
  if (adjustment.target === 'action_preference') {
    // ç›´æ¥è°ƒæ•´åŸºç¡€åˆ†
    return baseScore + adjustment.value;
  }
  
  if (adjustment.target === 'supportHuman') {
    // å¦‚æœæ”¯æ´äººç±»ç©å®¶ï¼ŒåŠ åˆ†
    if (checkSupportsHuman(action, state)) {
      return baseScore + adjustment.value;
    }
  }
  
  return baseScore;
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šå®æ—¶å“åº”æœºåˆ¶

### 5.1 å®æ—¶æ›´æ–°æµç¨‹

```typescript
class RealTimeStrategyManager {
  private dynamicStrategies: Map<number, AIDynamicStrategy> = new Map();
  
  // å¤„ç†äººç±»ç©å®¶çš„æ¶ˆæ¯
  async processHumanMessage(
    message: HumanChatMessage,
    gameState: GameState
  ): Promise<void> {
    // 1. ç†è§£æ„å›¾
    const intent = await recognizeIntent(message.content, gameState);
    
    // 2. æå–ä¿¡æ¯
    const extractedInfo = extractInfoFromText(message.content, intent, gameState);
    
    // 3. ç”Ÿæˆç­–ç•¥è°ƒæ•´
    const adjustments = generateStrategyAdjustments(intent, extractedInfo, gameState);
    
    // 4. æ›´æ–°AIç­–ç•¥
    const aiPlayerId = getTeammateId(message.playerId, gameState);
    this.updateAIStrategy(aiPlayerId, adjustments, extractedInfo);
    
    // 5. ç«‹å³ç”Ÿæ•ˆï¼ˆå¦‚æœAIæ­£åœ¨å†³ç­–ï¼‰
    if (isAITurn(aiPlayerId, gameState)) {
      this.triggerImmediateUpdate(aiPlayerId);
    }
  }
  
  // æ›´æ–°AIç­–ç•¥
  private updateAIStrategy(
    aiPlayerId: number,
    adjustments: StrategyAdjustment[],
    understoodInfo: ExtractedInfo
  ): void {
    const currentStrategy = this.dynamicStrategies.get(aiPlayerId) || {
      baseConfig: getDefaultMCTSConfig(),
      adjustments: [],
      understoodInfo: {},
      lastUpdateTime: Date.now()
    };
    
    // åˆå¹¶è°ƒæ•´
    currentStrategy.adjustments = mergeAdjustments(
      currentStrategy.adjustments,
      adjustments
    );
    
    // æ›´æ–°ç†è§£çš„ä¿¡æ¯
    currentStrategy.understoodInfo = mergeExtractedInfo(
      currentStrategy.understoodInfo,
      understoodInfo
    );
    
    currentStrategy.lastUpdateTime = Date.now();
    
    // ä¿å­˜
    this.dynamicStrategies.set(aiPlayerId, currentStrategy);
  }
  
  // ç«‹å³è§¦å‘æ›´æ–°
  private triggerImmediateUpdate(aiPlayerId: number): void {
    // å¦‚æœAIæ­£åœ¨è¿è¡ŒMCTSï¼Œä¸­æ–­å¹¶é‡æ–°å¼€å§‹
    this.interruptMCTS(aiPlayerId);
    
    // è§¦å‘æ–°çš„å†³ç­–
    this.triggerNewDecision(aiPlayerId);
  }
}
```

### 5.2 MCTSä¸­æ–­å’Œé‡å¯

```typescript
class InterruptibleMCTS {
  private runningMCTS: Map<number, { promise: Promise<Card[] | null>; cancel: () => void }> = new Map();
  
  async runMCTS(
    playerId: number,
    hand: Card[],
    lastPlay: Play | null,
    config: MCTSConfig,
    dynamicStrategy: AIDynamicStrategy
  ): Promise<Card[] | null> {
    // å¦‚æœå·²æœ‰æ­£åœ¨è¿è¡Œçš„MCTSï¼Œå…ˆå–æ¶ˆ
    const existing = this.runningMCTS.get(playerId);
    if (existing) {
      existing.cancel();
    }
    
    // åˆ›å»ºå¯ä¸­æ–­çš„Promise
    let cancelled = false;
    const cancel = () => {
      cancelled = true;
    };
    
    const promise = this.runInterruptibleMCTS(hand, lastPlay, config, dynamicStrategy, () => cancelled);
    
    this.runningMCTS.set(playerId, { promise, cancel });
    
    try {
      const result = await promise;
      this.runningMCTS.delete(playerId);
      return result;
    } catch (error) {
      this.runningMCTS.delete(playerId);
      throw error;
    }
  }
  
  private async runInterruptibleMCTS(
    hand: Card[],
    lastPlay: Play | null,
    config: MCTSConfig,
    dynamicStrategy: AIDynamicStrategy,
    isCancelled: () => boolean
  ): Promise<Card[] | null> {
    // åœ¨æ¯æ¬¡è¿­ä»£ä¸­æ£€æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
    for (let i = 0; i < config.iterations; i++) {
      if (isCancelled()) {
        throw new Error('MCTSè¢«ä¸­æ–­');
      }
      
      // è¿è¡Œä¸€æ¬¡è¿­ä»£ï¼Œä½¿ç”¨åŠ¨æ€ç­–ç•¥
      this.runOneIteration(hand, lastPlay, config, dynamicStrategy);
      
      // è®©å‡ºæ§åˆ¶æƒï¼Œå…è®¸ä¸­æ–­
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    return this.selectBestAction(hand, lastPlay, config, dynamicStrategy);
  }
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šUIç»„ä»¶è®¾è®¡

### 6.1 èŠå¤©è¾“å…¥ç»„ä»¶

```typescript
interface CommunicationInputProps {
  onSend: (message: string) => void;
  isEnabled: boolean;
  teammateName?: string;
}
```

**UIè®¾è®¡**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¬ å’Œ ${teammateName} æ²Ÿé€š               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚ [è¾“å…¥æ¡†]                                â”‚
â”‚ "æˆ‘æ¥å‡ºï¼Œä½ ä¿ç•™å¤§ç‰Œ"                    â”‚
â”‚                                         â”‚
â”‚ [å¿«æ·çŸ­è¯­]                              â”‚
â”‚ â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”          â”‚
â”‚ â”‚æˆ‘æ¥â”‚ â”‚ä½ æ¥â”‚ â”‚ä¿ç•™â”‚ â”‚æˆ‘æœ‰â”‚          â”‚
â”‚ â”‚å‡º  â”‚ â”‚å‡º  â”‚ â”‚å¤§ç‰Œâ”‚ â”‚ç‚¸å¼¹â”‚          â”‚
â”‚ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜          â”‚
â”‚                                         â”‚
â”‚ [å‘é€] [å–æ¶ˆ]                           â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 AIç†è§£åé¦ˆç»„ä»¶

```typescript
interface AIUnderstandingFeedbackProps {
  message: HumanChatMessage;
  processedMessage: ProcessedMessage;
  onConfirm?: () => void;
}
```

**UIè®¾è®¡**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¤– AIç†è§£äº†ä½ çš„è¯                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚ ğŸ’¬ ä½ è¯´ï¼š"æˆ‘æ¥å‡ºï¼Œä½ ä¿ç•™å¤§ç‰Œ"          â”‚
â”‚                                         â”‚
â”‚ âœ… ç†è§£ç»“æœï¼š                           â”‚
â”‚ â€¢ æ„å›¾ï¼šç­–ç•¥è¯·æ±‚                        â”‚
â”‚ â€¢ åŠ¨ä½œï¼šä½ æ¥ä¿ç•™å¤§ç‰Œ                    â”‚
â”‚ â€¢ ç½®ä¿¡åº¦ï¼š85%                           â”‚
â”‚                                         â”‚
â”‚ ğŸ“Š AIå°†è°ƒæ•´ç­–ç•¥ï¼š                       â”‚
â”‚ â€¢ æé«˜ä¿ç•™å¤§ç‰Œæƒé‡ +30%                â”‚
â”‚ â€¢ é™ä½å‡ºç‰Œå€¾å‘ -20%                    â”‚
â”‚                                         â”‚
â”‚ [ç¡®è®¤] [å–æ¶ˆ]                           â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå®æ–½æ­¥éª¤

### é˜¶æ®µ1ï¼šåŸºç¡€è¾“å…¥ç³»ç»Ÿï¼ˆ2-3å¤©ï¼‰

1. âœ… åˆ›å»ºèŠå¤©è¾“å…¥ç»„ä»¶
2. âœ… å®ç°å¿«æ·çŸ­è¯­
3. âœ… é›†æˆåˆ°æ¸¸æˆç•Œé¢

### é˜¶æ®µ2ï¼šNLUç†è§£ç³»ç»Ÿï¼ˆ3-4å¤©ï¼‰

1. âœ… å®ç°æ„å›¾è¯†åˆ«ï¼ˆè§„åˆ™å¼•æ“ï¼‰
2. âœ… é›†æˆLLMæ„å›¾åˆ†æ
3. âœ… å®ç°ä¿¡æ¯æå–

### é˜¶æ®µ3ï¼šç­–ç•¥è°ƒæ•´ç³»ç»Ÿï¼ˆ3-4å¤©ï¼‰

1. âœ… è®¾è®¡åŠ¨æ€ç­–ç•¥è°ƒæ•´æœºåˆ¶
2. âœ… é›†æˆåˆ°MCTSè¯„ä¼°å‡½æ•°
3. âœ… å®ç°å®æ—¶æ›´æ–°

### é˜¶æ®µ4ï¼šæµ‹è¯•å’Œä¼˜åŒ–ï¼ˆ2-3å¤©ï¼‰

1. âœ… å•å…ƒæµ‹è¯•
2. âœ… é›†æˆæµ‹è¯•
3. âœ… ç”¨æˆ·ä½“éªŒæµ‹è¯•

---

## ğŸ“Š æ€»ç»“

### æ ¸å¿ƒåŠŸèƒ½

1. âœ… **äººç±»ç©å®¶å¯ä»¥è¾“å…¥**ï¼šæ–‡å­—æˆ–å¿«æ·çŸ­è¯­
2. âœ… **AIç†è§£äººç±»çš„è¯**ï¼šæ„å›¾è¯†åˆ« + ä¿¡æ¯æå–
3. âœ… **å®æ—¶è°ƒæ•´ç­–ç•¥**ï¼šåŠ¨æ€æƒé‡ + ç«‹å³ç”Ÿæ•ˆ

### é¢„æœŸæ•ˆæœ

- âœ… çœŸæ­£çš„å›¢é˜Ÿé…åˆ
- âœ… å¢å¼ºæ¸¸æˆä½“éªŒ
- âœ… å¿ƒç†åšå¼ˆæ·±åº¦

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- ä¿¡æ¯æå–è®¾è®¡ï¼š`docs/review/information-extraction-from-chat.md`
- å›¢é˜Ÿä½œæˆ˜è®¾è®¡ï¼š`docs/review/team-scoring-and-chat-redesign.md`
- å¤šæ–¹æ¡ˆå»ºè®®è®¾è®¡ï¼š`docs/design/multiple-ai-suggestions-redesign.md`

