# ç®€åŒ–é€‰ç‰Œç³»ç»Ÿè®¾è®¡ V2ï¼ˆæœ€ç»ˆæ–¹æ¡ˆï¼‰

## ğŸ“‹ éœ€æ±‚ç¡®è®¤

1. âœ… **ç‚¹å‡»å¢åŠ **: ä¸éœ€è¦åŠ å‡æŒ‰é’®ï¼Œç›´æ¥ç‚¹å‡»ç‚¹æ•°å°±å¢åŠ é€‰æ‹©æ•°é‡ï¼ˆå¯ä»¥å–æ¶ˆï¼‰
2. âœ… **å°é¢„è§ˆ**: æ˜¾ç¤ºå½“å‰é€‰å–çš„ç‰Œï¼Œå æ”¾æ•ˆæœï¼Œä¸éœ€è¦èŠ±è‰²ï¼ˆå¦‚6ä¸ª9æ˜¾ç¤º6å¼ 9å åœ¨ä¸€èµ·ï¼‰ï¼Œå¯ä»¥å–æ¶ˆ
3. âœ… **æ™ºèƒ½é«˜äº®**: é«˜äº®å¯å‡ºç‰Œçš„ç‚¹æ•°
4. âœ… **åŒå‡»å…¨é€‰**: åŒå‡»å¯ä»¥å…¨é€‰/å…¨ä¸é€‰è¯¥ç‚¹æ•°

## ğŸ¯ è®¾è®¡æ–¹æ¡ˆ

### UIå¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç‚¹æ•°åŒºåŸŸï¼ˆå¯ç‚¹å‡»ï¼Œé«˜äº®å¯å‡ºç‰Œï¼‰              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  9  â”‚  â”‚ 10 â”‚  â”‚  J  â”‚  â”‚  Q  â”‚  ...   â”‚
â”‚  â”‚ (7) â”‚  â”‚ (5)â”‚  â”‚ (3) â”‚  â”‚ (2) â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜        â”‚
â”‚    â†‘        â†‘        â†‘        â†‘            â”‚
â”‚  ç‚¹å‡»å¢åŠ   ç‚¹å‡»å¢åŠ   ç‚¹å‡»å¢åŠ   ç‚¹å‡»å¢åŠ      â”‚
â”‚  åŒå‡»å…¨é€‰  åŒå‡»å…¨é€‰  åŒå‡»å…¨é€‰  åŒå‡»å…¨é€‰     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é€‰ä¸­é¢„è§ˆåŒºåŸŸï¼ˆå æ”¾æ•ˆæœï¼‰                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  9  â”‚  â”‚  9  â”‚  â”‚ 10  â”‚  ...           â”‚
â”‚  â”‚  9  â”‚  â”‚  9  â”‚  â”‚ 10  â”‚                â”‚
â”‚  â”‚  9  â”‚  â”‚  9  â”‚  â”‚     â”‚                â”‚
â”‚  â”‚  9  â”‚  â”‚     â”‚  â”‚     â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜                â”‚
â”‚    Ã—6       Ã—4       Ã—2                    â”‚
â”‚  [å–æ¶ˆ]   [å–æ¶ˆ]   [å–æ¶ˆ]                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### äº¤äº’è®¾è®¡

#### 1. ç‚¹æ•°åŒºåŸŸ
- **å•å‡»**: å¢åŠ è¯¥ç‚¹æ•°çš„é€‰æ‹©æ•°é‡ï¼ˆå¦‚æœå·²é€‰æ»¡ï¼Œåˆ™å–æ¶ˆé€‰æ‹©ï¼‰
- **åŒå‡»**: å…¨é€‰/å…¨ä¸é€‰è¯¥ç‚¹æ•°
- **è§†è§‰åé¦ˆ**:
  - å¯å‡ºç‰Œçš„ç‚¹æ•°ï¼šç»¿è‰²è¾¹æ¡†/èƒŒæ™¯é«˜äº®
  - å·²é€‰æ‹©çš„ç‚¹æ•°ï¼šæ˜¾ç¤ºé€‰æ‹©æ•°é‡ï¼ŒèƒŒæ™¯è‰²å˜åŒ–
  - æœªé€‰æ‹©çš„ç‚¹æ•°ï¼šæ­£å¸¸æ˜¾ç¤º

#### 2. é¢„è§ˆåŒºåŸŸ
- **æ˜¾ç¤º**: é€‰ä¸­çš„ç‰Œä»¥å æ”¾æ•ˆæœæ˜¾ç¤ºï¼ˆä¸éœ€è¦èŠ±è‰²ï¼‰
- **å–æ¶ˆ**: æ¯ä¸ªé¢„è§ˆå¡ç‰‡ç»„æœ‰å–æ¶ˆæŒ‰é’®
- **å æ”¾æ•ˆæœ**: åŒç‚¹æ•°çš„ç‰Œå åœ¨ä¸€èµ·ï¼Œæ˜¾ç¤ºæ•°é‡

## ğŸ’» å®ç°æ–¹æ¡ˆ

### 1. Hookè®¾è®¡

```typescript
// src/hooks/useSimplifiedCardSelection.ts

interface UseSimplifiedCardSelectionResult {
  // é€‰ç‰ŒçŠ¶æ€ï¼šMap<rank, count>
  selection: Map<number, number>;
  
  // æ“ä½œå‡½æ•°
  clickRank: (rank: number) => void;        // å•å‡»ï¼šå¢åŠ é€‰æ‹©
  doubleClickRank: (rank: number) => void;  // åŒå‡»ï¼šå…¨é€‰/å…¨ä¸é€‰
  cancelRank: (rank: number) => void;       // å–æ¶ˆæŸä¸ªç‚¹æ•°çš„é€‰æ‹©
  clearSelection: () => void;               // æ¸…ç©ºæ‰€æœ‰é€‰æ‹©
  
  // è·å–é€‰ä¸­çš„Cardå¯¹è±¡ï¼ˆç”¨äºå‡ºç‰Œï¼‰
  getSelectedCards: () => Card[];
  
  // éªŒè¯å’Œæç¤º
  validateSelection: () => ValidationResult;
  getPlayableRanks: () => number[];  // å¯å‡ºç‰Œçš„ç‚¹æ•°
}

export function useSimplifiedCardSelection(
  game: Game,
  humanPlayer: Player | undefined
): UseSimplifiedCardSelectionResult {
  const [selection, setSelection] = useState<Map<number, number>>(new Map());
  
  // æŒ‰ç‚¹æ•°åˆ†ç»„çš„æ‰‹ç‰Œ
  const groupedHand = useMemo(() => {
    if (!humanPlayer) return new Map<number, Card[]>();
    const groups = new Map<number, Card[]>();
    humanPlayer.hand.forEach(card => {
      const rank = card.rank;
      if (!groups.has(rank)) {
        groups.set(rank, []);
      }
      groups.get(rank)!.push(card);
    });
    return groups;
  }, [humanPlayer?.hand]);
  
  // å•å‡»ï¼šå¢åŠ é€‰æ‹©ï¼ˆå¦‚æœå·²é€‰æ»¡ï¼Œåˆ™å–æ¶ˆï¼‰
  const clickRank = useCallback((rank: number) => {
    setSelection(prev => {
      const newSelection = new Map(prev);
      const currentCount = newSelection.get(rank) || 0;
      const maxCount = groupedHand.get(rank)?.length || 0;
      
      if (currentCount >= maxCount) {
        // å·²é€‰æ»¡ï¼Œå–æ¶ˆé€‰æ‹©
        newSelection.delete(rank);
      } else {
        // å¢åŠ é€‰æ‹©
        newSelection.set(rank, currentCount + 1);
      }
      return newSelection;
    });
  }, [groupedHand]);
  
  // åŒå‡»ï¼šå…¨é€‰/å…¨ä¸é€‰
  const doubleClickRank = useCallback((rank: number) => {
    setSelection(prev => {
      const newSelection = new Map(prev);
      const currentCount = newSelection.get(rank) || 0;
      const maxCount = groupedHand.get(rank)?.length || 0;
      
      if (currentCount === maxCount) {
        // å…¨é€‰ â†’ å…¨ä¸é€‰
        newSelection.delete(rank);
      } else {
        // å…¨ä¸é€‰ â†’ å…¨é€‰
        newSelection.set(rank, maxCount);
      }
      return newSelection;
    });
  }, [groupedHand]);
  
  // å–æ¶ˆæŸä¸ªç‚¹æ•°çš„é€‰æ‹©
  const cancelRank = useCallback((rank: number) => {
    setSelection(prev => {
      const newSelection = new Map(prev);
      newSelection.delete(rank);
      return newSelection;
    });
  }, []);
  
  // æ¸…ç©ºæ‰€æœ‰é€‰æ‹©
  const clearSelection = useCallback(() => {
    setSelection(new Map());
  }, []);
  
  // è·å–é€‰ä¸­çš„Cardå¯¹è±¡ï¼ˆç”¨äºå‡ºç‰Œï¼‰
  const getSelectedCards = useCallback((): Card[] => {
    const selectedCards: Card[] = [];
    const hand = humanPlayer?.hand || [];
    
    selection.forEach((count, rank) => {
      const cardsOfRank = hand.filter(c => c.rank === rank);
      // é€‰æ‹©å‰countå¼ ï¼ˆä¸éœ€è¦å…³å¿ƒå…·ä½“æ˜¯å“ªå¼ ï¼Œå› ä¸ºæ²¡èŠ±è‰²åŒºåˆ«ï¼‰
      selectedCards.push(...cardsOfRank.slice(0, count));
    });
    
    return selectedCards;
  }, [selection, humanPlayer?.hand]);
  
  // éªŒè¯é€‰æ‹©
  const validateSelection = useCallback((): ValidationResult => {
    const selectedCards = getSelectedCards();
    // ä½¿ç”¨ç°æœ‰çš„éªŒè¯é€»è¾‘
    return validateCardSelection(selectedCards, game);
  }, [getSelectedCards, game]);
  
  // è·å–å¯å‡ºç‰Œçš„ç‚¹æ•°
  const getPlayableRanks = useCallback((): number[] => {
    const lastPlay = getLastPlay(game);
    const hand = humanPlayer?.hand || [];
    
    // ä½¿ç”¨ç°æœ‰çš„findPlayableCardsé€»è¾‘
    const playableCards = findPlayableCards(hand, lastPlay);
    
    // æå–å¯å‡ºç‰Œçš„ç‚¹æ•°
    const playableRanks = new Set<number>();
    playableCards.forEach(cards => {
      cards.forEach(card => {
        playableRanks.add(card.rank);
      });
    });
    
    return Array.from(playableRanks);
  }, [game, humanPlayer?.hand]);
  
  return {
    selection,
    clickRank,
    doubleClickRank,
    cancelRank,
    clearSelection,
    getSelectedCards,
    validateSelection,
    getPlayableRanks
  };
}
```

### 2. ç»„ä»¶è®¾è®¡

```typescript
// src/components/game/SimplifiedHandCards.tsx

import React, { useMemo, useCallback, useState } from 'react';
import { Card } from '../../types/card';
import { CardComponent } from '../CardComponent';
import { useSimplifiedCardSelection } from '../../hooks/useSimplifiedCardSelection';
import { Game } from '../../utils/Game';
import './SimplifiedHandCards.css';

interface SimplifiedHandCardsProps {
  game: Game;
  humanPlayer: Player | undefined;
}

export const SimplifiedHandCards: React.FC<SimplifiedHandCardsProps> = ({
  game,
  humanPlayer
}) => {
  const {
    selection,
    clickRank,
    doubleClickRank,
    cancelRank,
    clearSelection,
    getSelectedCards,
    getPlayableRanks
  } = useSimplifiedCardSelection(game, humanPlayer);
  
  // æŒ‰ç‚¹æ•°åˆ†ç»„çš„æ‰‹ç‰Œ
  const groupedHand = useMemo(() => {
    if (!humanPlayer) return new Map<number, Card[]>();
    const groups = new Map<number, Card[]>();
    humanPlayer.hand.forEach(card => {
      const rank = card.rank;
      if (!groups.has(rank)) {
        groups.set(rank, []);
      }
      groups.get(rank)!.push(card);
    });
    return groups;
  }, [humanPlayer?.hand]);
  
  const playableRanks = getPlayableRanks();
  const sortedRanks = useMemo(() => {
    return Array.from(groupedHand.keys()).sort((a, b) => a - b);
  }, [groupedHand]);
  
  const getRankDisplay = (rank: number): string => {
    const rankMap: { [key: number]: string } = {
      3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
      11: 'J', 12: 'Q', 13: 'K', 14: 'A', 15: '2',
      16: 'å°', 17: 'å¤§'
    };
    return rankMap[rank] || String(rank);
  };
  
  // å¤„ç†å•å‡»ï¼ˆå»¶è¿Ÿå¤„ç†ï¼Œç”¨äºåŒºåˆ†å•å‡»å’ŒåŒå‡»ï¼‰
  const [clickTimers, setClickTimers] = useState<Map<number, NodeJS.Timeout>>(new Map());
  
  const handleRankClick = useCallback((rank: number) => {
    const timer = setTimeout(() => {
      clickRank(rank);
      setClickTimers(prev => {
        const newTimers = new Map(prev);
        newTimers.delete(rank);
        return newTimers;
      });
    }, 300); // 300mså»¶è¿Ÿï¼Œç”¨äºåŒºåˆ†å•å‡»å’ŒåŒå‡»
    
    setClickTimers(prev => {
      const newTimers = new Map(prev);
      const existingTimer = newTimers.get(rank);
      if (existingTimer) {
        clearTimeout(existingTimer);
      }
      newTimers.set(rank, timer);
      return newTimers;
    });
  }, [clickRank]);
  
  const handleRankDoubleClick = useCallback((rank: number) => {
    // æ¸…é™¤å•å‡»å®šæ—¶å™¨
    const timer = clickTimers.get(rank);
    if (timer) {
      clearTimeout(timer);
      setClickTimers(prev => {
        const newTimers = new Map(prev);
        newTimers.delete(rank);
        return newTimers;
      });
    }
    
    // æ‰§è¡ŒåŒå‡»æ“ä½œ
    doubleClickRank(rank);
  }, [doubleClickRank, clickTimers]);
  
  // è·å–é¢„è§ˆæ•°æ®ï¼ˆæŒ‰ç‚¹æ•°åˆ†ç»„çš„é€‰æ‹©ï¼‰
  const previewData = useMemo(() => {
    const preview: Array<{ rank: number; count: number; cards: Card[] }> = [];
    const hand = humanPlayer?.hand || [];
    
    selection.forEach((count, rank) => {
      const cardsOfRank = hand.filter(c => c.rank === rank);
      if (cardsOfRank.length > 0) {
        preview.push({
          rank,
          count,
          cards: cardsOfRank.slice(0, count)
        });
      }
    });
    
    return preview.sort((a, b) => a.rank - b.rank);
  }, [selection, humanPlayer?.hand]);
  
  return (
    <div className="simplified-hand-wrapper">
      {/* ç‚¹æ•°é€‰æ‹©åŒºåŸŸ */}
      <div className="rank-selection-area">
        <div className="rank-selection-grid">
          {sortedRanks.map(rank => {
            const cards = groupedHand.get(rank) || [];
            const totalCount = cards.length;
            const selectedCount = selection.get(rank) || 0;
            const isPlayable = playableRanks.includes(rank);
            const rankDisplay = getRankDisplay(rank);
            const hasSelected = selectedCount > 0;
            
            return (
              <div
                key={rank}
                className={`rank-item ${hasSelected ? 'has-selected' : ''} ${isPlayable ? 'playable' : ''}`}
                onClick={() => handleRankClick(rank)}
                onDoubleClick={() => handleRankDoubleClick(rank)}
                title={`å•å‡»å¢åŠ é€‰æ‹©ï¼ŒåŒå‡»å…¨é€‰/å…¨ä¸é€‰ (${totalCount}å¼ )`}
              >
                <div className="rank-label">{rankDisplay}</div>
                <div className="rank-count">
                  {hasSelected ? (
                    <span className="selected-count">{selectedCount}</span>
                  ) : (
                    <span className="total-count">{totalCount}</span>
                  )}
                </div>
                {hasSelected && (
                  <div className="selected-indicator">âœ“</div>
                )}
              </div>
            );
          })}
        </div>
      </div>
      
      {/* é€‰ä¸­é¢„è§ˆåŒºåŸŸ */}
      {previewData.length > 0 && (
        <div className="selection-preview-area">
          <div className="preview-header">
            <span>å·²é€‰æ‹© ({getSelectedCards().length}å¼ )</span>
            <button
              className="btn-clear-all"
              onClick={clearSelection}
              title="æ¸…ç©ºæ‰€æœ‰é€‰æ‹©"
            >
              æ¸…ç©º
            </button>
          </div>
          <div className="preview-cards">
            {previewData.map(({ rank, count, cards }) => {
              const rankDisplay = getRankDisplay(rank);
              const firstCard = cards[0]; // å–ç¬¬ä¸€å¼ ä½œä¸ºä»£è¡¨ï¼ˆä¸éœ€è¦èŠ±è‰²ï¼‰
              
              return (
                <div
                  key={rank}
                  className="preview-group"
                >
                  <div className="preview-stack">
                    {/* å æ”¾æ•ˆæœï¼šæ˜¾ç¤ºå¤šå¼ ç‰Œ */}
                    {cards.map((card, index) => (
                      <div
                        key={card.id}
                        className="preview-card-stacked"
                        style={{
                          transform: `translateY(${-index * 8}px)`,
                          zIndex: index + 1
                        }}
                      >
                        <CardComponent
                          card={firstCard} // æ‰€æœ‰ç‰Œéƒ½æ˜¾ç¤ºç›¸åŒçš„ç‚¹æ•°ï¼ˆä¸éœ€è¦èŠ±è‰²ï¼‰
                          selected={true}
                          size="small"
                        />
                      </div>
                    ))}
                    {/* æ•°é‡æ ‡ç­¾ */}
                    <div className="preview-count-badge">{count}</div>
                  </div>
                  {/* å–æ¶ˆæŒ‰é’® */}
                  <button
                    className="btn-cancel-rank"
                    onClick={() => cancelRank(rank)}
                    title={`å–æ¶ˆé€‰æ‹© ${rankDisplay}`}
                  >
                    Ã—
                  </button>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
};
```

### 3. æ ·å¼è®¾è®¡

```css
/* src/components/game/SimplifiedHandCards.css */

.simplified-hand-wrapper {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 16px;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* ç‚¹æ•°é€‰æ‹©åŒºåŸŸ */
.rank-selection-area {
  width: 100%;
}

.rank-selection-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.rank-item {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 60px;
  min-height: 80px;
  padding: 12px 8px;
  border: 2px solid #ddd;
  border-radius: 8px;
  background: white;
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
}

.rank-item:hover {
  border-color: #999;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.rank-item.has-selected {
  border-color: #4CAF50;
  background: #f0f8f0;
}

.rank-item.playable {
  border-color: #2196F3;
  box-shadow: 0 0 12px rgba(33, 150, 243, 0.4);
  animation: playable-pulse 2s infinite;
}

@keyframes playable-pulse {
  0%, 100% {
    box-shadow: 0 0 12px rgba(33, 150, 243, 0.4);
  }
  50% {
    box-shadow: 0 0 20px rgba(33, 150, 243, 0.6);
  }
}

.rank-label {
  font-size: 28px;
  font-weight: bold;
  color: #333;
  margin-bottom: 4px;
}

.rank-count {
  font-size: 14px;
  color: #666;
}

.rank-count .selected-count {
  color: #4CAF50;
  font-weight: bold;
  font-size: 16px;
}

.rank-count .total-count {
  color: #999;
}

.selected-indicator {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 20px;
  height: 20px;
  background: #4CAF50;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
}

/* é€‰ä¸­é¢„è§ˆåŒºåŸŸ */
.selection-preview-area {
  border-top: 2px solid #eee;
  padding-top: 16px;
}

.preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  font-size: 14px;
  font-weight: bold;
  color: #333;
}

.btn-clear-all {
  padding: 6px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s;
}

.btn-clear-all:hover {
  background: #f0f0f0;
  border-color: #999;
}

.preview-cards {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
}

.preview-group {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.preview-stack {
  position: relative;
  width: 60px;
  height: 84px; /* æ ¹æ®å æ”¾æ•ˆæœè®¡ç®— */
}

.preview-card-stacked {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.preview-count-badge {
  position: absolute;
  bottom: -8px;
  right: -8px;
  width: 24px;
  height: 24px;
  background: #4CAF50;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  z-index: 100;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.btn-cancel-rank {
  width: 24px;
  height: 24px;
  border: 1px solid #ddd;
  border-radius: 50%;
  background: white;
  color: #999;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.btn-cancel-rank:hover {
  background: #ff4444;
  color: white;
  border-color: #ff4444;
}
```

## âœ… åŠŸèƒ½æ¸…å•

- [x] å•å‡»ç‚¹æ•°å¢åŠ é€‰æ‹©
- [x] åŒå‡»ç‚¹æ•°å…¨é€‰/å…¨ä¸é€‰
- [x] é€‰ä¸­é¢„è§ˆï¼ˆå æ”¾æ•ˆæœï¼‰
- [x] å–æ¶ˆå•ä¸ªç‚¹æ•°é€‰æ‹©
- [x] æ¸…ç©ºæ‰€æœ‰é€‰æ‹©
- [x] æ™ºèƒ½é«˜äº®å¯å‡ºç‰Œç‚¹æ•°
- [x] æ˜¾ç¤ºé€‰æ‹©æ•°é‡
- [x] ä¸éœ€è¦èŠ±è‰²æ˜¾ç¤º

## ğŸ¯ ä¸‹ä¸€æ­¥

1. å®ç° `useSimplifiedCardSelection` Hook
2. å®ç° `SimplifiedHandCards` ç»„ä»¶
3. é›†æˆåˆ° `MultiPlayerGameBoard`
4. æµ‹è¯•å’Œä¼˜åŒ–

