import { useState, useCallback, useEffect, useRef } from 'react';
import { Card, Play, GameStatus, Player, PlayerType, RoundPlayRecord, RoundRecord } from '../types/card';
import { dealCards, canPlayCards, canBeat, hasPlayableCards, findPlayableCards, calculateCardsScore, isScoreCard } from '../utils/cardUtils';
import { aiChoosePlay, AIConfig } from '../utils/aiPlayer';
import { voiceService } from '../services/voiceService';
import { announcePlay, announcePass } from '../services/systemAnnouncementService';
import { generateRandomVoiceConfig } from '../services/voiceConfigService';
import { triggerScoreStolenReaction, triggerScoreEatenCurseReaction, triggerFinishFirstReaction, triggerFinishMiddleReaction, triggerFinishLastReaction, clearChatMessages, triggerTaunt } from '../services/chatService';
import { findNextActivePlayer, checkGameFinished, MultiPlayerGameState, checkAllRemainingPlayersPassed } from '../utils/gameStateUtils';
import { applyFinalGameRules } from '../utils/gameRules';
import { handleGameEnd } from '../utils/gameEndHandler';
import { handleDunScoring, createPlayRecord, updatePlayerAfterPlay, triggerGoodPlayReactions } from '../utils/playManager';
import { getGameConfig } from '../config/gameConfig';
import { calculatePlayAnimationPosition } from '../utils/animationUtils';
import { validateCardIntegritySimple } from '../services/scoringService';
import { Round } from '../utils/Round';
import { processPlayAsync } from '../utils/asyncPlayHandler';
import { ensureRoundInTracker } from '../utils/cardTrackerUtils';
import { cardTracker } from '../services/cardTrackerService';
import { RoundScheduler } from '../utils/roundScheduler';
import { getCurrentRound, getCurrentRoundNumber, getCurrentRoundPlays, getCurrentRoundScore, getLastPlay, getLastPlayPlayerIndex } from '../utils/gameStateUtils';

// æ¸¸æˆå®Œæ•´è®°å½•ï¼ˆç”¨äºä¿å­˜ï¼‰
export interface GameRecord {
  gameId: string; // æ¸¸æˆå”¯ä¸€ID
  startTime: number; // æ¸¸æˆå¼€å§‹æ—¶é—´
  endTime?: number; // æ¸¸æˆç»“æŸæ—¶é—´
  playerCount: number; // ç©å®¶æ•°é‡
  initialHands: Card[][]; // åˆå§‹æ‰‹ç‰Œï¼ˆæŒ‰ç©å®¶é¡ºåºï¼‰
  allRounds: RoundRecord[]; // æ‰€æœ‰è½®æ¬¡çš„è®°å½•
  finishOrder: number[]; // ç©å®¶å‡ºå®Œç‰Œçš„é¡ºåº
  finalRankings: any[]; // æœ€ç»ˆæ’å
  winner: number; // è·èƒœè€…ID
}

// MultiPlayerGameState å·²ç§»åŠ¨åˆ° gameStateUtils.ts

export interface GameConfig {
  playerCount: number; // 4-8äºº
  humanPlayerIndex: number; // äººç±»ç©å®¶åœ¨playersæ•°ç»„ä¸­çš„ç´¢å¼•
  aiConfigs: { 
    apiKey?: string; // ä¸éœ€è¦API Keyï¼ˆOpenAIå·²ç¦ç”¨ï¼‰
    strategy?: 'aggressive' | 'conservative' | 'balanced';
    algorithm?: 'simple' | 'mcts';
    mctsIterations?: number;
  }[];
  dealingAlgorithm?: 'random' | 'fair' | 'favor-human' | 'favor-ai' | 'balanced-score' | 'clustered'; // å‘ç‰Œç®—æ³•
  skipDealingAnimation?: boolean; // æ˜¯å¦è·³è¿‡å‘ç‰ŒåŠ¨ç”»
  dealingSpeed?: number; // å‘ç‰Œé€Ÿåº¦ï¼ˆæ¯«ç§’/å¼ ï¼‰
  sortOrder?: 'asc' | 'desc' | 'grouped'; // æ’åºè§„åˆ™
  cardTrackerEnabled?: boolean; // æ˜¯å¦å¯ç”¨è®¡åˆ†å™¨
}

export function useMultiPlayerGame() {
  // è·å–æ¸¸æˆé…ç½®
  const gameConfig = getGameConfig();
  const announcementDelay = gameConfig.announcementDelay;
  
  // ä» localStorage è¯»å–è®¡åˆ†å™¨å¼€å…³é…ç½®ï¼ˆé»˜è®¤å…³é—­ï¼‰
  const cardTrackerEnabled = (() => {
    const saved = localStorage.getItem('cardTrackerEnabled');
    return saved !== null ? saved === 'true' : false;
  })();

  const [gameState, setGameState] = useState<MultiPlayerGameState>({
    status: GameStatus.WAITING,
    players: [],
    currentPlayerIndex: 0,
    winner: null,
    playerCount: 0,
    finishOrder: [],
    rounds: [],
    currentRoundIndex: -1
  });

  const gameStateRef = useRef(gameState);
  useEffect(() => {
    gameStateRef.current = gameState;
  }, [gameState]);

  // ç”¨äºé˜²æ­¢é‡å¤è§¦å‘AIå‡ºç‰Œçš„æ ‡å¿—
  const isAITurnProcessingRef = useRef(false);

  // å‘ç‰ŒçŠ¶æ€
  const [isDealing, setIsDealing] = useState(false);
  const [pendingGameConfig, setPendingGameConfig] = useState<GameConfig | null>(null);
  
  // æ‰˜ç®¡çŠ¶æ€
  const [isAutoPlay, setIsAutoPlay] = useState(false);
  const isAutoPlayRef = useRef(false);
  
  // åŒæ­¥ isAutoPlay åˆ° ref
  useEffect(() => {
    isAutoPlayRef.current = isAutoPlay;
  }, [isAutoPlay]);

  // åˆ›å»ºè½®æ¬¡è°ƒåº¦å™¨
  const schedulerRef = useRef<RoundScheduler | null>(null);
  
  // è·å–äººç±»ç©å®¶ç´¢å¼•ï¼ˆä»æ¸¸æˆçŠ¶æ€ä¸­è·å–ï¼‰
  const humanPlayerIndex = gameState.players.findIndex(p => p.isHuman);
  
  // åˆå§‹åŒ–è°ƒåº¦å™¨
  useEffect(() => {
    if (!schedulerRef.current) {
      schedulerRef.current = new RoundScheduler({
        isAutoPlay: isAutoPlay,
        humanPlayerIndex: humanPlayerIndex >= 0 ? humanPlayerIndex : 0,
        getGameState: () => gameStateRef.current
      });
      
      // è®¾ç½®å›è°ƒå‡½æ•°ï¼ˆå»¶è¿Ÿè®¾ç½®ï¼Œå› ä¸º playNextTurnInternal è¿˜æœªå®šä¹‰ï¼‰
      // å°†åœ¨ playNextTurnInternal å®šä¹‰åè®¾ç½®
    } else {
      // æ›´æ–°é…ç½®
      schedulerRef.current.updateConfig({
        isAutoPlay: isAutoPlay,
        humanPlayerIndex: humanPlayerIndex >= 0 ? humanPlayerIndex : 0
      });
    }
    
    // æ›´æ–°è½®æ¬¡å·
    if (schedulerRef.current && gameState.status === GameStatus.PLAYING) {
      const currentRoundNumber = getCurrentRoundNumber(gameState);
      schedulerRef.current.updateRoundNumber(currentRoundNumber);
    }
  }, [isAutoPlay, humanPlayerIndex, gameState.status]);

  // è¾…åŠ©å‡½æ•°å·²ç§»åŠ¨åˆ° gameStateUtils.ts

  // AIè‡ªåŠ¨å‡ºç‰Œï¼ˆä¸‹ä¸€ä¸ªå›åˆï¼‰- å†…éƒ¨å®ç°
  const playNextTurnInternal = useCallback(async (targetPlayerIndex?: number) => {
    const currentState = gameStateRef.current;
    
    if (currentState.status !== GameStatus.PLAYING) {
      return;
    }

    // ç­‰å¾…æ­£åœ¨å¤„ç†çš„å‡ºç‰Œå®Œæˆ
    const currentRound = getCurrentRound(currentState);
    if (currentRound?.hasProcessingPlay()) {
      try {
        await currentRound.waitForPlayProcess(15000);
      } catch (error) {
        // è¶…æ—¶æˆ–é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œ
      }
    }

    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ’­æ”¾è¯­éŸ³ï¼Œå¦‚æœæ˜¯ï¼Œç­‰å¾…å®Œæˆ
    // ç¡®ä¿AIç­‰å¾…ä¸Šå®¶æŠ¥ç‰Œå®Œæˆåå†å‡ºç‰Œï¼ˆæ— è®ºä¸Šå®¶æ˜¯AIè¿˜æ˜¯çœŸäººï¼‰
    // æ³¨æ„ï¼šç”±äºæŠ¥ç‰Œä½¿ç”¨speakImmediateä¼šç«‹å³æ’­æ”¾å¹¶ä¸­æ–­å…¶ä»–è¯­éŸ³ï¼Œ
    // æ‰€ä»¥å¦‚æœisSpeakingä¸ºtrueï¼Œå¾ˆå¯èƒ½å°±æ˜¯æ­£åœ¨æŠ¥ç‰Œ
    if (voiceService.isCurrentlySpeaking()) {
      // è®°å½•åˆå§‹çŠ¶æ€ï¼Œç”¨äºæ£€æŸ¥æ¸¸æˆæ˜¯å¦å·²ç»æ›´æ–°
      const initialState = gameStateRef.current;
      const initialPlayerIndex = initialState.currentPlayerIndex;
      
      // ç­‰å¾…è¯­éŸ³æ’­æ”¾å®Œæˆï¼ˆæœ€å¤šç­‰å¾…1ç§’ï¼Œé¿å…å¡ä½ï¼‰
      await new Promise<void>((resolve) => {
        const checkInterval = setInterval(() => {
          // å¦‚æœè¯­éŸ³æ’­æ”¾å®Œæˆï¼Œæˆ–è€…æ¸¸æˆçŠ¶æ€å·²ç»æ›´æ–°ï¼ˆè¯´æ˜ä¸Šå®¶å·²ç»å‡ºç‰Œï¼‰ï¼Œå°±ç»§ç»­
          const currentState = gameStateRef.current;
          const stateChanged = currentState.currentPlayerIndex !== initialPlayerIndex;
          
          if (!voiceService.isCurrentlySpeaking() || stateChanged) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 50); // æ¯50msæ£€æŸ¥ä¸€æ¬¡
        
        // è¶…æ—¶ä¿æŠ¤ï¼š1ç§’åå¼ºåˆ¶ç»§ç»­ï¼ˆé¿å…å¡ä½æ¸¸æˆï¼‰
        setTimeout(() => {
          clearInterval(checkInterval);
          resolve();
        }, 1000);
      });
      
      // å†ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿è¯­éŸ³å®Œå…¨ç»“æŸï¼ˆä½†ä¸è¶…è¿‡200msï¼‰
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // å¦‚æœæœ‰ Round å¯¹è±¡ï¼Œç­‰å¾…æœ€çŸ­é—´éš”
    if (currentRound) {
      await currentRound.waitForMinInterval();
    }

    // å¦‚æœæŒ‡å®šäº†ç›®æ ‡ç©å®¶ç´¢å¼•ï¼Œä½¿ç”¨å®ƒï¼›å¦åˆ™ä½¿ç”¨å½“å‰ç©å®¶ç´¢å¼•
    const playerIndex = targetPlayerIndex !== undefined ? targetPlayerIndex : currentState.currentPlayerIndex;
    const currentPlayer = currentState.players[playerIndex];
    if (!currentPlayer) return;
    
    // å¦‚æœæŒ‡å®šäº†ç›®æ ‡ç©å®¶ç´¢å¼•ä¸”ä¸å½“å‰ç©å®¶ç´¢å¼•ä¸åŒï¼Œæ›´æ–°çŠ¶æ€
    if (targetPlayerIndex !== undefined && targetPlayerIndex !== currentState.currentPlayerIndex) {
      setGameState(prev => {
        return {
          ...prev,
          currentPlayerIndex: targetPlayerIndex
        };
      });
      // ç­‰å¾…çŠ¶æ€æ›´æ–°
      await new Promise(resolve => setTimeout(resolve, 50));
      // é‡æ–°è·å–çŠ¶æ€
      const updatedState = gameStateRef.current;
      if (updatedState.currentPlayerIndex !== targetPlayerIndex) {
        console.warn('[playNextTurnInternal] çŠ¶æ€æ›´æ–°å¤±è´¥ï¼Œä½¿ç”¨å½“å‰ç©å®¶ç´¢å¼•', {
          targetPlayerIndex,
          actualPlayerIndex: updatedState.currentPlayerIndex,
          timestamp: Date.now()
        });
        return;
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€ä¸ªç©å®¶è¿˜æ²¡å‡ºå®Œï¼Œå¦‚æœæ˜¯ï¼Œä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†
    const remainingPlayers = currentState.players.filter(p => p.hand.length > 0);
    if (remainingPlayers.length === 1) {
      const lastPlayerIndex = remainingPlayers[0].id;
      const lastPlayer = currentState.players[lastPlayerIndex];
      
      // è§¦å‘æœ€åä¸€åè¾“äº†çš„èŠå¤©ååº”ï¼ˆä¼ é€’å®Œæ•´æ¸¸æˆçŠ¶æ€ï¼‰
      triggerFinishLastReaction(lastPlayer, undefined, currentState).catch(console.error);
      
      // ä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†æ¸¸æˆç»“æŸé€»è¾‘
      // å®ƒä¼šï¼š1. ä¿å­˜å½“å‰è½®æ¬¡è®°å½• 2. å¤„ç†æœ«æ¸¸æ‰‹ç‰Œå’Œåˆ†æ•° 3. åˆ›å»ºæ¨¡æ‹Ÿè½® 4. æ¸…ç©ºæ‰€æœ‰æ‰‹ç‰Œ 5. éªŒè¯ç‰Œæ•° 6. åº”ç”¨æœ€ç»ˆè§„åˆ™
      setGameState(prev => {
        if (prev.status !== GameStatus.PLAYING) return prev;
        
        try {
          const gameEndResult = handleGameEnd({
            prevState: {
              status: prev.status,
              players: prev.players,
              finishOrder: prev.finishOrder || [],
              rounds: prev.rounds,
              currentRoundIndex: prev.currentRoundIndex,
              initialHands: prev.initialHands
            },
            lastPlayerIndex,
            lastPlayer,
            context: 'playNextTurn - åªå‰©ä¸€ä¸ªç©å®¶'
          });
          
          return {
            ...prev,
            ...gameEndResult
          };
        } catch (error) {
          console.error('[playNextTurn] handleGameEnd å¤±è´¥:', error);
          // å¦‚æœ handleGameEnd å¤±è´¥ï¼Œå›é€€åˆ°åŸæ¥çš„é€»è¾‘
          return prev;
        }
      });
      return;
    }
    
    // å¦‚æœå½“å‰ç©å®¶å·²ç»å‡ºå®Œç‰Œäº†ï¼Œè·³è¿‡åˆ°ä¸‹ä¸€ä¸ªç©å®¶
    if (currentPlayer.hand.length === 0) {
      setGameState(prev => {
        if (prev.status !== GameStatus.PLAYING) return prev;
        
        const nextPlayerIndex = findNextActivePlayer(prev.currentPlayerIndex, prev.players, prev.playerCount);
        
        // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
        if (nextPlayerIndex === null) {
          const allFinished = prev.players.every(p => p.hand.length === 0);
          if (allFinished) {
            const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(prev.players, prev.finishOrder || []);
            const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
            
            return {
              ...prev,
              status: GameStatus.FINISHED,
              players: finalPlayers,
              winner: winner.player.id,
              finalRankings
            };
          }
          return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
        }
        
        // ç¡®ä¿ä¿ç•™ currentRoundPlaysï¼Œä» currentRound è·å–æœ€æ–°æ•°æ®
        const currentRoundPlays = prev.currentRound?.getPlays() 
          ? Array.from(prev.currentRound.getPlays())
          : (prev.currentRoundPlays || []);
        
        console.warn(`[playNextTurnInternal] â†’ æ›´æ–° currentPlayerIndex`, {
          nextPlayerIndex,
          prevCurrentPlayerIndex: prev.currentPlayerIndex,
          currentRoundPlaysCount: currentRoundPlays.length,
          roundPlaysFromRound: prev.currentRound?.getPlays().length || 0,
          roundNumber: prev.roundNumber,
          timestamp: Date.now()
        });
        
        return {
          ...prev,
          currentPlayerIndex: nextPlayerIndex,
          currentRoundPlays: currentRoundPlays
        };
      });
      
      // é€’å½’è°ƒç”¨ï¼Œå¤„ç†ä¸‹ä¸€ä¸ªç©å®¶ï¼ˆé€šè¿‡è°ƒåº¦å™¨ï¼‰
      // æ³¨æ„ï¼šnextPlayerIndex åœ¨ setGameState å›è°ƒä¸­å®šä¹‰ï¼Œéœ€è¦ä»çŠ¶æ€ä¸­è·å–
      setGameState(prev => {
        const nextPlayer = findNextActivePlayer(prev.currentPlayerIndex, prev.players, prev.playerCount);
        if (schedulerRef.current && nextPlayer !== null) {
          schedulerRef.current.scheduleNextTurn(nextPlayer, 0);
        }
        return prev;
      });
      return;
    }
    
    // å¦‚æœæ˜¯äººç±»ç©å®¶
    if (currentPlayer.type !== PlayerType.AI) {
      // å¦‚æœå¼€å¯äº†æ‰˜ç®¡ï¼Œåˆ™è‡ªåŠ¨ä½¿ç”¨AIå»ºè®®å‡ºç‰Œ
      if (isAutoPlayRef.current) {
        // æ‰˜ç®¡æ¨¡å¼ï¼šè‡ªåŠ¨ä½¿ç”¨AIå»ºè®®å‡ºç‰Œ
        const humanPlayer = currentState.players.find(p => p.isHuman);
        if (humanPlayer && currentPlayer.id === humanPlayer.id) {
          const lastPlay = getLastPlay(currentState);
          const currentRoundScore = getCurrentRoundScore(currentState);
          
          console.log('[AutoPlay] ğŸ¤– æ‰˜ç®¡æ¨¡å¼ï¼šè½®åˆ°äººç±»ç©å®¶ï¼Œè‡ªåŠ¨å‡ºç‰Œ', {
            currentPlayerIndex: playerIndex,
            playerName: currentPlayer.name,
            handCount: currentPlayer.hand.length,
            lastPlay: lastPlay,
            isAutoPlay: isAutoPlayRef.current
          });
          
          // è·å–AIé…ç½®ï¼ˆä»æ¸¸æˆé…ç½®ä¸­è·å–ï¼‰
          const aiConfig: AIConfig = {
            strategy: 'balanced',
            algorithm: 'simple'
          };
          
          // ä½¿ç”¨AIé€»è¾‘è‡ªåŠ¨å‡ºç‰Œ
          try {
            const aiConfigWithContext = {
              ...aiConfig,
              perfectInformation: true,
              allPlayerHands: currentState.players.map(p => [...p.hand]),
              currentRoundScore: currentRoundScore || 0,
              playerCount: currentState.playerCount
            };
            
            console.log('[AutoPlay] ğŸ¤– è°ƒç”¨AIå»ºè®®ï¼Œæ‰‹ç‰Œæ•°:', currentPlayer.hand.length, 'ä¸Šå®¶å‡ºç‰Œ:', lastPlay);
            const suggestedCards = await aiChoosePlay(
              currentPlayer.hand,
              lastPlay,
              aiConfigWithContext
            );
            
            if (suggestedCards && suggestedCards.length > 0) {
              console.log('[AutoPlay] âœ… AIå»ºè®®å‡ºç‰Œ:', suggestedCards.length, 'å¼ ', suggestedCards.map(c => `${c.suit}-${c.rank}`));
              // è‡ªåŠ¨å‡ºç‰Œ
              const playSuccess = playerPlay(playerIndex, suggestedCards);
              console.log('[AutoPlay] ğŸ“ playerPlay è¿”å›å€¼:', playSuccess);
              if (playSuccess) {
                console.log('[AutoPlay] âœ… å‡ºç‰ŒæˆåŠŸï¼Œç­‰å¾…çŠ¶æ€æ›´æ–°åç»§ç»­ä¸‹ä¸€å›åˆ');
                // å‡ºç‰ŒæˆåŠŸï¼Œé€šè¿‡è°ƒåº¦å™¨ç»§ç»­
                if (schedulerRef.current) {
                setTimeout(() => {
                    schedulerRef.current?.scheduleNextTurn(undefined, 0);
                }, 1500);
                }
                return;
              } else {
                console.warn('[AutoPlay] âš ï¸ playerPlay è¿”å› falseï¼Œå¯èƒ½å‡ºç‰Œå¤±è´¥ï¼Œå°è¯•è¦ä¸èµ·');
                // å‡ºç‰Œå¤±è´¥ï¼Œå°è¯•è¦ä¸èµ·ï¼ˆä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ï¼‰
                await playerPassAsync(playerIndex);
                return;
              }
            } else {
              console.log('[AutoPlay] âš ï¸ AIæ²¡æœ‰å»ºè®®å‡ºç‰Œï¼Œè‡ªåŠ¨è¦ä¸èµ·');
              // æ²¡æœ‰å¯å‡ºçš„ç‰Œï¼Œè‡ªåŠ¨è¦ä¸èµ·ï¼ˆä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ï¼‰
              await playerPassAsync(playerIndex);
              return;
            }
          } catch (error) {
            console.error('[AutoPlay] âŒ æ‰˜ç®¡å‡ºç‰Œå¤±è´¥:', error);
            // å‡ºé”™æ—¶è‡ªåŠ¨è¦ä¸èµ·ï¼ˆä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ï¼‰
            await playerPassAsync(playerIndex);
            return;
          }
        }
      }
      // ä¸æ˜¯æ‰˜ç®¡æ¨¡å¼ï¼Œç­‰å¾…ç©å®¶æ‰‹åŠ¨æ“ä½œ
      return;
    }
    
    // AIç©å®¶
    if (!currentPlayer.aiConfig) return;

    try {
      // å‡†å¤‡å®Œå…¨ä¿¡æ¯æ¨¡å¼çš„é…ç½®
      const aiConfigWithContext = {
        ...currentPlayer.aiConfig,
        perfectInformation: true, // å¯ç”¨å®Œå…¨ä¿¡æ¯æ¨¡å¼ï¼ˆ"ä½œå¼Š"æ¨¡å¼ï¼‰
        allPlayerHands: currentState.players.map(p => [...p.hand]), // æ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œ
        currentRoundScore: getCurrentRoundScore(currentState) || 0, // å½“å‰è½®æ¬¡ç´¯è®¡åˆ†æ•°
        playerCount: currentState.playerCount // ç©å®¶æ€»æ•°
      };
      
      const lastPlayForAI = getLastPlay(currentState);
      const aiCards = await aiChoosePlay(
        currentPlayer.hand,
        lastPlayForAI,
        aiConfigWithContext
      );

      // å¦‚æœæœ‰ Round å¯¹è±¡ï¼Œä½¿ç”¨å¼‚æ­¥å‡ºç‰Œå¤„ç†
      if (currentRound) {
        if (aiCards && aiCards.length > 0) {
          // ä½¿ç”¨å¼‚æ­¥å‡ºç‰Œ
          await playerPlayAsync(playerIndex, aiCards);
        } else {
          // ä½¿ç”¨å¼‚æ­¥è¦ä¸èµ·
          await playerPassAsync(playerIndex);
        }
        return;
      }

      // å¦åˆ™ä½¿ç”¨æ—§çš„åŒæ­¥é€»è¾‘ï¼ˆå‘åå…¼å®¹ï¼‰
      // æ£€æŸ¥ AI æ˜¯å¦æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼ˆå¼ºåˆ¶å‡ºç‰Œè§„åˆ™ï¼‰
      const lastPlay = lastPlayForAI;
      const hasPlayable = hasPlayableCards(currentPlayer.hand, lastPlay);
      
      if (!aiCards || aiCards.length === 0) {
        // AIè¦ä¸èµ· - ä½†éœ€è¦éªŒè¯æ˜¯å¦çœŸçš„æ²¡æœ‰èƒ½æ‰“è¿‡çš„ç‰Œ
        // å¦‚æœæ˜¯æ¥é£ï¼ˆlastPlayä¸ºnullï¼‰ï¼Œåº”è¯¥å¼ºåˆ¶å‡ºç‰Œï¼›å¦‚æœæœ‰lastPlayä¸”æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¹Ÿåº”è¯¥å¼ºåˆ¶å‡ºç‰Œ
        if (hasPlayable) {
          // å¦‚æœæœ‰èƒ½æ‰“è¿‡çš„ç‰Œä½†æ²¡æœ‰é€‰æ‹©ï¼Œå¼ºåˆ¶é€‰æ‹©æœ€å°çš„èƒ½æ‰“è¿‡çš„ç‰Œ
          const allPlayable = findPlayableCards(currentPlayer.hand, lastPlay);
          if (allPlayable.length > 0) {
            // é€‰æ‹©ç¬¬ä¸€ä¸ªèƒ½æ‰“è¿‡çš„ç‰Œï¼ˆAIåº”è¯¥é€‰æ‹©ï¼Œè¿™é‡Œä½œä¸ºfallbackï¼‰
            const fallbackCards = allPlayable[0];
            const fallbackPlay = canPlayCards(fallbackCards);
            if (fallbackPlay) {
              // ä½¿ç”¨fallbackå‡ºç‰Œ
              setGameState(prev => {
                if (prev.status !== GameStatus.PLAYING) return prev;
                if (prev.currentPlayerIndex !== currentState.currentPlayerIndex) return prev;

                const player = prev.players[currentState.currentPlayerIndex];
                if (!player) return prev;

                // è®¡ç®—è¿™æ‰‹ç‰Œçš„åˆ†å€¼
                const fallbackScore = calculateCardsScore(fallbackCards);
                
                // è®¡ç®—åŠ¨ç”»ä½ç½®
                const animationPosition = calculatePlayAnimationPosition(
                  currentState.currentPlayerIndex,
                  prev.players,
                  prev.players.findIndex(p => p.isHuman),
                  prev.playerCount
                );
                
                // å¤„ç†å¢©çš„è®¡åˆ†
                const { updatedPlayers: playersAfterDun, dunScore } = handleDunScoring(
                  prev.players,
                  currentState.currentPlayerIndex,
                  fallbackCards,
                  prev.playerCount,
                  fallbackPlay,
                  animationPosition
                );
                
                // æ›´æ–°ç©å®¶æ‰‹ç‰Œå’Œåˆ†æ•°
                const updatedPlayer = updatePlayerAfterPlay(player, fallbackCards, dunScore);
                const newPlayers = [...playersAfterDun];
                newPlayers[currentState.currentPlayerIndex] = updatedPlayer;

                // è®°å½•è¿™ä¸€æ‰‹å‡ºç‰Œ
                const fallbackPlayRecord: RoundPlayRecord = createPlayRecord(
                  currentState.currentPlayerIndex,
                  player.name,
                  fallbackCards,
                  fallbackScore
                );

        // æ’­æ”¾å‡ºç‰Œè¯­éŸ³æç¤ºï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡çŠ¶æ€æ›´æ–°ï¼‰
        // æ³¨æ„ï¼šè¿™é‡Œä¸ç­‰å¾…ï¼Œå› ä¸ºä¼šåœ¨çŠ¶æ€æ›´æ–°åç»Ÿä¸€å¤„ç†

                if (updatedPlayer.hand.length === 0) {
          // ç©å®¶å‡ºå®Œç‰Œï¼Œè®°å½•åˆ°å®Œæˆé¡ºåº
          const newFinishOrder = [...(prev.finishOrder || []), currentState.currentPlayerIndex];
          
          // è®¡ç®—å½“å‰ç©å®¶çš„åæ¬¡ï¼ˆæ ¹æ®å‡ºå®Œç‰Œçš„é¡ºåºï¼Œç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰
          const currentRank = newFinishOrder.length;
          
          // æŠŠè½®æ¬¡åˆ†æ•°ç»™è·èƒœè€…ï¼ˆåŒ…æ‹¬å½“å‰è¿™ä¸€æ‰‹çš„åˆ†ç‰Œï¼‰
                  const finalScore = (player.score || 0) + prev.roundScore + fallbackScore;
                  newPlayers[currentState.currentPlayerIndex] = {
                    ...newPlayers[currentState.currentPlayerIndex],
                    score: finalScore,
                    finishedRank: currentRank // è®¾ç½®åæ¬¡ï¼ˆç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰
                  };
          
          // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸‹ä¸€ä¸ªç©å®¶è¿˜æ²¡å‡ºå®Œï¼ˆå³æœ€åä¸€ä¸ªç©å®¶ï¼‰
          const remainingPlayers = newPlayers.filter(p => p.hand.length > 0);
          
          // å¦‚æœåªå‰©ä¸‹ä¸€ä¸ªç©å®¶è¿˜æ²¡å‡ºå®Œï¼Œä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†
          if (remainingPlayers.length === 1) {
            const lastPlayerIndex = remainingPlayers[0].id;
            const lastPlayer = newPlayers[lastPlayerIndex];
            
            // è§¦å‘æœ€åä¸€åè¾“äº†çš„èŠå¤©ååº”ï¼ˆä¼ é€’å®Œæ•´æ¸¸æˆçŠ¶æ€ï¼‰
            const currentGameState: MultiPlayerGameState = {
              ...prev,
              players: newPlayers
            };
            triggerFinishLastReaction(lastPlayer, undefined, currentGameState).catch(console.error);
            
            // é‡è¦ï¼šåœ¨è°ƒç”¨ handleGameEnd ä¹‹å‰ï¼Œå…ˆå°†å½“å‰ç©å®¶çš„å‡ºç‰Œè®°å½•æ·»åŠ åˆ° currentRoundPlays
            // å› ä¸º handleGameEnd éœ€è¦å®Œæ•´çš„ currentRoundPlays æ¥ä¿å­˜æœ€åä¸€è½®è®°å½•
            const updatedCurrentRoundPlays = [...(prev.currentRoundPlays || []), fallbackPlayRecord];
            
            // ä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†æ¸¸æˆç»“æŸé€»è¾‘
            try {
              const gameEndResult = handleGameEnd({
                prevState: {
                  status: prev.status,
                  players: newPlayers,
                  finishOrder: newFinishOrder,
                  allRounds: prev.allRounds || [],
                  currentRoundPlays: updatedCurrentRoundPlays, // ä½¿ç”¨åŒ…å«å½“å‰å‡ºç‰Œè®°å½•çš„ currentRoundPlays
                  roundNumber: prev.roundNumber,
                  roundScore: prev.roundScore + fallbackScore, // åŒ…å«å½“å‰å‡ºç‰Œçš„åˆ†æ•°
                  lastPlayPlayerIndex: currentState.currentPlayerIndex, // å½“å‰ç©å®¶æ˜¯æœ€åå‡ºç‰Œçš„äºº
                  initialHands: prev.initialHands
                },
                lastPlayerIndex,
                lastPlayer,
                context: 'playerPlay - AIå‡ºå®Œç‰Œååªå‰©ä¸€ä¸ªç©å®¶'
              });
              
              return {
                ...prev,
                ...gameEndResult
              };
            } catch (error) {
              console.error('[playerPlay] handleGameEnd å¤±è´¥:', error);
              return prev;
            }
          }
          
          // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†
          const gameFinished = checkGameFinished(prev, newPlayers, newFinishOrder);
          if (gameFinished) {
            return gameFinished;
          }
          
          // è¿˜æ²¡å…¨éƒ¨å‡ºå®Œï¼Œæ‰¾åˆ°ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼ˆæ¥é£ï¼‰
          const nextPlayerIndex = findNextActivePlayer(currentState.currentPlayerIndex, newPlayers, prev.playerCount);
          
          // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
          if (nextPlayerIndex === null) {
            const allFinished = newPlayers.every(p => p.hand.length === 0);
            if (allFinished) {
              const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, newFinishOrder);
              const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
              
              return {
                ...prev,
                status: GameStatus.FINISHED,
                players: finalPlayers,
                winner: winner.player.id,
                finishOrder: newFinishOrder,
                finalRankings
              };
            }
            return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
          }
          
          // AIå‡ºå®Œç‰Œåï¼Œå¦‚æœæœ€åä¸€æ‰‹ç‰Œæ²¡äººèƒ½æ‰“è¿‡ï¼Œåº”è¯¥ç”±ä¸‹å®¶æ¥é£å‡ºç‰Œï¼ˆæ¸…ç©ºlastPlayï¼‰
          // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å‰©ä½™ç©å®¶éƒ½è¦ä¸èµ·è¿™ä¸€æ‰‹ç‰Œ
          let allCannotBeat = true;
          for (let i = 0; i < newPlayers.length; i++) {
            if (newPlayers[i].hand.length > 0 && i !== currentState.currentPlayerIndex) {
              // æ£€æŸ¥è¿™ä¸ªç©å®¶æ˜¯å¦æœ‰èƒ½æ‰“è¿‡å½“å‰ç‰Œçš„ç‰Œ
              const hasPlayable = hasPlayableCards(newPlayers[i].hand, fallbackPlay);
              if (hasPlayable) {
                allCannotBeat = false;
                break;
              }
            }
          }
          
          const playRecord: RoundPlayRecord = {
              playerId: currentState.currentPlayerIndex,
              playerName: player.name,
              cards: fallbackCards,
              scoreCards: fallbackCards.filter(card => isScoreCard(card)),
              score: fallbackScore
          };
          
          // å¦‚æœæ‰€æœ‰äººéƒ½è¦ä¸èµ·ï¼Œæˆ–è€…å½“å‰ç©å®¶å·²ç»å‡ºå®Œç‰Œï¼Œç”±ä¸‹å®¶æ¥é£å‡ºç‰Œ
          // æ¥é£ï¼šæ¸…ç©ºlastPlayï¼Œè®©ä¸‹å®¶è‡ªç”±å‡ºç‰Œ
          const newState = {
                    ...prev,
                    players: newPlayers,
                    currentPlayerIndex: nextPlayerIndex,
                    lastPlay: allCannotBeat ? null : fallbackPlay, // å¦‚æœæ‰€æœ‰äººéƒ½è¦ä¸èµ·ï¼Œæ¸…ç©ºlastPlayï¼ˆæ¥é£ï¼‰
                    lastPlayPlayerIndex: allCannotBeat ? null : currentState.currentPlayerIndex, // æ¥é£æ—¶æ¸…ç©ºlastPlayPlayerIndex
            roundScore: allCannotBeat ? 0 : (prev.roundScore + fallbackScore), // å¦‚æœæ¥é£ï¼Œåˆ†æ•°å·²ç»ç»™ç©å®¶äº†ï¼Œé‡ç½®è½®æ¬¡åˆ†æ•°
            currentRoundPlays: allCannotBeat ? [] : [...(prev.currentRoundPlays || []), playRecord], // å¦‚æœæ¥é£ï¼Œæ¸…ç©ºå½“å‰è½®æ¬¡è®°å½•
            finishOrder: newFinishOrder
                  };
          
          // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
          const currentPlayerVoice = newPlayers[currentState.currentPlayerIndex]?.voiceConfig;
          announcePlay(fallbackPlay, currentPlayerVoice).catch(console.error);
          
          // æ’­æŠ¥åç­‰å¾…ï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
          if (newPlayers[nextPlayerIndex].type === PlayerType.AI) {
              setTimeout(() => {
                if (schedulerRef.current) {
                  schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
                }
            }, announcementDelay);
          }
          
          return newState;
        }

                const nextPlayerIndex = findNextActivePlayer(currentState.currentPlayerIndex, newPlayers, prev.playerCount);
                
                // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
                if (nextPlayerIndex === null) {
                  const allFinished = newPlayers.every(p => p.hand.length === 0);
                  if (allFinished) {
                    const finishOrder = prev.finishOrder || [];
                    const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, finishOrder);
                    const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
                    
                    return {
                      ...prev,
                      status: GameStatus.FINISHED,
                      players: finalPlayers,
                      winner: winner.player.id,
                      finishOrder: finishOrder,
                      finalRankings
                    };
                  }
                  return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
                }
                
                const newState = {
                  ...prev,
                  players: newPlayers,
                  currentPlayerIndex: nextPlayerIndex,
                  lastPlay: fallbackPlay,
                  lastPlayPlayerIndex: currentState.currentPlayerIndex,
                  roundScore: prev.roundScore + fallbackScore // ç´¯åŠ è½®æ¬¡åˆ†æ•°
                };

                // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
                const currentPlayerVoice = newPlayers[currentState.currentPlayerIndex]?.voiceConfig;
                announcePlay(fallbackPlay, currentPlayerVoice).catch(console.error);
                
                // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
                if (newPlayers[nextPlayerIndex].type === PlayerType.AI) {
                    setTimeout(() => {
                      if (schedulerRef.current) {
                        schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
                      }
                  }, 1500);
                }

                return newState;
              });
              return;
            }
          }
        }
        
        // AIçœŸçš„æ²¡æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œè¦ä¸èµ·
        setGameState(prev => {
          if (prev.status !== GameStatus.PLAYING) return prev;
          if (prev.currentPlayerIndex !== currentState.currentPlayerIndex) return prev;

          const nextPlayerIndex = findNextActivePlayer(prev.currentPlayerIndex, prev.players, prev.playerCount);
          
          // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
          if (nextPlayerIndex === null) {
            const allFinished = prev.players.every(p => p.hand.length === 0);
            if (allFinished) {
              const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(prev.players, prev.finishOrder || []);
              const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
              
              return {
                ...prev,
                status: GameStatus.FINISHED,
                players: finalPlayers,
                winner: winner.player.id,
                finalRankings
              };
            }
            return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
          }
          
          const newPlayers = [...prev.players];
          
          // åªè¦æœ‰äºº"è¦ä¸èµ·"ï¼Œä¸”æœ¬è½®æœ‰å‡ºç‰Œè®°å½•ï¼ˆlastPlayPlayerIndexä¸ä¸ºnullï¼‰ï¼Œåˆ™å¼ºåˆ¶ç»“æŸæœ¬è½®
          if (prev.lastPlayPlayerIndex !== null) {
            // å¼ºåˆ¶ç»“æŸæœ¬è½®ï¼ŒæŠŠåˆ†æ•°ç»™æœ€åå‡ºç‰Œçš„äºº
            const lastPlayer = newPlayers[prev.lastPlayPlayerIndex];
            if (lastPlayer) {
              // åˆ›å»ºè½®æ¬¡è®°å½•
              const roundRecord: RoundRecord = {
                roundNumber: prev.roundNumber,
                plays: [...prev.currentRoundPlays],
                totalScore: prev.roundScore,
                winnerId: prev.lastPlayPlayerIndex,
                winnerName: lastPlayer.name
              };
              
              // å¦‚æœæœ‰åˆ†æ•°ï¼Œç»™æœ€åå‡ºç‰Œçš„äºº
              if (prev.roundScore > 0) {
                newPlayers[prev.lastPlayPlayerIndex] = {
                  ...lastPlayer,
                  score: (lastPlayer.score || 0) + prev.roundScore,
                  wonRounds: [...(lastPlayer.wonRounds || []), roundRecord]
                };
              }
              
              // ä¿å­˜è½®æ¬¡è®°å½•åˆ°allRounds
              const updatedAllRounds = [...(prev.allRounds || []), roundRecord];
              
              // ä¸€è½®ç»“æŸï¼Œç”±èµ¢å®¶å¼€å§‹ä¸‹ä¸€è½®ï¼ˆå¦‚æœèµ¢å®¶å·²å‡ºå®Œï¼Œæ‰¾ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰
              const winnerIndex = prev.lastPlayPlayerIndex;
              let nextActivePlayerIndex: number | null;
              if (newPlayers[winnerIndex]?.hand.length > 0) {
                nextActivePlayerIndex = winnerIndex;
              } else {
                nextActivePlayerIndex = findNextActivePlayer(winnerIndex, newPlayers, prev.playerCount);
              }
              
              // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
              if (nextActivePlayerIndex === null) {
                const allFinished = newPlayers.every(p => p.hand.length === 0);
                if (allFinished) {
                  const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, prev.finishOrder || []);
                  const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
                  
                  return {
                    ...prev,
                    status: GameStatus.FINISHED,
                    players: finalPlayers,
                    winner: winner.player.id,
                    finalRankings
                  };
                }
                return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
              }
              
              const newState = {
                ...prev,
                players: newPlayers,
                currentPlayerIndex: nextActivePlayerIndex, // ç”±èµ¢å®¶ï¼ˆæˆ–ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰å¼€å§‹ä¸‹ä¸€è½®
                lastPlay: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlay
                lastPlayPlayerIndex: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlayPlayerIndex
                roundScore: 0, // æ–°è½®æ¬¡ï¼Œé‡ç½®åˆ†æ•°
                currentRoundPlays: [], // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºå½“å‰è½®æ¬¡å‡ºç‰Œè®°å½•
                roundNumber: prev.roundNumber + 1, // æ–°è½®æ¬¡
                allRounds: updatedAllRounds,
                gameRecord: prev.gameRecord ? {
                  ...prev.gameRecord,
                  allRounds: updatedAllRounds
                } : prev.gameRecord
              };
              
              // å¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œå¼€å§‹ä¸‹ä¸€è½®
              // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
              const currentPlayerVoice = prev.players[prev.currentPlayerIndex]?.voiceConfig;
              // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
              announcePass(currentPlayerVoice).catch(console.error);
              
              // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­ï¼ˆé€šè¿‡è°ƒåº¦å™¨ï¼‰
              if (newPlayers[nextActivePlayerIndex].type === PlayerType.AI) {
                  setTimeout(() => {
                    if (schedulerRef.current) {
                      schedulerRef.current.scheduleNextTurn(nextActivePlayerIndex, 0);
                    }
                }, 1500);
              }
              
              return newState;
            }
          }
          
          // å¦‚æœæ²¡æœ‰lastPlayPlayerIndexï¼ˆæ¥é£çŠ¶æ€ï¼‰ï¼Œæ£€æŸ¥æ˜¯å¦æ‰€æœ‰å‰©ä½™ç©å®¶éƒ½è¦ä¸èµ·
          if (prev.lastPlayPlayerIndex === null) {
            // æ¥é£çŠ¶æ€ä¸‹ï¼Œå¦‚æœæ‰€æœ‰å‰©ä½™ç©å®¶éƒ½è¦ä¸èµ·ï¼Œå¼ºåˆ¶å¼€å§‹æ–°è½®æ¬¡
            const allPassed = checkAllRemainingPlayersPassed(
              prev.currentPlayerIndex,
              prev.players,
              prev.playerCount,
              prev.lastPlay
            );
            
            if (allPassed) {
              // æ‰€æœ‰å‰©ä½™ç©å®¶éƒ½è¦ä¸èµ·ï¼Œå¼ºåˆ¶å¼€å§‹æ–°è½®æ¬¡ï¼Œç”±å½“å‰ç©å®¶å¼€å§‹
              const newState = {
                ...prev,
                players: newPlayers,
                currentPlayerIndex: prev.currentPlayerIndex, // ç”±å½“å‰ç©å®¶å¼€å§‹æ–°è½®æ¬¡
                lastPlay: null,
                lastPlayPlayerIndex: null,
                roundScore: 0,
                currentRoundPlays: [],
                roundNumber: prev.roundNumber + 1
              };
              
              // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
              const currentPlayerVoice = prev.players[prev.currentPlayerIndex]?.voiceConfig;
              announcePass(currentPlayerVoice).catch(console.error);
              
              // 1.5ç§’åï¼Œå¦‚æœå½“å‰ç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­ï¼ˆé€šè¿‡è°ƒåº¦å™¨ï¼‰
              if (prev.players[prev.currentPlayerIndex].type === PlayerType.AI) {
                  setTimeout(() => {
                    if (schedulerRef.current) {
                      schedulerRef.current.scheduleNextTurn(prev.currentPlayerIndex, 0);
                    }
                }, 1500);
              }
              
              return newState;
            }
          }
          
          // æ­£å¸¸ç»§ç»­æ¸¸æˆ
          // æ£€æŸ¥ nextPlayerIndex æ˜¯å¦ä¸º nullï¼ˆæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼‰
          if (nextPlayerIndex === null) {
            // æ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
            const allFinished = newPlayers.every(p => p.hand.length === 0);
            if (allFinished) {
              const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, prev.finishOrder || []);
              const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
              
              return {
                ...prev,
                status: GameStatus.FINISHED,
                players: finalPlayers,
                winner: winner.player.id,
                finalRankings
              };
            }
            return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
          }
          
          let newLastPlay = prev.lastPlay;
          let newLastPlayPlayerIndex = prev.lastPlayPlayerIndex;
          let newRoundScore = prev.roundScore;

          const newState = {
            ...prev,
            players: newPlayers,
            currentPlayerIndex: nextPlayerIndex,
            lastPlay: newLastPlay,
            lastPlayPlayerIndex: newLastPlayPlayerIndex,
            roundScore: newRoundScore,
            currentRoundPlays: nextPlayerIndex === prev.lastPlayPlayerIndex ? [] : prev.currentRoundPlays, // é‡ç½®æˆ–ä¿æŒ
            roundNumber: nextPlayerIndex === prev.lastPlayPlayerIndex ? prev.roundNumber + 1 : prev.roundNumber // æ–°è½®æ¬¡
          };

          // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
          const currentPlayerVoice = prev.players[prev.currentPlayerIndex]?.voiceConfig;
          announcePass(currentPlayerVoice).catch(console.error);
          
          // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­ï¼ˆé€šè¿‡è°ƒåº¦å™¨ï¼‰
          if (prev.players[nextPlayerIndex].type === PlayerType.AI) {
              setTimeout(() => {
                if (schedulerRef.current) {
                  schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
                }
            }, 1500);
          }

          return newState;
        });
        return;
      }

      const play = canPlayCards(aiCards);
      if (!play) {
        setGameState(prev => {
          if (prev.status !== GameStatus.PLAYING) return prev;
          const nextPlayerIndex = findNextActivePlayer(prev.currentPlayerIndex, prev.players, prev.playerCount);
          
          // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
          if (nextPlayerIndex === null) {
            const allFinished = prev.players.every(p => p.hand.length === 0);
            if (allFinished) {
              const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(prev.players, prev.finishOrder || []);
              const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
              
              return {
                ...prev,
                status: GameStatus.FINISHED,
                players: finalPlayers,
                winner: winner.player.id,
                finalRankings
              };
            }
            return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
          }
          
          const newPlayers = [...prev.players];
          
          // åªè¦æœ‰äºº"è¦ä¸èµ·"ï¼Œä¸”æœ¬è½®æœ‰å‡ºç‰Œè®°å½•ï¼ˆlastPlayPlayerIndexä¸ä¸ºnullï¼‰ï¼Œåˆ™å¼ºåˆ¶ç»“æŸæœ¬è½®
          if (prev.lastPlayPlayerIndex !== null) {
            // å¼ºåˆ¶ç»“æŸæœ¬è½®ï¼ŒæŠŠåˆ†æ•°ç»™æœ€åå‡ºç‰Œçš„äºº
            const lastPlayer = newPlayers[prev.lastPlayPlayerIndex];
            if (lastPlayer) {
              // åˆ›å»ºè½®æ¬¡è®°å½•
              const roundRecord: RoundRecord = {
                roundNumber: prev.roundNumber,
                plays: [...prev.currentRoundPlays],
                totalScore: prev.roundScore,
                winnerId: prev.lastPlayPlayerIndex,
                winnerName: lastPlayer.name
              };
              
              // å¦‚æœæœ‰åˆ†æ•°ï¼Œç»™æœ€åå‡ºç‰Œçš„äºº
              if (prev.roundScore > 0) {
                newPlayers[prev.lastPlayPlayerIndex] = {
                  ...lastPlayer,
                  score: (lastPlayer.score || 0) + prev.roundScore,
                  wonRounds: [...(lastPlayer.wonRounds || []), roundRecord]
                };
              }
              
              // ä¿å­˜è½®æ¬¡è®°å½•åˆ°allRounds
              const updatedAllRounds = [...(prev.allRounds || []), roundRecord];
              
              // ä¸€è½®ç»“æŸï¼Œç”±èµ¢å®¶å¼€å§‹ä¸‹ä¸€è½®ï¼ˆå¦‚æœèµ¢å®¶å·²å‡ºå®Œï¼Œæ‰¾ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰
              const winnerIndex = prev.lastPlayPlayerIndex;
              let nextActivePlayerIndex: number | null;
              if (newPlayers[winnerIndex]?.hand.length > 0) {
                nextActivePlayerIndex = winnerIndex;
              } else {
                nextActivePlayerIndex = findNextActivePlayer(winnerIndex, newPlayers, prev.playerCount);
              }
              
              // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
              if (nextActivePlayerIndex === null) {
                const allFinished = newPlayers.every(p => p.hand.length === 0);
                if (allFinished) {
                  const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, prev.finishOrder || []);
                  const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
                  
                  return {
                    ...prev,
                    status: GameStatus.FINISHED,
                    players: finalPlayers,
                    winner: winner.player.id,
                    finalRankings
                  };
                }
                return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
              }
              
              const newState = {
                ...prev,
                players: newPlayers,
                currentPlayerIndex: nextActivePlayerIndex, // ç”±èµ¢å®¶ï¼ˆæˆ–ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰å¼€å§‹ä¸‹ä¸€è½®
                lastPlay: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlay
                lastPlayPlayerIndex: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlayPlayerIndex
                roundScore: 0, // æ–°è½®æ¬¡ï¼Œé‡ç½®åˆ†æ•°
                currentRoundPlays: [], // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºå½“å‰è½®æ¬¡å‡ºç‰Œè®°å½•
                roundNumber: prev.roundNumber + 1, // æ–°è½®æ¬¡
                allRounds: updatedAllRounds,
                gameRecord: prev.gameRecord ? {
                  ...prev.gameRecord,
                  allRounds: updatedAllRounds
                } : prev.gameRecord
              };
              
              // å¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œå¼€å§‹ä¸‹ä¸€è½®
              // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
              const currentPlayerVoice = prev.players[prev.currentPlayerIndex]?.voiceConfig;
              // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
              announcePass(currentPlayerVoice).catch(console.error);
              
              // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­ï¼ˆé€šè¿‡è°ƒåº¦å™¨ï¼‰
              if (newPlayers[nextActivePlayerIndex].type === PlayerType.AI) {
                  setTimeout(() => {
                    if (schedulerRef.current) {
                      schedulerRef.current.scheduleNextTurn(nextActivePlayerIndex, 0);
                    }
                }, 1500);
              }
              
              return newState;
            }
          }
          
          // å¦‚æœæ²¡æœ‰lastPlayPlayerIndexï¼ˆæ¥é£çŠ¶æ€ï¼‰ï¼Œç»§ç»­æ¸¸æˆ
          return {
            ...prev,
            players: newPlayers,
            currentPlayerIndex: nextPlayerIndex,
            lastPlay: prev.lastPlay,
            lastPlayPlayerIndex: prev.lastPlayPlayerIndex,
            roundScore: prev.roundScore,
            currentRoundPlays: prev.currentRoundPlays,
            roundNumber: prev.roundNumber
          };
        });
        return;
      }

      // ç›´æ¥æ›´æ–°çŠ¶æ€å‡ºç‰Œ
      setGameState(prev => {
        if (prev.status !== GameStatus.PLAYING) return prev;
        if (prev.currentPlayerIndex !== currentState.currentPlayerIndex) return prev;

        const player = prev.players[currentState.currentPlayerIndex];
        if (!player) return prev;

        // è®¡ç®—è¿™æ‰‹ç‰Œçš„åˆ†å€¼ï¼ˆç´¯åŠ åˆ°è½®æ¬¡åˆ†æ•°ï¼Œä¸ç›´æ¥ç»™ç©å®¶ï¼‰
        const playScore = calculateCardsScore(aiCards);
        const scoreCards = aiCards.filter(card => isScoreCard(card));

        // æ£€æŸ¥æ˜¯å¦æ˜¯å¢©ï¼Œå¦‚æœæ˜¯ï¼Œåº”ç”¨å¢©çš„è®¡åˆ†è§„åˆ™
        const play = canPlayCards(aiCards);
        if (!play) {
          // å¦‚æœæ— æ³•è¯†åˆ«ç‰Œå‹ï¼Œè·³è¿‡
          return prev;
        }

        // è®¡ç®—åŠ¨ç”»ä½ç½®
        const animationPosition = calculatePlayAnimationPosition(
          currentState.currentPlayerIndex,
          prev.players,
          prev.players.findIndex(p => p.isHuman),
          prev.playerCount
        );

        // å¤„ç†å¢©çš„è®¡åˆ†
        const { updatedPlayers: playersAfterDun, dunScore } = handleDunScoring(
          prev.players,
          currentState.currentPlayerIndex,
          aiCards,
          prev.playerCount,
          play,
          animationPosition
        );
        
        // æ›´æ–°ç©å®¶æ‰‹ç‰Œå’Œåˆ†æ•°
        const updatedPlayer = updatePlayerAfterPlay(player, aiCards, dunScore);
        const newPlayers = [...playersAfterDun];
        newPlayers[currentState.currentPlayerIndex] = updatedPlayer;
        
        // è§¦å‘å¥½ç‰Œååº”
        triggerGoodPlayReactions(player, play, scoreCards);

        // å¦‚æœæ¡åˆ°äº†åˆ†ï¼Œå¯èƒ½è§¦å‘å…¶ä»–ç©å®¶çš„ååº”
        if (playScore > 0) {
          // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–ç©å®¶å¤±å»äº†åˆ†
          const lostScore = playScore;
          // è®¡ç®—æ€»è½®æ¬¡åˆ†æ•°ï¼ˆåŒ…æ‹¬å½“å‰è¿™ä¸€æ‰‹ï¼‰
          const totalRoundScore = prev.roundScore + playScore;
          
          newPlayers.forEach((p, idx) => {
            if (idx !== currentState.currentPlayerIndex && p.hand.length > 0) {
              // æ ¹æ®åˆ†æ•°å¤§å°å†³å®šååº”å¼ºåº¦
              // å¦‚æœåˆ†æ•°è¾ƒå¤§ï¼ˆ>=5åˆ†ï¼‰æˆ–æ€»è½®æ¬¡åˆ†æ•°è¾ƒå¤§ï¼ˆ>=10åˆ†ï¼‰ï¼Œä¼˜å…ˆè§¦å‘è„è¯ååº”
              const shouldCurse = lostScore >= 5 || totalRoundScore >= 10;
              
              if (shouldCurse) {
                // å¤§åˆ†è¢«åƒï¼Œè§¦å‘è„è¯ï¼ˆæ›´æ¿€çƒˆï¼‰- 80%æ¦‚ç‡
                if (Math.random() < 0.8) {
                  triggerScoreEatenCurseReaction(p, lostScore).catch(console.error);
                } else if (Math.random() < 0.3) {
                  // 20%æ¦‚ç‡æ™®é€šæŠ±æ€¨
                  triggerScoreStolenReaction(p, lostScore).catch(console.error);
                }
              } else {
                // å°åˆ†è¢«åƒï¼Œä¹Ÿæœ‰ä¸€å®šæ¦‚ç‡è§¦å‘è„è¯ï¼ˆ30%ï¼‰ï¼Œæˆ–è€…æ™®é€šæŠ±æ€¨ï¼ˆ40%ï¼‰
                if (Math.random() < 0.3) {
                  triggerScoreEatenCurseReaction(p, lostScore).catch(console.error);
                } else if (Math.random() < 0.4) {
                  triggerScoreStolenReaction(p, lostScore).catch(console.error);
                }
              }
            }
          });
        }

        // è®°å½•è¿™ä¸€æ‰‹å‡ºç‰Œ
        const playRecord: RoundPlayRecord = createPlayRecord(
          currentState.currentPlayerIndex,
          player.name,
          aiCards,
          playScore
        );

        // æ’­æ”¾å‡ºç‰Œè¯­éŸ³æç¤ºï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡çŠ¶æ€æ›´æ–°ï¼‰
        // æ³¨æ„ï¼šè¿™é‡Œä¸ç­‰å¾…ï¼Œå› ä¸ºä¼šåœ¨çŠ¶æ€æ›´æ–°åç»Ÿä¸€å¤„ç†

        if (updatedPlayer.hand.length === 0) {
          // ç©å®¶å‡ºå®Œç‰Œï¼Œè®°å½•åˆ°å®Œæˆé¡ºåº
          const newFinishOrder = [...(prev.finishOrder || []), currentState.currentPlayerIndex];
          
          // è®¡ç®—å½“å‰ç©å®¶çš„åæ¬¡ï¼ˆæ ¹æ®å‡ºå®Œç‰Œçš„é¡ºåºï¼Œç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰
          const currentRank = newFinishOrder.length;
          
          // è§¦å‘å‡ºå®Œç‰Œæ—¶çš„èŠå¤©ååº”ï¼ˆä¼ é€’å®Œæ•´æ¸¸æˆçŠ¶æ€ï¼‰
          const finishPosition = newFinishOrder.length;
          const currentGameState: MultiPlayerGameState = {
            ...prev,
            players: newPlayers,
            finishOrder: newFinishOrder
          };
          if (finishPosition === 1) {
            // å¤´åå‡ºå®Œï¼Œå…´å¥‹
            triggerFinishFirstReaction(updatedPlayer, undefined, currentGameState).catch(console.error);
          } else {
            // ä¸­é—´åæ¬¡å‡ºå®Œï¼Œæ„Ÿæ…¨
            triggerFinishMiddleReaction(updatedPlayer, undefined, currentGameState).catch(console.error);
          }
          
          // æŠŠè½®æ¬¡åˆ†æ•°ç»™è·èƒœè€…
          const finalScore = (player.score || 0) + prev.roundScore + playScore;
          // åˆ›å»ºæœ€åä¸€è½®çš„è®°å½•
          const finalRoundRecord: RoundRecord = {
            roundNumber: prev.roundNumber,
            plays: [...prev.currentRoundPlays, playRecord],
            totalScore: prev.roundScore + playScore,
            winnerId: currentState.currentPlayerIndex,
            winnerName: player.name
          };
          newPlayers[currentState.currentPlayerIndex] = {
            ...newPlayers[currentState.currentPlayerIndex],
            score: finalScore,
            wonRounds: [...(player.wonRounds || []), finalRoundRecord],
            finishedRank: currentRank // è®¾ç½®åæ¬¡ï¼ˆç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰
          };
          
          // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸‹ä¸€ä¸ªç©å®¶è¿˜æ²¡å‡ºå®Œï¼ˆå³æœ€åä¸€ä¸ªç©å®¶ï¼‰
          const remainingPlayers = newPlayers.filter(p => p.hand.length > 0);
          
          // å¦‚æœåªå‰©ä¸‹ä¸€ä¸ªç©å®¶è¿˜æ²¡å‡ºå®Œï¼Œä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†
          if (remainingPlayers.length === 1) {
            const lastPlayerIndex = remainingPlayers[0].id;
            const lastPlayer = newPlayers[lastPlayerIndex];
            
            // è§¦å‘æœ€åä¸€åè¾“äº†çš„èŠå¤©ååº”ï¼ˆä¼ é€’å®Œæ•´æ¸¸æˆçŠ¶æ€ï¼‰
            const currentGameState: MultiPlayerGameState = {
              ...prev,
              players: newPlayers
            };
            triggerFinishLastReaction(lastPlayer, undefined, currentGameState).catch(console.error);
            
            // é‡è¦ï¼šåœ¨è°ƒç”¨ handleGameEnd ä¹‹å‰ï¼Œå…ˆå°†å½“å‰ç©å®¶çš„å‡ºç‰Œè®°å½•æ·»åŠ åˆ° currentRoundPlays
            // å› ä¸º handleGameEnd éœ€è¦å®Œæ•´çš„ currentRoundPlays æ¥ä¿å­˜æœ€åä¸€è½®è®°å½•
            const updatedCurrentRoundPlays = [...(prev.currentRoundPlays || []), playRecord];
            
            // ä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†æ¸¸æˆç»“æŸé€»è¾‘
            try {
              const gameEndResult = handleGameEnd({
                prevState: {
                  status: prev.status,
                  players: newPlayers,
                  finishOrder: newFinishOrder,
                  allRounds: prev.allRounds || [],
                  currentRoundPlays: updatedCurrentRoundPlays, // ä½¿ç”¨åŒ…å«å½“å‰å‡ºç‰Œè®°å½•çš„ currentRoundPlays
                  roundNumber: prev.roundNumber,
                  roundScore: prev.roundScore + playScore, // åŒ…å«å½“å‰å‡ºç‰Œçš„åˆ†æ•°
                  lastPlayPlayerIndex: currentState.currentPlayerIndex, // å½“å‰ç©å®¶æ˜¯æœ€åå‡ºç‰Œçš„äºº
                  initialHands: prev.initialHands
                },
                lastPlayerIndex,
                lastPlayer,
                context: 'playerPlay - äººç±»ç©å®¶å‡ºå®Œç‰Œååªå‰©ä¸€ä¸ªç©å®¶'
              });
              
              return {
                ...prev,
                ...gameEndResult
              };
            } catch (error) {
              console.error('[playerPlay] handleGameEnd å¤±è´¥:', error);
              return prev;
            }
          }
          
          // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†
          const gameFinished = checkGameFinished(prev, newPlayers, newFinishOrder);
          if (gameFinished) {
            return gameFinished;
          }
          
          // è¿˜æ²¡å…¨éƒ¨å‡ºå®Œï¼Œæ‰¾åˆ°ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶
          // é‡è¦ï¼šä½¿ç”¨findNextActivePlayerç¡®ä¿è·³è¿‡å·²å‡ºå®Œç‰Œçš„ç©å®¶
          const nextPlayerIndex = findNextActivePlayer(currentState.currentPlayerIndex, newPlayers, prev.playerCount);
          
          // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å‰©ä½™ç©å®¶éƒ½è¦ä¸èµ·æœ€åä¸€æ‰‹ç‰Œ
          // å¦‚æœéƒ½è¦ä¸èµ·ï¼Œåˆ™æ¥é£ï¼ˆæ¸…ç©ºlastPlayï¼Œè®©ä¸‹å®¶è‡ªç”±å‡ºç‰Œï¼‰
          // å¦‚æœæœ‰äººèƒ½æ‰“è¿‡ï¼Œåˆ™ä¸æ¸…ç©ºlastPlayï¼Œè®©èƒ½æ‰“è¿‡çš„ç©å®¶ç»§ç»­
          let shouldTakeover = true; // é»˜è®¤æ¥é£
          for (let i = 0; i < newPlayers.length; i++) {
            if (i !== currentState.currentPlayerIndex && newPlayers[i].hand.length > 0) {
              // æ£€æŸ¥è¿™ä¸ªç©å®¶æ˜¯å¦èƒ½æ‰“è¿‡æœ€åä¸€æ‰‹ç‰Œ
              if (hasPlayableCards(newPlayers[i].hand, play)) {
                shouldTakeover = false; // æœ‰äººèƒ½æ‰“è¿‡ï¼Œä¸éœ€è¦æ¥é£
                break;
              }
            }
          }
          
          // æ ¹æ®æ˜¯å¦æ¥é£å†³å®šæ¸¸æˆçŠ¶æ€
          // æ³¨æ„ï¼šåˆ†æ•°å·²ç»åœ¨å‰é¢ï¼ˆ593è¡Œï¼‰åŠ ç»™ç©å®¶äº†ï¼Œæ‰€ä»¥è¿™é‡ŒroundScoreåº”è¯¥é‡ç½®ä¸º0
          // æ£€æŸ¥ nextPlayerIndex æ˜¯å¦ä¸º null
          if (nextPlayerIndex === null) {
            const allFinished = newPlayers.every(p => p.hand.length === 0);
            if (allFinished) {
              const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, newFinishOrder);
              const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
              
              return {
                ...prev,
                status: GameStatus.FINISHED,
                players: finalPlayers,
                winner: winner.player.id,
                finishOrder: newFinishOrder,
                finalRankings
              };
            }
            return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
          }
          
          // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
          const currentPlayerVoice = newPlayers[currentState.currentPlayerIndex]?.voiceConfig;
          announcePlay(play, currentPlayerVoice).catch(console.error);
          
          const newState = {
            ...prev,
            players: newPlayers,
            currentPlayerIndex: nextPlayerIndex,
            lastPlay: shouldTakeover ? null : play, // å¦‚æœæ¥é£ï¼Œæ¸…ç©ºlastPlayï¼›å¦åˆ™ä¿æŒlastPlay
            lastPlayPlayerIndex: shouldTakeover ? null : currentState.currentPlayerIndex, // å¦‚æœæ¥é£ï¼Œæ¸…ç©ºlastPlayPlayerIndexï¼›å¦åˆ™ä¿æŒä¸ºå½“å‰ç©å®¶
            roundScore: 0, // åˆ†æ•°å·²ç»ç»™ç©å®¶äº†ï¼Œé‡ç½®è½®æ¬¡åˆ†æ•°
            currentRoundPlays: shouldTakeover ? [] : [...prev.currentRoundPlays, playRecord], // å¦‚æœæ¥é£ï¼Œæ¸…ç©ºè®°å½•ï¼›å¦åˆ™æ·»åŠ è®°å½•
            finishOrder: newFinishOrder
          };
          
          // æ’­æŠ¥åç­‰å¾…ï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
          if (newPlayers[nextPlayerIndex].type === PlayerType.AI) {
              setTimeout(() => {
                if (schedulerRef.current) {
                  schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
                }
            }, announcementDelay);
          }
          
          return newState;
        }

        // è®¡ç®—ä¸‹ä¸€ä¸ªç©å®¶ï¼Œè·³è¿‡å·²å‡ºå®Œçš„ç©å®¶
        const nextPlayerIndex = findNextActivePlayer(currentState.currentPlayerIndex, newPlayers, prev.playerCount);
        
        // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
        if (nextPlayerIndex === null) {
          const allFinished = newPlayers.every(p => p.hand.length === 0);
          if (allFinished) {
            const finishOrder = prev.finishOrder || [];
            const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, finishOrder);
            const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
            
            return {
              ...prev,
              status: GameStatus.FINISHED,
              players: finalPlayers,
              winner: winner.player.id,
              finishOrder: finishOrder,
              finalRankings
            };
          }
          return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
        }
        
        const newState = {
          ...prev,
          players: newPlayers,
          currentPlayerIndex: nextPlayerIndex,
          lastPlay: play,
          lastPlayPlayerIndex: currentState.currentPlayerIndex,
          roundScore: prev.roundScore + playScore, // ç´¯åŠ è½®æ¬¡åˆ†æ•°
          currentRoundPlays: [...prev.currentRoundPlays, playRecord] // è®°å½•è¿™ä¸€æ‰‹å‡ºç‰Œ
        };

        // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
        const currentPlayerVoice = newPlayers[currentState.currentPlayerIndex]?.voiceConfig;
        announcePlay(play, currentPlayerVoice).catch(console.error);
        
        // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
        if (newPlayers[nextPlayerIndex].type === PlayerType.AI) {
            setTimeout(() => {
              if (schedulerRef.current) {
                schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
              }
          }, 1500);
        }

        return newState;
      });
    } catch (error) {
      console.error('[playNextTurnInternal] AIå‡ºç‰Œå¤±è´¥:', error);
      setGameState(prev => {
        if (prev.status !== GameStatus.PLAYING) return prev;
        const nextPlayerIndex = (prev.currentPlayerIndex + 1) % prev.playerCount;
        let newLastPlay: Play | null = prev.lastPlay;
        let newLastPlayPlayerIndex: number | null = prev.lastPlayPlayerIndex;
        let newRoundScore = prev.roundScore;
        const newPlayers = [...prev.players];
        
        // åªè¦æœ‰äºº"è¦ä¸èµ·"ï¼Œä¸”æœ¬è½®æœ‰å‡ºç‰Œè®°å½•ï¼ˆlastPlayPlayerIndexä¸ä¸ºnullï¼‰ï¼Œåˆ™å¼ºåˆ¶ç»“æŸæœ¬è½®
        if (prev.lastPlayPlayerIndex !== null) {
          // å¼ºåˆ¶ç»“æŸæœ¬è½®ï¼ŒæŠŠåˆ†æ•°ç»™æœ€åå‡ºç‰Œçš„äºº
          const lastPlayer = newPlayers[prev.lastPlayPlayerIndex];
          if (lastPlayer) {
            // åˆ›å»ºè½®æ¬¡è®°å½•
            const roundRecord: RoundRecord = {
              roundNumber: prev.roundNumber,
              plays: [...prev.currentRoundPlays],
              totalScore: prev.roundScore,
              winnerId: prev.lastPlayPlayerIndex,
              winnerName: lastPlayer.name
            };
            
            // å¦‚æœæœ‰åˆ†æ•°ï¼Œç»™æœ€åå‡ºç‰Œçš„äºº
            if (prev.roundScore > 0) {
              newPlayers[prev.lastPlayPlayerIndex] = {
                ...lastPlayer,
                score: (lastPlayer.score || 0) + prev.roundScore,
                wonRounds: [...(lastPlayer.wonRounds || []), roundRecord]
              };
            }
            
            // ä¿å­˜è½®æ¬¡è®°å½•åˆ°allRounds
            const updatedAllRounds = [...(prev.allRounds || []), roundRecord];
            
            // ä¸€è½®ç»“æŸï¼Œç”±èµ¢å®¶å¼€å§‹ä¸‹ä¸€è½®ï¼ˆå¦‚æœèµ¢å®¶å·²å‡ºå®Œï¼Œæ‰¾ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰
            const winnerIndex = prev.lastPlayPlayerIndex;
            let nextActivePlayerIndex: number | null;
            if (newPlayers[winnerIndex]?.hand.length > 0) {
              nextActivePlayerIndex = winnerIndex;
            } else {
              nextActivePlayerIndex = findNextActivePlayer(winnerIndex, newPlayers, prev.playerCount);
            }
            
            // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
            if (nextActivePlayerIndex === null) {
              const allFinished = newPlayers.every(p => p.hand.length === 0);
              if (allFinished) {
                const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, prev.finishOrder || []);
                const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
                
                return {
                  ...prev,
                  status: GameStatus.FINISHED,
                  players: finalPlayers,
                  winner: winner.player.id,
                  finalRankings
                };
              }
              return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
            }
            
            const newState = {
              ...prev,
              players: newPlayers,
              currentPlayerIndex: nextActivePlayerIndex, // ç”±èµ¢å®¶ï¼ˆæˆ–ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰å¼€å§‹ä¸‹ä¸€è½®
              lastPlay: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlay
              lastPlayPlayerIndex: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlayPlayerIndex
              roundScore: 0, // æ–°è½®æ¬¡ï¼Œé‡ç½®åˆ†æ•°
              currentRoundPlays: [], // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºå½“å‰è½®æ¬¡å‡ºç‰Œè®°å½•
              roundNumber: prev.roundNumber + 1, // æ–°è½®æ¬¡
              allRounds: updatedAllRounds,
              gameRecord: prev.gameRecord ? {
                ...prev.gameRecord,
                allRounds: updatedAllRounds
              } : prev.gameRecord
            };
            
            // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
            const currentPlayerVoice = prev.players[prev.currentPlayerIndex]?.voiceConfig;
            // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
            announcePass(currentPlayerVoice).catch(console.error);
            
            // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
            if (newPlayers[nextActivePlayerIndex].type === PlayerType.AI) {
                setTimeout(() => {
                  if (schedulerRef.current) {
                    schedulerRef.current.scheduleNextTurn(nextActivePlayerIndex, 0);
                  }
              }, 1500);
            }
            
            return newState;
          }
        }
        
        // å¦‚æœæ²¡æœ‰lastPlayPlayerIndexï¼ˆæ¥é£çŠ¶æ€ï¼‰ï¼Œç»§ç»­æ¸¸æˆ
        newLastPlay = prev.lastPlay;
        newLastPlayPlayerIndex = prev.lastPlayPlayerIndex;
        newRoundScore = prev.roundScore;
        
        return {
          ...prev,
          players: newPlayers,
          currentPlayerIndex: nextPlayerIndex,
          lastPlay: newLastPlay,
          lastPlayPlayerIndex: newLastPlayPlayerIndex,
          roundScore: newRoundScore
        };
      });
    }
  }, []);

  // æ–°çš„ playNextTurn å‡½æ•° - é€šè¿‡è°ƒåº¦å™¨ç»Ÿä¸€ç®¡ç†
  const playNextTurn = useCallback(() => {
    if (schedulerRef.current) {
      schedulerRef.current.scheduleNextTurn(undefined, 0);
    } else {
      console.warn('[playNextTurn] è°ƒåº¦å™¨æœªåˆå§‹åŒ–ï¼Œç›´æ¥è°ƒç”¨å†…éƒ¨å‡½æ•°', {
        timestamp: Date.now()
      });
      // å¦‚æœè°ƒåº¦å™¨æœªåˆå§‹åŒ–ï¼Œç›´æ¥è°ƒç”¨å†…éƒ¨å‡½æ•°ï¼ˆå‘åå…¼å®¹ï¼‰
      playNextTurnInternal();
    }
  }, [playNextTurnInternal]);

  // è®¾ç½®è°ƒåº¦å™¨å›è°ƒï¼ˆåœ¨ playNextTurnInternal å®šä¹‰åï¼‰
  useEffect(() => {
    if (schedulerRef.current && !schedulerRef.current.onNextTurnCallback) {
      schedulerRef.current.onNextTurnCallback = async (playerIndex: number) => {
        // è°ƒç”¨å®é™…çš„ playNextTurn é€»è¾‘
        await playNextTurnInternal(playerIndex);
      };
    }
  }, [playNextTurnInternal]);

  // ç›‘å¬currentPlayerIndexå˜åŒ–ï¼Œé€šè¿‡è°ƒåº¦å™¨è‡ªåŠ¨è§¦å‘AIç©å®¶å‡ºç‰Œ
  useEffect(() => {
    if (gameState.status !== GameStatus.PLAYING) return;
    if (!gameState.players?.length) return;

    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (!currentPlayer || currentPlayer.type !== PlayerType.AI || currentPlayer.hand.length === 0) {
      return;
    }

    // å»¶è¿Ÿä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿çŠ¶æ€å®Œå…¨æ›´æ–°
      const timer = setTimeout(() => {
        const latestState = gameStateRef.current;
        if (latestState.status === GameStatus.PLAYING && 
            latestState.currentPlayerIndex === gameState.currentPlayerIndex &&
          latestState.players[latestState.currentPlayerIndex]?.type === PlayerType.AI &&
          schedulerRef.current) {
        schedulerRef.current.scheduleNextTurn(gameState.currentPlayerIndex, 0);
      }
    }, 100);

    return () => clearTimeout(timer);
  }, [gameState.currentPlayerIndex, gameState.status]);

  // å¼€å§‹æ–°æ¸¸æˆï¼ˆå†…éƒ¨å‡½æ•°ï¼Œå¤„ç†å‘ç‰Œï¼‰
  const startGameInternal = useCallback((config: GameConfig, hands: Card[][]) => {
    // æ¸…ç©ºèŠå¤©è®°å½•
    clearChatMessages();

    const players: Player[] = hands.map((hand, index) => ({
      id: index,
      name: index === config.humanPlayerIndex ? 'ä½ ' : `ç©å®¶${index + 1}`,
      type: index === config.humanPlayerIndex ? PlayerType.HUMAN : PlayerType.AI,
      hand: hand,
      score: -100, // åˆå§‹åˆ†æ•°ä¸º-100ï¼ˆæ¯ä¸ªäººåŸºæœ¬åˆ†100ï¼Œæ‰€ä»¥åˆå§‹æ‰£é™¤100ï¼‰
      isHuman: index === config.humanPlayerIndex,
      aiConfig: index === config.humanPlayerIndex ? undefined : {
        apiKey: '', // ä¸éœ€è¦API Keyï¼ˆOpenAIå·²ç¦ç”¨ï¼‰
        strategy: config.aiConfigs[index]?.strategy || 'balanced',
        algorithm: config.aiConfigs[index]?.algorithm || 'mcts', // é»˜è®¤ä½¿ç”¨MCTS
        mctsIterations: config.aiConfigs[index]?.mctsIterations || 100 // å¤§å¹…é™ä½é»˜è®¤å€¼ä»¥æé«˜é€Ÿåº¦ï¼ˆå¿«é€Ÿæ¨¡å¼ï¼‰
      },
      voiceConfig: generateRandomVoiceConfig(index) // ä¸ºæ¯ä¸ªç©å®¶åˆ†é…ç‹¬ç‰¹çš„è¯­éŸ³é…ç½®ï¼ˆä½¿ç”¨indexç¡®ä¿æ¯ä¸ªç©å®¶ä¸åŒï¼‰
    }));

    // æ³¨æ„ï¼šä¸å†è®¡ç®— totalScoreï¼Œå› ä¸ºæœªä½¿ç”¨

    // éšæœºå†³å®šè°å…ˆå‡ºç‰Œ
    const firstPlayer = Math.floor(Math.random() * config.playerCount);

    // åˆå§‹åŒ–è®°ç‰Œå™¨å¹¶åˆ›å»ºç¬¬1è½®ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (cardTrackerEnabled) {
      const stackTrace = new Error().stack?.split('\n').slice(2, 8).join('\n') || 'unknown';
      console.warn(`[startGameInternal] â†’ å‡†å¤‡åˆå§‹åŒ–è®°ç‰Œå™¨`, {
        roundNumber: 1,
        playersCount: players.length,
        players: players.map(p => ({ id: p.id, name: p.name, handCount: p.hand.length })),
        existingRounds: cardTracker.getAllRounds().map(r => r.roundNumber).sort((a, b) => a - b),
        stackTrace: stackTrace.substring(0, 300),
        timestamp: Date.now()
      });
      
      try {
        cardTracker.initialize(hands, Date.now());
        console.warn(`[startGameInternal] âœ“ è®°ç‰Œå™¨å·²åˆå§‹åŒ–`, {
          totalRounds: cardTracker.getAllRounds().length,
          timestamp: Date.now()
        });
        
        cardTracker.startRound(1, players);
        console.warn(`[startGameInternal] âœ“ ç¬¬1è½®å·²åˆ›å»º`, {
          totalRounds: cardTracker.getAllRounds().length,
          round1Exists: !!cardTracker.getRound(1),
          timestamp: Date.now()
        });
      } catch (error) {
        console.error(`[startGameInternal] âœ— è®°ç‰Œå™¨åˆå§‹åŒ–å¤±è´¥`, {
          error: error instanceof Error ? error.message : String(error),
          stackTrace: stackTrace.substring(0, 200),
          timestamp: Date.now()
        });
      }
    } else {
      console.log(`[startGameInternal] è®¡åˆ†å™¨å·²ç¦ç”¨ï¼Œè·³è¿‡åˆå§‹åŒ–`);
    }

    // åˆ›å»ºç¬¬ä¸€è½®
    const firstRound = Round.createNew(1, Date.now(), gameConfig.timingConfig);
    
    setGameState({
      status: GameStatus.PLAYING,
      players,
      currentPlayerIndex: firstPlayer,
      winner: null,
      playerCount: config.playerCount,
      finishOrder: [],
      initialHands: hands.map(hand => [...hand]), // ä¿å­˜åˆå§‹æ‰‹ç‰Œ
      rounds: [firstRound], // åˆå§‹åŒ–è½®æ¬¡æ•°ç»„ï¼ŒåŒ…å«ç¬¬ä¸€è½®
      currentRoundIndex: 0, // ç¬¬ä¸€è½®åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•æ˜¯ 0
      gameRecord: {
        gameId: `game-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        startTime: Date.now(),
        playerCount: config.playerCount,
        initialHands: hands.map(hand => [...hand]),
        allRounds: [],
        finishOrder: [],
        finalRankings: [],
        winner: -1
      }
    });

    // å¦‚æœç¬¬ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œï¼ˆé€šè¿‡è°ƒåº¦å™¨ï¼‰
    if (firstPlayer !== config.humanPlayerIndex) {
      setTimeout(() => {
        if (schedulerRef.current) {
          schedulerRef.current.scheduleNextTurn(firstPlayer, 0);
        }
      }, 1000);
    }
  }, [playNextTurn]);

  // å¼€å§‹æ–°æ¸¸æˆï¼ˆå…¬å¼€æ¥å£ï¼Œæ¥æ”¶GameConfigï¼‰
  const startGame = useCallback((startConfig: GameConfig) => {
    // è½¬æ¢ä¸ºGameConfig
    const config: GameConfig = {
      playerCount: startConfig.playerCount,
      humanPlayerIndex: startConfig.humanPlayerIndex,
      aiConfigs: startConfig.aiConfigs,
      dealingAlgorithm: startConfig.dealingAlgorithm,
      skipDealingAnimation: startConfig.skipDealingAnimation
    };

    // å¦‚æœè·³è¿‡å‘ç‰ŒåŠ¨ç”»ï¼Œç›´æ¥ä½¿ç”¨æ—§é€»è¾‘
    if (config.skipDealingAnimation) {
      const hands = dealCards(config.playerCount);
      startGameInternal(config, hands);
      return;
    }

    // å¦åˆ™ï¼Œæ˜¾ç¤ºå‘ç‰ŒåŠ¨ç”»
    setIsDealing(true);
    setPendingGameConfig(config);
  }, [startGameInternal]);

  // å‘ç‰Œå®Œæˆå›è°ƒ
  const handleDealingComplete = useCallback((hands: Card[][]) => {
    if (pendingGameConfig) {
      setIsDealing(false);
      startGameInternal(pendingGameConfig, hands);
      setPendingGameConfig(null);
    }
  }, [pendingGameConfig, startGameInternal]);

  // å–æ¶ˆå‘ç‰ŒåŠ¨ç”»
  const handleDealingCancel = useCallback(() => {
    if (pendingGameConfig) {
      // å¿«é€Ÿå‘ç‰Œï¼ˆä¸ä½¿ç”¨åŠ¨ç”»ï¼‰
      const hands = dealCards(pendingGameConfig.playerCount);
      setIsDealing(false);
      startGameInternal(pendingGameConfig, hands);
      setPendingGameConfig(null);
    }
  }, [pendingGameConfig, startGameInternal]);

  // ç©å®¶å‡ºç‰Œ
  // æ—§çš„åŒæ­¥ playerPlay å‡½æ•° - ç°åœ¨æ”¹ä¸ºè°ƒç”¨å¼‚æ­¥ç‰ˆæœ¬
  const playerPlay = useCallback((playerIndex: number, selectedCards: Card[]): boolean => {
    // ç›´æ¥è°ƒç”¨å¼‚æ­¥ç‰ˆæœ¬ï¼Œä½†ä¸ç­‰å¾…å®Œæˆï¼ˆä¿æŒåŒæ­¥æ¥å£ï¼‰
    playerPlayAsync(playerIndex, selectedCards).catch(console.error);
    return true; // å‡è®¾æˆåŠŸï¼Œå®é™…ç»“æœç”±å¼‚æ­¥å¤„ç†
  }, [playerPlayAsync]);

  // playerPlaySync å·²åˆ é™¤ - ä¸å†éœ€è¦ï¼Œå› ä¸º playerPlay ç°åœ¨ç›´æ¥è°ƒç”¨ playerPlayAsync

  // å¼‚æ­¥å‡ºç‰Œå¤„ç†å‡½æ•°ï¼ˆä½¿ç”¨ Round ç±»ï¼‰
      if (!player) return prev;
      
      // å¦‚æœç©å®¶å·²ç»å‡ºå®Œç‰Œäº†ï¼Œä¸åº”è¯¥å†å‡ºç‰Œ
      if (player.hand.length === 0) return prev;

      const play = canPlayCards(selectedCards);
      if (!play) return prev;

      // è·å–å½“å‰è½®æ¬¡æ•°æ®
      const currentRound = getCurrentRound(prev);
      const lastPlay = getLastPlay(prev);
      const lastPlayPlayerIndex = getLastPlayPlayerIndex(prev);
      
      // å¦‚æœå½“å‰ç©å®¶æ˜¯æœ€åå‡ºç‰Œçš„äººï¼ˆæ¥é£ï¼‰ï¼Œå¯ä»¥è‡ªç”±å‡ºç‰Œï¼Œä¸éœ€è¦æ£€æŸ¥canBeat
      const isTakingOver = prev.currentPlayerIndex === lastPlayPlayerIndex;
      
      // å¦‚æœä¸èƒ½å‹è¿‡ä¸Šå®¶çš„ç‰Œï¼Œç«‹å³è¦ä¸èµ·ï¼ˆä¸ç®¡æ‰‹ä¸­æœ‰æ²¡æœ‰å…¶ä»–èƒ½æ‰“è¿‡çš„ç‰Œï¼‰
      // ä½†æ˜¯ï¼Œå¦‚æœæ˜¯æ¥é£ï¼ˆå½“å‰ç©å®¶æ˜¯æœ€åå‡ºç‰Œçš„äººï¼‰ï¼Œå¯ä»¥è‡ªç”±å‡ºç‰Œ
      if (!isTakingOver && lastPlay && !canBeat(play, lastPlay)) {
        // æ‰§è¡Œè¦ä¸èµ·é€»è¾‘
        const nextPlayerIndex = findNextActivePlayer(playerIndex, prev.players, prev.playerCount);

        let newLastPlay: Play | null = prev.lastPlay;
        let newLastPlayPlayerIndex: number | null = prev.lastPlayPlayerIndex;
        let newRoundScore = prev.roundScore;
        const newPlayers = [...prev.players];
        
        // åªè¦æœ‰äºº"è¦ä¸èµ·"ï¼Œä¸”æœ¬è½®æœ‰å‡ºç‰Œè®°å½•ï¼ˆlastPlayPlayerIndexä¸ä¸ºnullï¼‰ï¼Œåˆ™å¼ºåˆ¶ç»“æŸæœ¬è½®
        if (prev.lastPlayPlayerIndex !== null) {
          // å¼ºåˆ¶ç»“æŸæœ¬è½®ï¼ŒæŠŠåˆ†æ•°ç»™æœ€åå‡ºç‰Œçš„äºº
          const lastPlayer = newPlayers[prev.lastPlayPlayerIndex];
          if (lastPlayer) {
            // åˆ›å»ºè½®æ¬¡è®°å½•
            const roundRecord: RoundRecord = {
              roundNumber: prev.roundNumber,
              plays: [...prev.currentRoundPlays],
              totalScore: prev.roundScore,
              winnerId: prev.lastPlayPlayerIndex,
              winnerName: lastPlayer.name
            };
            
            // å¦‚æœæœ‰åˆ†æ•°ï¼Œç»™æœ€åå‡ºç‰Œçš„äºº
            if (prev.roundScore > 0) {
              newPlayers[prev.lastPlayPlayerIndex] = {
                ...lastPlayer,
                score: (lastPlayer.score || 0) + prev.roundScore,
                wonRounds: [...(lastPlayer.wonRounds || []), roundRecord]
              };
            }
            
            // ä¿å­˜è½®æ¬¡è®°å½•åˆ°allRounds
            const updatedAllRounds = [...(prev.allRounds || []), roundRecord];
            
            // ä¸€è½®ç»“æŸï¼Œç”±èµ¢å®¶å¼€å§‹ä¸‹ä¸€è½®ï¼ˆå¦‚æœèµ¢å®¶å·²å‡ºå®Œï¼Œæ‰¾ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰
            const winnerIndex = prev.lastPlayPlayerIndex;
            let nextActivePlayerIndex: number | null;
            if (newPlayers[winnerIndex]?.hand.length > 0) {
              nextActivePlayerIndex = winnerIndex;
            } else {
              nextActivePlayerIndex = findNextActivePlayer(winnerIndex, newPlayers, prev.playerCount);
            }
            
            // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
            if (nextActivePlayerIndex === null) {
              const allFinished = newPlayers.every(p => p.hand.length === 0);
              if (allFinished) {
                const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, prev.finishOrder || []);
                const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
                
                return {
                  ...prev,
                  status: GameStatus.FINISHED,
                  players: finalPlayers,
                  winner: winner.player.id,
                  finalRankings
                };
              }
              return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
            }
            
            const newState = {
              ...prev,
              players: newPlayers,
              currentPlayerIndex: nextActivePlayerIndex, // ç”±èµ¢å®¶ï¼ˆæˆ–ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰å¼€å§‹ä¸‹ä¸€è½®
              lastPlay: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlay
              lastPlayPlayerIndex: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlayPlayerIndex
              roundScore: 0, // æ–°è½®æ¬¡ï¼Œé‡ç½®åˆ†æ•°
              currentRoundPlays: [], // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºå½“å‰è½®æ¬¡å‡ºç‰Œè®°å½•
              roundNumber: prev.roundNumber + 1, // æ–°è½®æ¬¡
              allRounds: updatedAllRounds,
              gameRecord: prev.gameRecord ? {
                ...prev.gameRecord,
                allRounds: updatedAllRounds
              } : prev.gameRecord
            };
            
            // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
            const currentPlayerVoice = prev.players[playerIndex]?.voiceConfig;
            // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
            announcePass(currentPlayerVoice).catch(console.error);
            
            // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
            if (newPlayers[nextActivePlayerIndex].type === PlayerType.AI) {
                setTimeout(() => {
                  if (schedulerRef.current) {
                    schedulerRef.current.scheduleNextTurn(nextActivePlayerIndex, 0);
                  }
              }, 1500);
            }
            
            return newState;
          }
        }
        
        // å¦‚æœæ²¡æœ‰lastPlayPlayerIndexï¼ˆæ¥é£çŠ¶æ€ï¼‰ï¼Œç»§ç»­æ¸¸æˆ
        // æ£€æŸ¥ nextPlayerIndex æ˜¯å¦ä¸º null
        if (nextPlayerIndex === null) {
          const allFinished = newPlayers.every(p => p.hand.length === 0);
          if (allFinished) {
            const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, prev.finishOrder || []);
            const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
            
            return {
              ...prev,
              status: GameStatus.FINISHED,
              players: finalPlayers,
              winner: winner.player.id,
              finalRankings
            };
          }
          return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
        }
        
        newLastPlay = prev.lastPlay;
        newLastPlayPlayerIndex = prev.lastPlayPlayerIndex;
        newRoundScore = prev.roundScore;

        const newState = {
          ...prev,
          players: newPlayers,
          currentPlayerIndex: nextPlayerIndex,
          lastPlay: newLastPlay,
          lastPlayPlayerIndex: newLastPlayPlayerIndex,
          roundScore: newRoundScore,
          currentRoundPlays: newLastPlay === null ? [] : prev.currentRoundPlays
        };

        // ç­‰å¾…"è¦ä¸èµ·"è¯­éŸ³æ’­æ”¾å®Œæˆåå†ç»§ç»­
        // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
        const currentPlayerVoice = newPlayers[prev.currentPlayerIndex]?.voiceConfig;
        // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
        announcePass(currentPlayerVoice).catch(console.error);
        
        // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
        if (newPlayers[nextPlayerIndex].type === PlayerType.AI) {
            setTimeout(() => {
              if (schedulerRef.current) {
                schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
              }
          }, 1500);
        }

        return newState;
      }

      // è®¡ç®—è¿™æ‰‹ç‰Œçš„åˆ†å€¼ï¼ˆç´¯åŠ åˆ°è½®æ¬¡åˆ†æ•°ï¼Œä¸ç›´æ¥ç»™ç©å®¶ï¼‰
      const playScore = calculateCardsScore(selectedCards);
      const scoreCards = selectedCards.filter(card => isScoreCard(card));

      // è®¡ç®—åŠ¨ç”»ä½ç½®
      const animationPosition = calculatePlayAnimationPosition(
        playerIndex,
        prev.players,
        prev.players.findIndex(p => p.isHuman),
        prev.playerCount
      );

      // å¤„ç†å¢©çš„è®¡åˆ†
      const { updatedPlayers: playersAfterDun, dunScore } = handleDunScoring(
        prev.players,
        playerIndex,
        selectedCards,
        prev.playerCount,
        play,
        animationPosition
      );
      
      // æ›´æ–°ç©å®¶æ‰‹ç‰Œå’Œåˆ†æ•°
      const updatedPlayer = updatePlayerAfterPlay(player, selectedCards, dunScore);
      const newPlayers = [...playersAfterDun];
      newPlayers[playerIndex] = updatedPlayer;
      
      // è§¦å‘å¥½ç‰Œååº”ï¼ˆä¼ é€’å®Œæ•´æ¸¸æˆçŠ¶æ€ï¼‰
      const currentGameState: MultiPlayerGameState = {
        ...prev,
        players: newPlayers
      };
      triggerGoodPlayReactions(player, play, scoreCards, currentGameState);
      
      // å¦‚æœå‡ºçš„æ˜¯å¥½ç‰Œï¼ˆç‚¸å¼¹ã€å¢©ã€æœ‰åˆ†ç‰Œï¼‰ï¼Œå…¶ä»–ç©å®¶å¯èƒ½å¯¹éª‚
      // æµ‹è¯•æ¨¡å¼ï¼šæé«˜è§¦å‘æ¦‚ç‡ï¼Œç¡®ä¿èƒ½çœ‹åˆ°å¤§é‡å¯¹éª‚
      if (play.type === 'bomb' || play.type === 'dun' || scoreCards.length > 0) {
        newPlayers.forEach((p, idx) => {
          if (idx !== playerIndex && p.hand.length > 0) {
            // æµ‹è¯•æ¨¡å¼ï¼š100%æ¦‚ç‡å¯¹éª‚ï¼ˆç¡®ä¿èƒ½çœ‹åˆ°ï¼‰
            // ç‚¸å¼¹ï¼š100%æ¦‚ç‡å¯¹éª‚
            // å¢©ï¼š100%æ¦‚ç‡å¯¹éª‚ï¼ˆæ›´æ¿€çƒˆï¼‰
            // æœ‰åˆ†ç‰Œï¼š100%æ¦‚ç‡å¯¹éª‚
            const tauntProbability = 1.0; // 100%è§¦å‘ï¼Œç”¨äºæµ‹è¯•
            if (Math.random() < tauntProbability) {
              triggerTaunt(p, player, currentGameState).catch(console.error);
            }
          }
        });
      }
      
      // æµ‹è¯•æ¨¡å¼ï¼šæ¯æ¬¡å‡ºç‰Œéƒ½æœ‰ä¸€å®šæ¦‚ç‡è§¦å‘å¯¹éª‚ï¼ˆå¢åŠ è§¦å‘é¢‘ç‡ï¼‰
      // å³ä½¿ä¸æ˜¯å¥½ç‰Œï¼Œä¹Ÿæœ‰30%æ¦‚ç‡è§¦å‘å¯¹éª‚
      if (play.type !== 'bomb' && play.type !== 'dun' && scoreCards.length === 0) {
        newPlayers.forEach((p, idx) => {
          if (idx !== playerIndex && p.hand.length > 0) {
            if (Math.random() < 0.3) { // 30%æ¦‚ç‡
              triggerTaunt(p, player, currentGameState).catch(console.error);
            }
          }
        });
      }
      
      // å¦‚æœæ¡åˆ°äº†åˆ†ï¼Œå¯èƒ½è§¦å‘å…¶ä»–ç©å®¶çš„ååº”
      if (playScore > 0) {
        // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–ç©å®¶å¤±å»äº†åˆ†
        const lostScore = playScore;
        // è®¡ç®—æ€»è½®æ¬¡åˆ†æ•°ï¼ˆåŒ…æ‹¬å½“å‰è¿™ä¸€æ‰‹ï¼‰
        const totalRoundScore = prev.roundScore + playScore;
        
        newPlayers.forEach((p, idx) => {
          if (idx !== playerIndex && p.hand.length > 0) {
            // æ ¹æ®åˆ†æ•°å¤§å°å†³å®šååº”å¼ºåº¦
            // å¦‚æœåˆ†æ•°è¾ƒå¤§ï¼ˆ>=5åˆ†ï¼‰æˆ–æ€»è½®æ¬¡åˆ†æ•°è¾ƒå¤§ï¼ˆ>=10åˆ†ï¼‰ï¼Œä¼˜å…ˆè§¦å‘è„è¯ååº”
            const shouldCurse = lostScore >= 5 || totalRoundScore >= 10;
            
            if (shouldCurse) {
              // å¤§åˆ†è¢«åƒï¼Œè§¦å‘è„è¯ï¼ˆæ›´æ¿€çƒˆï¼‰- 80%æ¦‚ç‡
              if (Math.random() < 0.8) {
                triggerScoreEatenCurseReaction(p, lostScore, currentGameState).catch(console.error);
              } else if (Math.random() < 0.3) {
                // 20%æ¦‚ç‡æ™®é€šæŠ±æ€¨
                triggerScoreStolenReaction(p, lostScore, currentGameState).catch(console.error);
              }
            } else {
              // å°åˆ†è¢«åƒï¼Œä¹Ÿæœ‰ä¸€å®šæ¦‚ç‡è§¦å‘è„è¯ï¼ˆ30%ï¼‰ï¼Œæˆ–è€…æ™®é€šæŠ±æ€¨ï¼ˆ40%ï¼‰
              if (Math.random() < 0.3) {
                triggerScoreEatenCurseReaction(p, lostScore, currentGameState).catch(console.error);
              } else if (Math.random() < 0.4) {
                triggerScoreStolenReaction(p, lostScore, currentGameState).catch(console.error);
              }
            }
          }
        });
      }

      // è®°å½•è¿™ä¸€æ‰‹å‡ºç‰Œ
      const playRecord: RoundPlayRecord = {
        playerId: playerIndex,
        playerName: player.name,
        cards: selectedCards,
        scoreCards: scoreCards,
        score: playScore
      };

      // updatedPlayerå·²ç»åœ¨ç¬¬937è¡Œè®¾ç½®åˆ°newPlayers[playerIndex]äº†
      // è¿™é‡Œä¸éœ€è¦é‡å¤è®¾ç½®

      // è¯­éŸ³ä¼šåœ¨çŠ¶æ€æ›´æ–°åç»Ÿä¸€å¤„ç†

      // æ£€æŸ¥æ˜¯å¦è·èƒœ
      if (updatedPlayer.hand.length === 0) {
        // ç©å®¶å‡ºå®Œç‰Œï¼Œè®°å½•åˆ°å®Œæˆé¡ºåº
        const newFinishOrder = [...(prev.finishOrder || []), playerIndex];
        
        // è®¡ç®—å½“å‰ç©å®¶çš„åæ¬¡ï¼ˆæ ¹æ®å‡ºå®Œç‰Œçš„é¡ºåºï¼Œç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰
        const currentRank = newFinishOrder.length;
        
        // è§¦å‘å‡ºå®Œç‰Œæ—¶çš„èŠå¤©ååº”ï¼ˆä¼ é€’å®Œæ•´æ¸¸æˆçŠ¶æ€ï¼‰
        const finishPosition = newFinishOrder.length;
        const currentGameState: MultiPlayerGameState = {
          ...prev,
          players: newPlayers,
          finishOrder: newFinishOrder
        };
        if (finishPosition === 1) {
          // å¤´åå‡ºå®Œï¼Œå…´å¥‹
          triggerFinishFirstReaction(updatedPlayer, undefined, currentGameState).catch(console.error);
        } else {
          // ä¸­é—´åæ¬¡å‡ºå®Œï¼Œæ„Ÿæ…¨
          triggerFinishMiddleReaction(updatedPlayer, undefined, currentGameState).catch(console.error);
        }
        
        // å…ˆæŠŠè½®æ¬¡åˆ†æ•°åŠ ä¸Šï¼ˆåŒ…æ‹¬å½“å‰è¿™ä¸€æ‰‹çš„åˆ†ç‰Œï¼‰
        newPlayers[playerIndex] = {
          ...newPlayers[playerIndex],
          score: (newPlayers[playerIndex].score || 0) + prev.roundScore + playScore,
          finishedRank: currentRank // è®¾ç½®åæ¬¡ï¼ˆç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰
        };
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼ˆåŒ…æ‹¬å½“å‰ç©å®¶ï¼‰
        const remainingPlayers = newPlayers.filter(p => p.hand.length > 0);
        
        // å¦‚æœåªå‰©ä¸‹ä¸€ä¸ªç©å®¶è¿˜æ²¡å‡ºå®Œï¼Œä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†
        if (remainingPlayers.length === 1) {
          const lastPlayerIndex = remainingPlayers[0].id;
          const lastPlayer = newPlayers[lastPlayerIndex];
          
          // è§¦å‘æœ€åä¸€åè¾“äº†çš„èŠå¤©ååº”
          triggerFinishLastReaction(lastPlayer).catch(console.error);
          
          // ä½¿ç”¨ handleGameEnd ç»Ÿä¸€å¤„ç†æ¸¸æˆç»“æŸé€»è¾‘
          try {
            const gameEndResult = handleGameEnd({
              prevState: {
                status: prev.status,
                players: newPlayers,
                finishOrder: newFinishOrder,
                allRounds: prev.allRounds || [],
                currentRoundPlays: prev.currentRoundPlays || [],
                roundNumber: prev.roundNumber,
                roundScore: prev.roundScore || 0,
                lastPlayPlayerIndex: prev.lastPlayPlayerIndex,
                initialHands: prev.initialHands
              },
              lastPlayerIndex,
              lastPlayer,
              context: 'playerPass - è¦ä¸èµ·ååªå‰©ä¸€ä¸ªç©å®¶'
            });
            
            return {
              ...prev,
              ...gameEndResult
            };
          } catch (error) {
            console.error('[playerPass] handleGameEnd å¤±è´¥:', error);
            return prev;
          }
        }
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†
        const gameFinished = checkGameFinished(prev, newPlayers, newFinishOrder);
        if (gameFinished) {
          return gameFinished;
        }
        
        // è¿˜æ²¡å…¨éƒ¨å‡ºå®Œï¼Œæ‰¾åˆ°ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶
        // é‡è¦ï¼šä½¿ç”¨findNextActivePlayerç¡®ä¿è·³è¿‡å·²å‡ºå®Œç‰Œçš„ç©å®¶
        const nextPlayerIndex = findNextActivePlayer(playerIndex, newPlayers, prev.playerCount);
        
        // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
        if (nextPlayerIndex === null) {
          const allFinished = newPlayers.every(p => p.hand.length === 0);
          if (allFinished) {
            const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, newFinishOrder);
            const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
            
            return {
              ...prev,
              status: GameStatus.FINISHED,
              players: finalPlayers,
              winner: winner.player.id,
              finishOrder: newFinishOrder,
              finalRankings
            };
          }
          return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
        }
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å‰©ä½™ç©å®¶éƒ½è¦ä¸èµ·æœ€åä¸€æ‰‹ç‰Œ
        // å¦‚æœéƒ½è¦ä¸èµ·ï¼Œåˆ™æ¥é£ï¼ˆæ¸…ç©ºlastPlayï¼Œè®©ä¸‹å®¶è‡ªç”±å‡ºç‰Œï¼‰
        // å¦‚æœæœ‰äººèƒ½æ‰“è¿‡ï¼Œåˆ™ä¸æ¸…ç©ºlastPlayï¼Œè®©èƒ½æ‰“è¿‡çš„ç©å®¶ç»§ç»­
        let shouldTakeover = true; // é»˜è®¤æ¥é£
        for (let i = 0; i < newPlayers.length; i++) {
          if (i !== playerIndex && newPlayers[i].hand.length > 0) {
            // æ£€æŸ¥è¿™ä¸ªç©å®¶æ˜¯å¦èƒ½æ‰“è¿‡æœ€åä¸€æ‰‹ç‰Œ
            if (hasPlayableCards(newPlayers[i].hand, play)) {
              shouldTakeover = false; // æœ‰äººèƒ½æ‰“è¿‡ï¼Œä¸éœ€è¦æ¥é£
              break;
            }
          }
        }
        
        // æ ¹æ®æ˜¯å¦æ¥é£å†³å®šæ¸¸æˆçŠ¶æ€
        // æ³¨æ„ï¼šåˆ†æ•°å·²ç»åœ¨å‰é¢ï¼ˆ1039-1041è¡Œï¼‰åŠ ç»™ç©å®¶äº†ï¼Œæ‰€ä»¥è¿™é‡ŒroundScoreåº”è¯¥é‡ç½®ä¸º0
        const newState = {
          ...prev,
          players: newPlayers,
          currentPlayerIndex: nextPlayerIndex,
          lastPlay: shouldTakeover ? null : play, // å¦‚æœæ¥é£ï¼Œæ¸…ç©ºlastPlayï¼›å¦åˆ™ä¿æŒlastPlay
          lastPlayPlayerIndex: shouldTakeover ? null : playerIndex, // å¦‚æœæ¥é£ï¼Œæ¸…ç©ºlastPlayPlayerIndexï¼›å¦åˆ™ä¿æŒä¸ºå½“å‰ç©å®¶
          roundScore: 0, // åˆ†æ•°å·²ç»ç»™ç©å®¶äº†ï¼Œé‡ç½®è½®æ¬¡åˆ†æ•°
          currentRoundPlays: shouldTakeover ? [] : [...prev.currentRoundPlays, playRecord], // å¦‚æœæ¥é£ï¼Œæ¸…ç©ºè®°å½•ï¼›å¦åˆ™æ·»åŠ è®°å½•
          finishOrder: newFinishOrder
        };
        
        // å®æ—¶æ ¡éªŒå¡ç‰Œæ€»æ•°ï¼ˆå‡ºç‰Œåï¼‰
        // æ³¨æ„ï¼šå¦‚æœåªå‰©ä¸€ä¸ªç©å®¶ï¼ŒéªŒè¯ä¼šåœ¨ handleGameEnd ä¸­è¿›è¡Œï¼Œè¿™é‡Œè·³è¿‡
        // å› ä¸ºæ­¤æ—¶æ¸¸æˆçŠ¶æ€è¿˜ä¸å®Œæ•´ï¼ˆæ¨¡æ‹Ÿè½®è¿˜æ²¡åˆ›å»ºï¼‰
        const remainingPlayersAfterPlay = newPlayers.filter(p => p.hand.length > 0);
        if (remainingPlayersAfterPlay.length > 1) {
          // åªæœ‰è¿˜æœ‰å¤šä¸ªç©å®¶æ—¶ï¼Œæ‰è¿›è¡ŒéªŒè¯
          try {
            const validationResult = validateCardIntegritySimple(
              newPlayers,
              [],
              prev.initialHands,
              prev.allRounds || [],
              newState.currentRoundPlays
            );
            
            if (!validationResult.isValid) {
              console.error('[CardValidation] âš ï¸ å‡ºç‰ŒåéªŒè¯å¤±è´¥ï¼ˆç©å®¶å‡ºå®Œï¼‰ï¼', {
                context: `ç©å®¶${playerIndex}(${player.name})å‡ºå®Œç‰Œå`,
                playerIndex,
                playerName: player.name,
                cardsPlayed: selectedCards.length,
                validationResult,
                gameState: {
                  roundNumber: newState.roundNumber,
                  currentRoundPlaysCount: newState.currentRoundPlays.length,
                  allRoundsCount: (prev.allRounds || []).length,
                  playersHandCounts: newPlayers.map(p => ({ id: p.id, name: p.name, handCount: p.hand.length }))
                }
              });
              
              window.dispatchEvent(new CustomEvent('cardValidationError', {
                detail: {
                  message: validationResult.errorMessage || 'ç‰Œæ•°éªŒè¯å¤±è´¥',
                  details: {
                    expected: validationResult.expectedTotal,
                    found: validationResult.actualTotal,
                    missing: validationResult.missingCards,
                    playedCards: validationResult.playedCardsCount,
                    playerHands: validationResult.playerHandsCount,
                    details: validationResult.details
                  }
                }
              }));
            } else {
              console.log('[CardValidation] âœ… å‡ºç‰ŒåéªŒè¯é€šè¿‡ï¼ˆç©å®¶å‡ºå®Œï¼‰', {
                context: `ç©å®¶${playerIndex}(${player.name})å‡ºå®Œç‰Œå`,
                playerIndex,
                expectedTotal: validationResult.expectedTotal,
                actualTotal: validationResult.actualTotal
              });
            }
          } catch (error) {
            console.error('[CardValidation] âŒ æ ¡éªŒè¿‡ç¨‹å‡ºé”™:', error);
          }
        } else {
          // åªå‰©ä¸€ä¸ªç©å®¶ï¼ŒéªŒè¯ä¼šåœ¨ handleGameEnd ä¸­è¿›è¡Œ
          console.log('[CardValidation] â­ï¸ è·³è¿‡éªŒè¯ï¼ˆåªå‰©ä¸€ä¸ªç©å®¶ï¼Œå°†åœ¨ handleGameEnd ä¸­éªŒè¯ï¼‰');
        }
        
        // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
        const currentPlayerVoice = newPlayers[playerIndex]?.voiceConfig;
        // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
        announcePlay(play, currentPlayerVoice).catch(console.error);
        
        // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
          if (newPlayers[nextPlayerIndex].type === PlayerType.AI) {
            setTimeout(() => {
              if (schedulerRef.current) {
                schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
              }
          }, 1500);
        }
        
        return newState;
      }

      // è®¡ç®—ä¸‹ä¸€ä¸ªç©å®¶ï¼Œè·³è¿‡å·²å‡ºå®Œçš„ç©å®¶
      const nextPlayerIndex = findNextActivePlayer(playerIndex, newPlayers, prev.playerCount);
      
      // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
      if (nextPlayerIndex === null) {
        const allFinished = newPlayers.every(p => p.hand.length === 0);
        if (allFinished) {
          const finishOrder = prev.finishOrder || [];
          const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, finishOrder);
          const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
          
          return {
            ...prev,
            status: GameStatus.FINISHED,
            players: finalPlayers,
            winner: winner.player.id,
            finishOrder: finishOrder,
            finalRankings
          };
        }
        return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
      }

      const newState = {
        ...prev,
        players: newPlayers,
        currentPlayerIndex: nextPlayerIndex,
        lastPlay: play,
        lastPlayPlayerIndex: playerIndex,
        roundScore: prev.roundScore + playScore, // ç´¯åŠ è½®æ¬¡åˆ†æ•°
        currentRoundPlays: [...(prev.currentRoundPlays || []), playRecord] // è®°å½•è¿™ä¸€æ‰‹å‡ºç‰Œ
      };

      // å®æ—¶æ ¡éªŒå¡ç‰Œæ€»æ•°ï¼ˆå‡ºç‰Œåï¼‰
      try {
        const validationResult = validateCardIntegritySimple(
          newPlayers,
          [], // allPlayedCards ä¸ä½¿ç”¨ï¼Œä» allRounds å’Œ currentRoundPlays ç»Ÿè®¡
          prev.initialHands,
          prev.allRounds || [],
          newState.currentRoundPlays
        );
        
        if (!validationResult.isValid) {
          console.error('[CardValidation] âš ï¸ å‡ºç‰ŒåéªŒè¯å¤±è´¥ï¼', {
            context: `ç©å®¶${playerIndex}(${player.name})å‡ºç‰Œå`,
            playerIndex,
            playerName: player.name,
            cardsPlayed: selectedCards.length,
            cards: selectedCards.map(c => `${c.suit}-${c.rank}`),
            validationResult: {
              isValid: validationResult.isValid,
              expectedTotal: validationResult.expectedTotal,
              actualTotal: validationResult.actualTotal,
              missingCards: validationResult.missingCards,
              playedCardsCount: validationResult.playedCardsCount,
              playerHandsCount: validationResult.playerHandsCount,
              errorMessage: validationResult.errorMessage,
              details: validationResult.details
            },
            gameState: {
              roundNumber: newState.roundNumber,
              currentRoundPlaysCount: newState.currentRoundPlays.length,
              allRoundsCount: (prev.allRounds || []).length,
              playersHandCounts: newPlayers.map(p => ({ id: p.id, name: p.name, handCount: p.hand.length }))
            }
          });
          
          // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ï¼Œç”¨äºUIæ˜¾ç¤ºé”™è¯¯æç¤º
          window.dispatchEvent(new CustomEvent('cardValidationError', {
            detail: {
              message: validationResult.errorMessage || 'ç‰Œæ•°éªŒè¯å¤±è´¥',
              details: {
                expected: validationResult.expectedTotal,
                found: validationResult.actualTotal,
                missing: validationResult.missingCards,
                playedCards: validationResult.playedCardsCount,
                playerHands: validationResult.playerHandsCount,
                details: validationResult.details
              }
            }
          }));
        } else {
          console.log('[CardValidation] âœ… å‡ºç‰ŒåéªŒè¯é€šè¿‡', {
            context: `ç©å®¶${playerIndex}(${player.name})å‡ºç‰Œå`,
            playerIndex,
            playerName: player.name,
            cardsPlayed: selectedCards.length,
            expectedTotal: validationResult.expectedTotal,
            actualTotal: validationResult.actualTotal,
            playedCardsCount: validationResult.playedCardsCount,
            playerHandsCount: validationResult.playerHandsCount
          });
        }
      } catch (error) {
        console.error('[CardValidation] âŒ æ ¡éªŒè¿‡ç¨‹å‡ºé”™:', error);
      }

      // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
      const currentPlayerVoice = newPlayers[playerIndex]?.voiceConfig;
      // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
      announcePlay(play, currentPlayerVoice).catch(console.error);
      
      // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
      if (newPlayers[nextPlayerIndex].type === PlayerType.AI) {
          setTimeout(() => {
              if (schedulerRef.current) {
                schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
              }
        }, 1500);
      }

      return newState;
    });

    return true;
  }, [playNextTurn]);

  // å¼‚æ­¥å‡ºç‰Œå¤„ç†å‡½æ•°ï¼ˆä½¿ç”¨ Round ç±»ï¼‰
  const playerPlayAsync = useCallback(async (
    playerIndex: number,
    selectedCards: Card[]
  ): Promise<boolean> => {
    const stackTrace = new Error().stack?.split('\n').slice(2, 8).join('\n') || 'unknown';
    const currentState = gameStateRef.current;
    
    // æ£€æµ‹æ˜¯å¦æ˜¯çœŸå®ç©å®¶ï¼ˆåœ¨å‡½æ•°å¼€å§‹å¤„å®šä¹‰ï¼Œç¡®ä¿æ•´ä¸ªå‡½æ•°éƒ½å¯ä»¥è®¿é—®ï¼‰
    const isHumanPlayer = currentState.players[playerIndex]?.isHuman || false;
    const playerName = currentState.players[playerIndex]?.name || 'æœªçŸ¥';
    
    // è·å–å½“å‰è½®æ¬¡
    const round = getCurrentRound(currentState);
    const currentRoundNumber = getCurrentRoundNumber(currentState);
    const currentRoundPlays = getCurrentRoundPlays(currentState);
    const lastPlay = getLastPlay(currentState);
    const lastPlayPlayerIndex = getLastPlayPlayerIndex(currentState);
    
    // çœŸå®ç©å®¶å‡ºç‰Œæ—¶ï¼Œæ·»åŠ æ›´è¯¦ç»†çš„æ—¥å¿—
    if (isHumanPlayer) {
      console.error(`[playerPlayAsync] ğŸ”µ çœŸå®ç©å®¶å‡ºç‰Œå¼€å§‹`, {
        playerIndex,
        playerName,
        cardsCount: selectedCards.length,
        selectedCards: selectedCards.map((c: Card) => `${c.suit}-${c.rank}`),
        roundNumber: currentRoundNumber,
        currentPlayerIndex: currentState.currentPlayerIndex,
        isCurrentPlayer: currentState.currentPlayerIndex === playerIndex,
        hasCurrentRound: !!round,
        currentRoundPlaysCount: currentRoundPlays.length,
        currentRoundPlays: currentRoundPlays.map(p => ({
          playerId: p.playerId,
          playerName: p.playerName,
          cardsCount: p.cards.length,
          cards: p.cards.map((c: Card) => `${c.suit}-${c.rank}`)
        })),
        lastPlay: lastPlay ? {
          type: lastPlay.type,
          value: lastPlay.value,
          cards: lastPlay.cards?.map((c: Card) => `${c.suit}-${c.rank}`)
        } : null,
        lastPlayPlayerIndex: lastPlayPlayerIndex,
        players: currentState.players.map((p, i) => ({
          index: i,
          name: p.name,
          isHuman: p.isHuman,
          handCount: p.hand.length
        })),
        stackTrace: stackTrace.substring(0, 500),
        timestamp: Date.now()
      });
    } else {
      console.warn(`[playerPlayAsync] â†’ è¢«è°ƒç”¨`, {
        playerIndex,
        playerName,
        cardsCount: selectedCards.length,
        roundNumber: currentRoundNumber,
        currentPlayerIndex: currentState.currentPlayerIndex,
        hasCurrentRound: !!round,
        hasProcessingPlay: round?.hasProcessingPlay(),
        stackTrace: stackTrace.substring(0, 300),
        timestamp: Date.now()
      });
    }
    
    // å¦‚æœæ²¡æœ‰ Round å¯¹è±¡ï¼Œè¿”å›é”™è¯¯ï¼ˆä¸åº”è¯¥å‘ç”Ÿï¼Œå› ä¸ºæ¸¸æˆå¼€å§‹æ—¶åº”è¯¥åˆ›å»º Roundï¼‰
    if (!round) {
      console.error('[playerPlayAsync] âœ— currentRound æœªåˆå§‹åŒ–ï¼Œæ— æ³•å¤„ç†å‡ºç‰Œ', {
        playerIndex,
        stackTrace: stackTrace.substring(0, 200),
        timestamp: Date.now()
      });
      return false;
    }

    try {
      // æ£€æŸ¥è½®æ¬¡å·æ˜¯å¦åŒ¹é…ï¼ˆé˜²æ­¢å¤„ç†æ—§è½®æ¬¡çš„è¯·æ±‚ï¼‰
      if (round.roundNumber !== currentRoundNumber) {
        console.warn(`[playerPlayAsync] âš ï¸ è½®æ¬¡å·ä¸åŒ¹é…ï¼Œå¿½ç•¥æ—§è½®æ¬¡çš„å‡ºç‰Œè¯·æ±‚`, {
          requestRoundNumber: round.roundNumber,
          currentRoundNumber: currentRoundNumber,
          playerIndex,
          playerName: currentState.players[playerIndex]?.name || 'æœªçŸ¥',
          stackTrace: stackTrace.substring(0, 200),
          timestamp: Date.now()
        });
        return false;
      }
      
      // åœ¨å¼€å§‹å¤„ç†ä¹‹å‰ï¼Œæ£€æŸ¥è½®æ¬¡æ˜¯å¦å·²ç»“æŸ
      if (!round || round.isEnded()) {
        console.warn(`[playerPlayAsync] âš ï¸ è½®æ¬¡ ${round?.roundNumber || 'æœªçŸ¥'} å·²ç»“æŸï¼Œæ— æ³•å¤„ç†ç©å®¶ ${playerIndex} çš„å‡ºç‰Œ`, {
          roundNumber: round?.roundNumber || null,
          playerIndex,
          playerName: currentState.players[playerIndex]?.name || 'æœªçŸ¥',
          isRoundNull: !round,
          isEnded: round?.isEnded() || false,
          gameStatus: currentState.status,
          currentPlayerIndex: currentState.currentPlayerIndex,
          stackTrace: stackTrace.substring(0, 200),
          timestamp: Date.now()
        });
        return false;
      }
      
      // ä½¿ç”¨è¾…åŠ©å‡½æ•°å¤„ç†å¼‚æ­¥å‡ºç‰Œ
      const result = await processPlayAsync(
        round,
        playerIndex,
        selectedCards,
        currentState.players,
        currentState.playerCount,
        currentState.players.findIndex(p => p.isHuman),
        { 
          timingConfig: gameConfig.timingConfig, 
          cardTrackerEnabled: cardTrackerEnabled 
        } as { timingConfig?: any; cardTrackerEnabled?: boolean },
        setGameState,
        () => gameStateRef.current
      );

      if (result.status === 'completed') {
        // å¤„ç†å‡ºç‰Œå®Œæˆåçš„é€»è¾‘
        const updatedState = gameStateRef.current;
        const updatedPlayer = updatedState.players[playerIndex];
        
        // çœŸå®ç©å®¶å‡ºç‰Œæ—¶ï¼Œæ·»åŠ æ›´è¯¦ç»†çš„æ—¥å¿—
        if (isHumanPlayer) {
          console.error(`[playerPlayAsync] ğŸ”µ çœŸå®ç©å®¶å‡ºç‰Œå¤„ç†å®Œæˆ`, {
            playerIndex,
            playerName: updatedPlayer.name || 'æœªçŸ¥',
            handCount: updatedPlayer.hand.length,
            roundNumber: round.roundNumber,
            playsCount: round.getPlayCount(),
            totalScore: round.getTotalScore(),
            lastPlayPlayerIndex: round.getLastPlayPlayerIndex(),
            hasProcessingPlay: round.hasProcessingPlay(),
            allPlays: round.getPlays().map(p => ({ 
              playerId: p.playerId, 
              playerName: p.playerName, 
              cardsCount: p.cards.length,
              cards: p.cards.map((c: Card) => `${c.suit}-${c.rank}`)
            })),
            playersHandCounts: updatedState.players.map((p, i) => ({ 
              index: i, 
              name: p.name, 
              handCount: p.hand.length,
              isHuman: p.isHuman
            })),
            currentRoundPlaysCount: updatedState.currentRoundPlays?.length || 0,
            currentRoundPlays: updatedState.currentRoundPlays?.map(p => ({
              playerId: p.playerId,
              playerName: p.playerName,
              cardsCount: p.cards.length,
              cards: p.cards.map((c: Card) => `${c.suit}-${c.rank}`)
            })),
            timestamp: Date.now()
          });
        } else {
          console.warn(`[playerPlayAsync] âœ“ å‡ºç‰Œå¤„ç†å®Œæˆ`, {
            playerIndex,
            playerName: updatedPlayer.name || 'æœªçŸ¥',
            handCount: updatedPlayer.hand.length,
            roundNumber: round.roundNumber,
            playsCount: round.getPlayCount(),
            totalScore: round.getTotalScore(),
            lastPlayPlayerIndex: round.getLastPlayPlayerIndex(),
            hasProcessingPlay: round.hasProcessingPlay(),
            allPlays: round.getPlays().map(p => ({ 
              playerId: p.playerId, 
              playerName: p.playerName, 
              cardsCount: p.cards.length 
            })),
            playersHandCounts: updatedState.players.map((p, i) => ({ 
              index: i, 
              name: p.name, 
              handCount: p.hand.length 
            })),
            timestamp: Date.now()
          });
        }
        
        // æ£€æŸ¥æ˜¯å¦å‡ºå®Œç‰Œ
        if (updatedPlayer.hand.length === 0) {
          const newFinishOrder = [...(updatedState.finishOrder || []), playerIndex];
          
          setGameState(prev => {
            // ä½¿ç”¨æœ€æ–°çš„ round å¯¹è±¡è·å– currentRoundPlaysï¼Œç¡®ä¿åŒ…å«æ‰€æœ‰å‡ºç‰Œè®°å½•
            const latestRound = round; // ä½¿ç”¨é—­åŒ…ä¸­çš„ round å¯¹è±¡
            const currentRoundPlays = [...latestRound.getPlays()]; // è½¬æ¢ä¸ºå¯å˜æ•°ç»„
            
            console.warn(`[playerPlayAsync] â†’ ç©å®¶å‡ºå®Œç‰Œï¼Œæ›´æ–°finishOrderï¼Œä¿ç•™currentRoundPlays`, {
          playerIndex,
              finishOrderLength: newFinishOrder.length,
              currentRoundPlaysCount: currentRoundPlays.length,
              currentRoundPlays: currentRoundPlays.map(p => ({ playerId: p.playerId, playerName: p.playerName, cardsCount: p.cards.length, cards: p.cards.map((c: Card) => `${c.suit}-${c.rank}`) })),
              timestamp: Date.now()
            });
          
          return {
            ...prev,
              finishOrder: newFinishOrder,
              currentRoundPlays: currentRoundPlays, // ä½¿ç”¨æœ€æ–°çš„å‡ºç‰Œè®°å½•
              currentRound: latestRound, // ç¡®ä¿ currentRound å¼•ç”¨æœ€æ–°çš„ round å¯¹è±¡
              players: prev.players.map((p, i) => 
                i === playerIndex ? { ...p, finishedRank: newFinishOrder.length } : p
              )
          };
        });
        }
        
        // é‡æ–°è·å–æ›´æ–°åçš„çŠ¶æ€
        const finalState = gameStateRef.current;
        const finalRound = finalState.currentRound;
        
        if (!finalRound) {
          console.error('[playerPlayAsync] âš ï¸ æ— æ³•è·å– Round å¯¹è±¡');
          return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€å¤§ç‰Œï¼ˆç®€åŒ–é€»è¾‘ï¼šæš‚æ—¶ä¸æ£€æŸ¥ï¼Œç”± Round.shouldEnd å†…éƒ¨å¤„ç†ï¼‰
        const isMaxPlay = false; // TODO: å®ç° isMaxPlayInRound æ£€æŸ¥
        
        // å®šä¹‰è½®æ¬¡ç»“æŸå›è°ƒ
        const handleRoundEnd = async (finalRound: Round, players: Player[], nextPlayerIndex: number | null) => {
          console.warn(`[playerPlayAsync] âš ï¸ è½®æ¬¡åº”è¯¥ç»“æŸï¼Œä¸‹ä¸€ä¸ªç©å®¶${nextPlayerIndex}æ˜¯æœ€åå‡ºç‰Œçš„äºº`, {
            roundNumber: finalRound.roundNumber,
            nextPlayerIndex,
            lastPlayPlayerIndex: finalRound.getLastPlayPlayerIndex(),
            playsCount: finalRound.getPlayCount(),
            totalScore: finalRound.getTotalScore(),
            hasProcessingPlay: finalRound.hasProcessingPlay(),
            allPlays: finalRound.getPlays().map(p => ({ 
              playerId: p.playerId, 
              playerName: p.playerName, 
              cardsCount: p.cards.length,
              score: p.score
            })),
            playersHandCounts: players.map((p, i) => ({ index: i, name: p.name, handCount: p.hand.length })),
            timestamp: Date.now()
          });
          
          // ç»“æŸè½®æ¬¡
          const { updatedPlayers, nextPlayerIndex: newNext } = finalRound.end(
            players,
            finalState.playerCount
          );
          
          const roundRecord = finalRound.toRecord();
          
          // ç¡®ä¿è®°ç‰Œå™¨ä¸­æœ‰è¿™ä¸ªè½®æ¬¡çš„è®°å½•
          if (cardTrackerEnabled) {
            try {
              ensureRoundInTracker(finalRound.roundNumber, roundRecord, updatedPlayers);
            } catch (error) {
              console.error(`[playerPlayAsync] âœ— è®°ç‰Œå™¨è®°å½•å¤±è´¥`, {
                roundNumber: finalRound.roundNumber,
                error: error instanceof Error ? error.message : String(error),
                timestamp: Date.now()
              });
            }
          }
          
          const nextRound = Round.createNew(
            finalRound.roundNumber + 1, 
            Date.now(), 
            gameConfig.timingConfig
          );
          
          // éªŒè¯æ–°è½®æ¬¡çŠ¶æ€æ˜¯å¦æ­£ç¡®åˆå§‹åŒ–
          if (nextRound.getLastPlayPlayerIndex() !== null || nextRound.getLastPlay() !== null) {
            console.error(`[playerPlayAsync] âœ— æ–°è½®æ¬¡çŠ¶æ€åˆå§‹åŒ–é”™è¯¯`, {
              roundNumber: finalRound.roundNumber + 1,
              lastPlayPlayerIndex: nextRound.getLastPlayPlayerIndex(),
              lastPlay: nextRound.getLastPlay(),
              timestamp: Date.now()
            });
          }
          
          // å¼€å§‹æ–°è½®æ¬¡æ—¶ï¼Œåœ¨è®°ç‰Œå™¨ä¸­åˆ›å»ºè®°å½•ï¼ˆå¦‚æœå¯ç”¨ï¼‰
          if (cardTrackerEnabled) {
            const newRoundNumber = finalRound.roundNumber + 1;
            const stackTrace = new Error().stack?.split('\n').slice(2, 8).join('\n') || 'unknown';
            console.warn(`[playerPlayAsync] â†’ å‡†å¤‡å¼€å§‹æ–°è½®æ¬¡${newRoundNumber}`, {
              oldRoundNumber: finalRound.roundNumber,
              newRoundNumber,
              existingRounds: cardTracker.getAllRounds().map(r => r.roundNumber).sort((a, b) => a - b),
              playersCount: updatedPlayers.length,
              stackTrace: stackTrace.substring(0, 300),
              timestamp: Date.now()
            });
            
            try {
              cardTracker.startRound(newRoundNumber, updatedPlayers);
              console.warn(`[playerPlayAsync] âœ“ æ–°è½®æ¬¡${newRoundNumber}å·²åˆ›å»º`, {
                totalRounds: cardTracker.getAllRounds().length,
                roundExists: !!cardTracker.getRound(newRoundNumber),
                timestamp: Date.now()
              });
            } catch (error) {
              console.error(`[playerPlayAsync] âœ— è®°ç‰Œå™¨å¼€å§‹æ–°è½®æ¬¡å¤±è´¥`, {
                roundNumber: newRoundNumber,
                error: error instanceof Error ? error.message : String(error),
                stackTrace: stackTrace.substring(0, 200),
                timestamp: Date.now()
              });
            }
          }
          
          setGameState(prev => {
            // å°†æ–°è½®æ¬¡æ·»åŠ åˆ° rounds æ•°ç»„
            const updatedRounds = [...prev.rounds, nextRound];
            const newRoundIndex = updatedRounds.length - 1;
            
            return {
              ...prev,
              players: updatedPlayers,
              rounds: updatedRounds,
              currentRoundIndex: newRoundIndex,
              currentPlayerIndex: newNext || prev.currentPlayerIndex
            };
          });
          
          // éªŒè¯çŠ¶æ€æ›´æ–°åçš„æ–°è½®æ¬¡çŠ¶æ€
          const verifyState = gameStateRef.current;
          const verifyRound = getCurrentRound(verifyState);
          if (verifyRound && 
              (verifyRound.getLastPlayPlayerIndex() !== null || 
               verifyRound.getLastPlay() !== null)) {
            console.error(`[playerPlayAsync] âœ— çŠ¶æ€æ›´æ–°åæ–°è½®æ¬¡çŠ¶æ€é”™è¯¯`, {
              roundNumber: verifyRound.roundNumber,
              lastPlayPlayerIndex: verifyRound.getLastPlayPlayerIndex(),
              lastPlay: verifyRound.getLastPlay(),
              timestamp: Date.now()
            });
          }
          
          console.warn(`[playerPlayAsync] âš ï¸ è½®æ¬¡${finalRound.roundNumber}ç»“æŸï¼Œæ–°è½®æ¬¡${finalRound.roundNumber + 1}å¼€å§‹`, {
            oldRoundNumber: finalRound.roundNumber,
            newRoundNumber: finalRound.roundNumber + 1,
            nextPlayerIndex: newNext,
            winnerId: roundRecord.winnerId,
            winnerName: roundRecord.winnerName,
            totalScore: roundRecord.totalScore,
            playsCount: roundRecord.plays.length,
            roundsCount: verifyState.rounds.length,
            trackerRoundsCount: cardTracker.getAllRounds().length,
            timestamp: Date.now()
          });
          
          // æ›´æ–°è°ƒåº¦å™¨çš„è½®æ¬¡å·
          if (schedulerRef.current) {
            schedulerRef.current.updateRoundNumber(finalRound.roundNumber + 1);
          }
          
          // å¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œæˆ–è€…ä¸‹ä¸€ä¸ªç©å®¶æ˜¯çœŸå®ç©å®¶ä¸”å¼€å¯äº†æ‰˜ç®¡ï¼Œè‡ªåŠ¨ç»§ç»­
          // ä½†éœ€è¦ç¡®ä¿æ–°è½®æ¬¡æ²¡æœ‰æ­£åœ¨å¤„ç†çš„å‡ºç‰Œï¼Œå¹¶ä¸”çŠ¶æ€å·²å®Œå…¨æ›´æ–°
          const nextPlayerForNewRound = newNext !== null ? updatedPlayers[newNext] : null;
          const shouldAutoContinueNewRound = nextPlayerForNewRound && (
            nextPlayerForNewRound.type === PlayerType.AI || 
            (nextPlayerForNewRound.isHuman && isAutoPlayRef.current)
          );
          
          if (shouldAutoContinueNewRound) {
            // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿æ–°è½®æ¬¡çŠ¶æ€å·²æ›´æ–°ï¼Œå¹¶ä¸”é¿å…ä¸ useEffect ç›‘å¬å†²çª
            setTimeout(() => {
              const verifyState = gameStateRef.current;
              const verifyRound = getCurrentRound(verifyState);
              const verifyRoundNumber = getCurrentRoundNumber(verifyState);
              // æ£€æŸ¥è½®æ¬¡å·æ˜¯å¦åŒ¹é…ï¼Œé¿å…å¤„ç†æ—§è½®æ¬¡
              if (verifyRoundNumber === finalRound.roundNumber + 1 &&
                  !verifyRound?.hasProcessingPlay()) {
                // å†æ¬¡æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å…¶ä»– playNextTurn åœ¨å¤„ç†
                if (!isAITurnProcessingRef.current) {
                  if (schedulerRef.current) {
                    schedulerRef.current.scheduleNextTurn(verifyState.currentPlayerIndex, 0);
                  }
                } else {
                  console.warn(`[playerPlayAsync] âš ï¸ å·²æœ‰AIå›åˆåœ¨å¤„ç†ï¼Œè·³è¿‡é‡å¤è°ƒç”¨playNextTurn`, {
                    roundNumber: verifyRoundNumber,
                    currentPlayerIndex: verifyState.currentPlayerIndex,
                    isAITurnProcessing: isAITurnProcessingRef.current,
                    timestamp: Date.now()
                  });
                }
              } else {
                console.warn(`[playerPlayAsync] âš ï¸ æ–°è½®æ¬¡çŠ¶æ€æœªå°±ç»ªï¼Œå»¶è¿Ÿè°ƒç”¨playNextTurn`, {
                  expectedRoundNumber: finalRound.roundNumber + 1,
                  actualRoundNumber: verifyRoundNumber,
                  hasProcessingPlay: verifyRound?.hasProcessingPlay(),
                  timestamp: Date.now()
                });
                // ç­‰å¾…å‡ºç‰Œå¤„ç†å®Œæˆåå†ç»§ç»­
                setTimeout(async () => {
                  const retryState = gameStateRef.current;
                  const retryRound = getCurrentRound(retryState);
                  const retryRoundNumber = getCurrentRoundNumber(retryState);
                  if (retryRoundNumber === finalRound.roundNumber + 1 &&
                      !retryRound?.hasProcessingPlay() &&
                      !isAITurnProcessingRef.current) {
                    if (schedulerRef.current) {
                      schedulerRef.current.scheduleNextTurn(retryState.currentPlayerIndex, 0);
                    }
                  }
                }, 500);
              }
            }, 300);
          } else {
            console.log(`[playerPlayAsync] æ–°è½®æ¬¡ä¸‹ä¸€ä¸ªç©å®¶æ˜¯çœŸå®ç©å®¶ä¸”æœªå¼€å¯æ‰˜ç®¡ï¼Œç­‰å¾…æ‰‹åŠ¨æ“ä½œ`, {
              nextPlayerIndex: newNext,
              nextPlayerType: nextPlayerForNewRound?.type,
              isHuman: nextPlayerForNewRound?.isHuman,
              isAutoPlay: isAutoPlayRef.current,
              timestamp: Date.now()
            });
          }
        };
        
        // ä½¿ç”¨ RoundScheduler å¤„ç†è°ƒåº¦é€»è¾‘ï¼ˆæ¥é£åˆ¤å®šã€è½®æ¬¡ç»“æŸã€ä¸‹ä¸€ä¸ªç©å®¶ï¼‰
        if (schedulerRef.current) {
          // ä½¿ç”¨ç±»å‹æ–­è¨€ï¼Œå› ä¸º TypeScript å¯èƒ½è¿˜æ²¡æœ‰è¯†åˆ«åˆ°æ–°æ·»åŠ çš„æ–¹æ³•
          const scheduler = schedulerRef.current as any;
          if (scheduler.onPlayCompleted) {
            await scheduler.onPlayCompleted(
              playerIndex,
              finalRound,
              finalState.players,
              finalState.playerCount,
              setGameState,
              handleRoundEnd,
              isMaxPlay
            );
            
            // ç­‰å¾…çŠ¶æ€æ›´æ–°å®Œæˆåå†éªŒè¯
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // éªŒè¯æœ€ç»ˆçŠ¶æ€ï¼ˆåœ¨ onPlayCompleted ä¹‹åï¼‰
            const verifyState = gameStateRef.current;
            const verifyRound = verifyState.currentRound;
            console.warn(`[playerPlayAsync] â†’ æœ€ç»ˆçŠ¶æ€éªŒè¯ï¼ˆonPlayCompletedåï¼‰`, {
              currentRoundPlaysCount: verifyState.currentRoundPlays?.length || 0,
              roundPlaysFromRound: verifyRound?.getPlays().length || 0,
              currentRoundPlays: verifyState.currentRoundPlays?.map(p => ({ playerId: p.playerId, playerName: p.playerName, cardsCount: p.cards.length })),
              roundPlays: verifyRound?.getPlays().map(p => ({ playerId: p.playerId, playerName: p.playerName, cardsCount: p.cards.length })),
              playerIndex,
              isHuman: verifyState.players[playerIndex]?.isHuman,
              timestamp: Date.now()
            });
            
            // å¦‚æœçŠ¶æ€ä¸ä¸€è‡´ï¼Œå¼ºåˆ¶åŒæ­¥
            if (verifyRound && verifyState.currentRoundPlays?.length !== verifyRound.getPlays().length) {
              console.error(`[playerPlayAsync] âš ï¸ çŠ¶æ€ä¸ä¸€è‡´ï¼å¼ºåˆ¶åŒæ­¥`, {
                currentRoundPlaysCount: verifyState.currentRoundPlays?.length || 0,
                roundPlaysFromRound: verifyRound.getPlays().length || 0,
                playerIndex,
                timestamp: Date.now()
              });
              
              setGameState(prev => {
                if (!prev.currentRound) return prev;
                const latestRound = prev.currentRound;
                const finalCurrentRoundPlays = Array.from(latestRound.getPlays());
                return {
                  ...prev,
                  currentRoundPlays: finalCurrentRoundPlays,
                  currentRound: latestRound
                };
              });
            }
          } else {
            console.error('[playerPlayAsync] âš ï¸ RoundScheduler.onPlayCompleted æ–¹æ³•ä¸å­˜åœ¨');
          }
        } else {
          console.error('[playerPlayAsync] âš ï¸ RoundScheduler æœªåˆå§‹åŒ–');
        }
        
        return true;
      }
      
      return false;
    } catch (error) {
      console.error('[playerPlayAsync] å‡ºç‰Œå¤„ç†å¤±è´¥:', error);
      return false;
    }
  }, [playerPlay, playNextTurn, gameConfig]);

  // ç©å®¶è¦ä¸èµ·ï¼ˆå¼ºåˆ¶å‡ºç‰Œè§„åˆ™ï¼šå¦‚æœæœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¸èƒ½è¦ä¸èµ·ï¼‰
  const playerPass = useCallback((playerIndex: number) => {
    setGameState(prev => {
      if (prev.status !== GameStatus.PLAYING) return prev;
      if (prev.currentPlayerIndex !== playerIndex) return prev;

      const player = prev.players[playerIndex];
      if (!player) return prev;
      
      // å¦‚æœç©å®¶å·²ç»å‡ºå®Œç‰Œäº†ï¼Œè‡ªåŠ¨è·³è¿‡åˆ°ä¸‹ä¸€ä¸ªç©å®¶
      if (player.hand.length === 0) {
        // æ‰¾åˆ°ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶
        const nextPlayerIndex = findNextActivePlayer(playerIndex, prev.players, prev.playerCount);
        
        // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
        if (nextPlayerIndex === null) {
          const allFinished = prev.players.every(p => p.hand.length === 0);
          if (allFinished) {
            const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(prev.players, prev.finishOrder || []);
            const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
            
            return {
              ...prev,
              status: GameStatus.FINISHED,
              players: finalPlayers,
              winner: winner.player.id,
              finalRankings
            };
          }
          return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
        }
        
        const newState = {
          ...prev,
          currentPlayerIndex: nextPlayerIndex
        };
        
        // å¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
        if (prev.players[nextPlayerIndex].type === PlayerType.AI) {
          setTimeout(() => {
            if (schedulerRef.current) {
              schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
            }
          }, 100);
        }
        
        return newState;
      }

      // å¼ºåˆ¶å‡ºç‰Œè§„åˆ™ï¼šå¦‚æœæœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¸èƒ½è¦ä¸èµ·
      if (prev.lastPlay) {
        const hasPlayable = hasPlayableCards(player.hand, prev.lastPlay);
        if (hasPlayable) {
          // æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¸å…è®¸è¦ä¸èµ·
          return prev; // ä¸æ›´æ–°çŠ¶æ€ï¼Œä¿æŒå½“å‰çŠ¶æ€
        }
      }

      // æ’­æ”¾"è¦ä¸èµ·"è¯­éŸ³æç¤ºï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡çŠ¶æ€æ›´æ–°ï¼‰
      // æ³¨æ„ï¼šä¼šåœ¨çŠ¶æ€æ›´æ–°åç»Ÿä¸€å¤„ç†
      // ç«‹å³æ’­æ”¾"è¦ä¸èµ·"è¯­éŸ³ï¼ˆåœ¨çŠ¶æ€æ›´æ–°å‰ï¼Œç¡®ä¿èƒ½æ’­æ”¾ï¼‰
      const currentPlayerVoice = prev.players[playerIndex]?.voiceConfig;
      if (currentPlayerVoice) {
        console.log('[useMultiPlayerGame] ç©å®¶è¦ä¸èµ·ï¼Œç«‹å³æ’­æ”¾è¯­éŸ³:', player.name, 'voiceConfig:', currentPlayerVoice);
        announcePass(currentPlayerVoice).catch(err => {
          console.error('[useMultiPlayerGame] æ’­æ”¾"è¦ä¸èµ·"è¯­éŸ³å¤±è´¥:', err);
        });
      } else {
        console.warn('[useMultiPlayerGame] ç©å®¶è¦ä¸èµ·ï¼Œä½†æ²¡æœ‰voiceConfig:', player.name, playerIndex);
        // å³ä½¿æ²¡æœ‰voiceConfigï¼Œä¹Ÿå°è¯•æ’­æ”¾ï¼ˆä½¿ç”¨é»˜è®¤è¯­éŸ³ï¼‰
        announcePass(undefined).catch(err => {
          console.error('[useMultiPlayerGame] æ’­æ”¾"è¦ä¸èµ·"è¯­éŸ³å¤±è´¥ï¼ˆæ— voiceConfigï¼‰:', err);
        });
      }

      // è®¡ç®—ä¸‹ä¸€ä¸ªç©å®¶ï¼Œè·³è¿‡å·²å‡ºå®Œçš„ç©å®¶
      const nextPlayerIndex = findNextActivePlayer(playerIndex, prev.players, prev.playerCount);
      
      // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
      if (nextPlayerIndex === null) {
        const allFinished = prev.players.every(p => p.hand.length === 0);
        if (allFinished) {
          const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(prev.players, prev.finishOrder || []);
          const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
          
          return {
            ...prev,
            status: GameStatus.FINISHED,
            players: finalPlayers,
            winner: winner.player.id,
            finalRankings
          };
        }
        return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
      }

      const newPlayers = [...prev.players];
      
      // åªè¦æœ‰äºº"è¦ä¸èµ·"ï¼Œä¸”æœ¬è½®æœ‰å‡ºç‰Œè®°å½•ï¼ˆlastPlayPlayerIndexä¸ä¸ºnullï¼‰ï¼Œåˆ™å¼ºåˆ¶ç»“æŸæœ¬è½®
      if (prev.lastPlayPlayerIndex !== null) {
        // å¼ºåˆ¶ç»“æŸæœ¬è½®ï¼ŒæŠŠåˆ†æ•°ç»™æœ€åå‡ºç‰Œçš„äºº
        const lastPlayer = newPlayers[prev.lastPlayPlayerIndex];
        if (lastPlayer) {
          // åˆ›å»ºè½®æ¬¡è®°å½•
          const roundRecord: RoundRecord = {
            roundNumber: prev.roundNumber,
            plays: [...prev.currentRoundPlays],
            totalScore: prev.roundScore,
            winnerId: prev.lastPlayPlayerIndex,
            winnerName: lastPlayer.name
          };
          
          // å¦‚æœæœ‰åˆ†æ•°ï¼Œç»™æœ€åå‡ºç‰Œçš„äºº
          if (prev.roundScore > 0) {
            newPlayers[prev.lastPlayPlayerIndex] = {
              ...lastPlayer,
              score: (lastPlayer.score || 0) + prev.roundScore,
              wonRounds: [...(lastPlayer.wonRounds || []), roundRecord]
            };
          }
          
          // ä¿å­˜è½®æ¬¡è®°å½•åˆ°allRounds
          const updatedAllRounds = [...(prev.allRounds || []), roundRecord];
          
          // ä¸€è½®ç»“æŸï¼Œç”±èµ¢å®¶å¼€å§‹ä¸‹ä¸€è½®ï¼ˆå¦‚æœèµ¢å®¶å·²å‡ºå®Œï¼Œæ‰¾ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰
          const winnerIndex = prev.lastPlayPlayerIndex;
          let nextActivePlayerIndex: number | null;
          if (newPlayers[winnerIndex]?.hand.length > 0) {
            nextActivePlayerIndex = winnerIndex;
          } else {
            nextActivePlayerIndex = findNextActivePlayer(winnerIndex, newPlayers, prev.playerCount);
          }
          
          // å¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
          if (nextActivePlayerIndex === null) {
            const allFinished = newPlayers.every(p => p.hand.length === 0);
            if (allFinished) {
              const { players: finalPlayers, rankings: finalRankings } = applyFinalGameRules(newPlayers, prev.finishOrder || []);
              const winner = finalRankings.sort((a, b) => b.finalScore - a.finalScore)[0];
              
              return {
                ...prev,
                status: GameStatus.FINISHED,
                players: finalPlayers,
                winner: winner.player.id,
                finalRankings
              };
            }
            return prev; // ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºä¿æŠ¤
          }
          
          const newState = {
            ...prev,
            players: newPlayers,
            currentPlayerIndex: nextActivePlayerIndex, // ç”±èµ¢å®¶ï¼ˆæˆ–ä¸‹ä¸€ä¸ªè¿˜åœ¨æ¸¸æˆä¸­çš„ç©å®¶ï¼‰å¼€å§‹ä¸‹ä¸€è½®
            lastPlay: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlay
            lastPlayPlayerIndex: null, // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºlastPlayPlayerIndex
            roundScore: 0, // æ–°è½®æ¬¡ï¼Œé‡ç½®åˆ†æ•°
            currentRoundPlays: [], // æ–°è½®æ¬¡ï¼Œæ¸…ç©ºå½“å‰è½®æ¬¡å‡ºç‰Œè®°å½•
            roundNumber: prev.roundNumber + 1, // æ–°è½®æ¬¡
            allRounds: updatedAllRounds,
            gameRecord: prev.gameRecord ? {
              ...prev.gameRecord,
              allRounds: updatedAllRounds
            } : prev.gameRecord
          };
          
          // æŠ¥ç‰Œï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šå¿…é¡»ç­‰å¾…å®Œæˆæ‰èƒ½ç»§ç»­æ¸¸æˆæµç¨‹
          // ä½¿ç”¨ä¹‹å‰å·²å£°æ˜çš„ currentPlayerVoice
          announcePass(currentPlayerVoice).then(() => {
            // æŠ¥ç‰Œå®Œæˆåï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
          if (newPlayers[nextActivePlayerIndex].type === PlayerType.AI) {
              setTimeout(() => {
                if (schedulerRef.current) {
                  schedulerRef.current.scheduleNextTurn(nextActivePlayerIndex, 0);
                }
              }, announcementDelay); // æŠ¥ç‰Œå®Œæˆåç­‰å¾…é…ç½®çš„æ—¶é—´å†ç»§ç»­
            }
            }).catch(() => {
            // å¦‚æœæŠ¥ç‰Œå¤±è´¥ï¼Œç›´æ¥ç»§ç»­ï¼ˆé¿å…å¡ä½æ¸¸æˆï¼‰
            if (newPlayers[nextActivePlayerIndex].type === PlayerType.AI) {
              setTimeout(() => {
                if (schedulerRef.current) {
                  schedulerRef.current.scheduleNextTurn(nextActivePlayerIndex, 0);
                }
              }, 1000);
          }
          });
          
          return newState;
        }
      }
      
      // å¦‚æœæ²¡æœ‰lastPlayPlayerIndexï¼ˆæ¥é£çŠ¶æ€ï¼‰ï¼Œç»§ç»­æ¸¸æˆ
      let newLastPlay = prev.lastPlay;
      let newLastPlayPlayerIndex = prev.lastPlayPlayerIndex;
      let newRoundScore = prev.roundScore;

      const newState = {
        ...prev,
        players: newPlayers,
        currentPlayerIndex: nextPlayerIndex,
        lastPlay: newLastPlay,
        lastPlayPlayerIndex: newLastPlayPlayerIndex,
        roundScore: newRoundScore
      };

      // å¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œç­‰å¾…"è¦ä¸èµ·"è¯­éŸ³æ’­æ”¾å®Œæˆåå†ç»§ç»­
      // æŠ¥"è¦ä¸èµ·"ï¼ˆç³»ç»Ÿä¿¡æ¯ï¼‰ï¼šç«‹å³æŠ¥ç‰Œï¼Œä¸ç­‰å¾…å®Œæˆ
      // ä½¿ç”¨ä¹‹å‰å·²å£°æ˜çš„ currentPlayerVoiceï¼ˆå·²åœ¨çŠ¶æ€æ›´æ–°å‰æ’­æ”¾è¿‡ï¼Œè¿™é‡Œä¸å†é‡å¤æ’­æ”¾ï¼‰
      
      // 1.5ç§’åï¼Œå¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨ç»§ç»­
      if (prev.players[nextPlayerIndex].type === PlayerType.AI) {
          setTimeout(() => {
            if (schedulerRef.current) {
              schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
            }
        }, 1500);
      }

      return newState;
    });
  }, [playNextTurn]);

  // å¼‚æ­¥è¦ä¸èµ·å‡½æ•°
  const playerPassAsync = useCallback(async (playerIndex: number): Promise<void> => {
    const currentState = gameStateRef.current;
    const isHumanPlayer = currentState.players[playerIndex]?.isHuman || false;
    const playerName = currentState.players[playerIndex]?.name || 'æœªçŸ¥';
    
    // è·å–å½“å‰è½®æ¬¡å’Œç›¸å…³æ•°æ®
    const round = getCurrentRound(currentState);
    const currentRoundNumber = getCurrentRoundNumber(currentState);
    const lastPlay = getLastPlay(currentState);
    const lastPlayPlayerIndex = getLastPlayPlayerIndex(currentState);
    const currentRoundPlays = getCurrentRoundPlays(currentState);
    
    // çœŸå®ç©å®¶è¦ä¸èµ·æ—¶ï¼Œæ·»åŠ è¯¦ç»†æ—¥å¿—
    if (isHumanPlayer) {
      console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ·å¼€å§‹`, {
        playerIndex,
        playerName,
        roundNumber: currentRoundNumber,
        currentPlayerIndex: currentState.currentPlayerIndex,
        isCurrentPlayer: currentState.currentPlayerIndex === playerIndex,
        hasCurrentRound: !!round,
        lastPlay: lastPlay ? {
          type: lastPlay.type,
          value: lastPlay.value,
          cards: lastPlay.cards?.map((c: Card) => `${c.suit}-${c.rank}`)
        } : null,
        lastPlayPlayerIndex: lastPlayPlayerIndex,
        currentRoundPlaysCount: currentRoundPlays.length,
        timestamp: Date.now()
      });
    }
    
    if (!round) {
      // ä½¿ç”¨æ—§é€»è¾‘
      if (isHumanPlayer) {
        console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ· - ä½¿ç”¨æ—§é€»è¾‘ï¼ˆæ— Roundå¯¹è±¡ï¼‰`);
      }
      playerPass(playerIndex);
      return;
    }
    
    // æ£€æŸ¥è½®æ¬¡æ˜¯å¦å·²ç»“æŸ
    if (round.isEnded()) {
      if (isHumanPlayer) {
        console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ· - è½®æ¬¡å·²ç»“æŸï¼Œæ— æ³•å¤„ç†`);
      }
      return;
    }
    
    // å¼ºåˆ¶å‡ºç‰Œè§„åˆ™ï¼šå¦‚æœæœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¸èƒ½è¦ä¸èµ·
    const player = currentState.players[playerIndex];
    if (lastPlay && player) {
      const hasPlayable = hasPlayableCards(player.hand, lastPlay);
      if (hasPlayable) {
        if (isHumanPlayer) {
          console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ· - æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¸å…è®¸è¦ä¸èµ·`, {
            playerIndex,
            playerName,
            handCount: player.hand.length,
            lastPlay: {
              type: lastPlay.type,
              value: lastPlay.value
            }
          });
        }
        return; // ä¸å…è®¸è¦ä¸èµ·
      }
    }
    
    // è®°å½•è¦ä¸èµ·
    round.recordPass(playerIndex);
    
    // æ’­æ”¾"è¦ä¸èµ·"è¯­éŸ³ï¼ˆç­‰å¾…å®Œæˆï¼‰
    await announcePass(player?.voiceConfig);
    
    // ä½¿ç”¨ RoundScheduler å¤„ç†è°ƒåº¦é€»è¾‘ï¼ˆæ¥é£åˆ¤å®šã€è½®æ¬¡ç»“æŸã€ä¸‹ä¸€ä¸ªç©å®¶ï¼‰
    if (schedulerRef.current) {
      const scheduler = schedulerRef.current as any;
      if (scheduler.onPassCompleted) {
        // å®šä¹‰è½®æ¬¡ç»“æŸå›è°ƒï¼ˆä¸ playerPlayAsync ä¸­çš„é€»è¾‘ç›¸åŒï¼‰
        const handleRoundEnd = async (finalRound: Round, players: Player[], _nextPlayerIndex: number | null) => {
          const { updatedPlayers, nextPlayerIndex: newNext } = finalRound.end(
            players,
            currentState.playerCount
          );
          
          const roundRecord = finalRound.toRecord();
          
          if (cardTrackerEnabled) {
            try {
              ensureRoundInTracker(finalRound.roundNumber, roundRecord, updatedPlayers);
            } catch (error) {
              console.error(`[playerPassAsync] âœ— è®°ç‰Œå™¨è®°å½•å¤±è´¥`, {
                roundNumber: finalRound.roundNumber,
                error: error instanceof Error ? error.message : String(error),
                timestamp: Date.now()
              });
            }
          }
          
          const nextRound = Round.createNew(
            finalRound.roundNumber + 1, 
            Date.now(), 
            gameConfig.timingConfig
          );
          
          if (cardTrackerEnabled) {
            const newRoundNumber = finalRound.roundNumber + 1;
            try {
              cardTracker.startRound(newRoundNumber, updatedPlayers);
            } catch (error) {
              console.error(`[playerPassAsync] âœ— è®°ç‰Œå™¨å¼€å§‹æ–°è½®æ¬¡å¤±è´¥`, {
                roundNumber: newRoundNumber,
                error: error instanceof Error ? error.message : String(error),
                timestamp: Date.now()
              });
            }
          }
    
          setGameState(prev => {
            // å°†æ–°è½®æ¬¡æ·»åŠ åˆ° rounds æ•°ç»„
            const updatedRounds = [...prev.rounds, nextRound];
            const newRoundIndex = updatedRounds.length - 1;
            
            return {
              ...prev,
              players: updatedPlayers,
              rounds: updatedRounds,
              currentRoundIndex: newRoundIndex,
              currentPlayerIndex: newNext || prev.currentPlayerIndex
            };
          });
          
          if (schedulerRef.current) {
            schedulerRef.current.updateRoundNumber(finalRound.roundNumber + 1);
          }
        };
        
        await scheduler.onPassCompleted(
          playerIndex,
          round,
          currentState.players,
          currentState.playerCount,
          setGameState,
          handleRoundEnd
        );
      } else {
        console.error('[playerPassAsync] âš ï¸ RoundScheduler.onPassCompleted æ–¹æ³•ä¸å­˜åœ¨');
      }
    } else {
      console.error('[playerPassAsync] âš ï¸ RoundScheduler æœªåˆå§‹åŒ–');
    }
  }, [playerPass, isAutoPlayRef]);

  // ç›‘å¬æ¸¸æˆçŠ¶æ€å˜åŒ–ï¼Œåœ¨æ‰˜ç®¡æ¨¡å¼ä¸‹è‡ªåŠ¨å‡ºç‰Œ
  useEffect(() => {
    if (gameState.status !== GameStatus.PLAYING) return;
    if (!isAutoPlay) return;
    if (gameState.players.length === 0) return;
    
    // ä½¿ç”¨ gameStateRef è·å–æœ€æ–°çŠ¶æ€ï¼Œé¿å…é—­åŒ…é—®é¢˜
    const currentState = gameStateRef.current;
    const currentPlayer = currentState.players[currentState.currentPlayerIndex];
    if (!currentPlayer) return;
    
    // å¦‚æœæ˜¯äººç±»ç©å®¶ä¸”å¼€å¯äº†æ‰˜ç®¡ï¼Œè‡ªåŠ¨è§¦å‘å‡ºç‰Œ
    if (currentPlayer.isHuman) {
      console.log('[AutoPlay] ğŸ¤– æ£€æµ‹åˆ°è½®åˆ°äººç±»ç©å®¶ï¼Œæ‰˜ç®¡æ¨¡å¼è‡ªåŠ¨å‡ºç‰Œ', {
        currentPlayerIndex: currentState.currentPlayerIndex,
        playerName: currentPlayer.name,
        handCount: currentPlayer.hand.length,
        lastPlay: getLastPlay(currentState),
        isAutoPlay
      });
      // å»¶è¿Ÿä¸€ç‚¹ï¼Œç¡®ä¿çŠ¶æ€å·²æ›´æ–°
      const timer = setTimeout(() => {
        if (schedulerRef.current) {
          schedulerRef.current.scheduleNextTurn(gameState.currentPlayerIndex, 0);
        }
      }, 500);
      
      return () => clearTimeout(timer);
    }
  }, [gameState.currentPlayerIndex, gameState.status, isAutoPlay]);

  // ä½¿ç”¨OpenAIè¾…åŠ©ç©å®¶å‡ºç‰Œ
  // å»ºè®®å‡ºç‰Œï¼ˆä½¿ç”¨å®Œå…¨ä¿¡æ¯æ¨¡å¼ï¼‰
  const suggestPlay = useCallback(async (
    playerIndex: number,
    aiConfig: AIConfig
  ): Promise<Card[] | null> => {
    const currentState = gameStateRef.current;
    const player = currentState.players[playerIndex];
    if (!player) return null;

    try {
      // å‡†å¤‡å®Œå…¨ä¿¡æ¯æ¨¡å¼çš„é…ç½®
      const aiConfigWithContext = {
        ...aiConfig,
        perfectInformation: true, // å¯ç”¨å®Œå…¨ä¿¡æ¯æ¨¡å¼ï¼ˆ"ä½œå¼Š"æ¨¡å¼ï¼‰
        allPlayerHands: currentState.players.map(p => [...p.hand]), // æ‰€æœ‰ç©å®¶çš„æ‰‹ç‰Œ
        currentRoundScore: getCurrentRoundScore(currentState) || 0, // å½“å‰è½®æ¬¡ç´¯è®¡åˆ†æ•°
        playerCount: currentState.playerCount // ç©å®¶æ€»æ•°
      };
      
      const suggestedCards = await aiChoosePlay(
        player.hand,
        getLastPlay(currentState),
        aiConfigWithContext
      );
      return suggestedCards;
    } catch (error) {
      console.error('AIå»ºè®®å¤±è´¥:', error);
      return null;
    }
  }, []);

  // é‡ç½®æ¸¸æˆ
  const resetGame = useCallback(() => {
    setGameState({
      status: GameStatus.WAITING,
      players: [],
      currentPlayerIndex: 0,
      lastPlay: null,
      lastPlayPlayerIndex: null,
      winner: null,
      playerCount: 0,
      roundScore: 0,
      currentRoundPlays: [],
      roundNumber: 1,
      finishOrder: []
    });
  }, []);

  // åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€
  const toggleAutoPlay = useCallback(() => {
    setIsAutoPlay(prev => {
      const newValue = !prev;
      console.log('[AutoPlay] ğŸ”„ åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€:', newValue ? 'å¼€å¯' : 'å…³é—­');
      
      // å¦‚æœå¼€å¯æ‰˜ç®¡ï¼Œä¸”å½“å‰è½®åˆ°äººç±»ç©å®¶ï¼Œç«‹å³è§¦å‘ä¸€æ¬¡
      if (newValue) {
        // ä½¿ç”¨ gameStateRef è·å–æœ€æ–°çŠ¶æ€ï¼Œé¿å…é—­åŒ…é—®é¢˜
        const currentState = gameStateRef.current;
        if (currentState.status === GameStatus.PLAYING) {
          const currentPlayer = currentState.players[currentState.currentPlayerIndex];
          if (currentPlayer && currentPlayer.isHuman) {
            console.log('[AutoPlay] ğŸš€ å¼€å¯æ‰˜ç®¡æ—¶ï¼Œå½“å‰è½®åˆ°äººç±»ç©å®¶ï¼Œç«‹å³è§¦å‘', {
              playerIndex: currentState.currentPlayerIndex,
              playerName: currentPlayer.name,
              handCount: currentPlayer.hand.length
            });
            // å»¶è¿Ÿè§¦å‘ï¼Œç¡®ä¿çŠ¶æ€å·²æ›´æ–°
            setTimeout(() => {
              if (schedulerRef.current) {
                schedulerRef.current.scheduleNextTurn(undefined, 0);
              }
            }, 500);
          }
        }
      }
      
      return newValue;
    });
  }, [playNextTurn]);

  return {
    gameState,
    startGame,
    playerPlay,  // ä¿ç•™æ—§çš„åŒæ­¥å‡½æ•°ï¼ˆå‘åå…¼å®¹ï¼‰
    playerPlayAsync,  // æ–°å¢å¼‚æ­¥å‡½æ•°
    playerPass,
    playerPassAsync,  // æ–°å¢å¼‚æ­¥è¦ä¸èµ·å‡½æ•°
    suggestPlay,
    resetGame,
    isDealing,
    pendingGameConfig,
    handleDealingComplete,
    handleDealingCancel,
    isAutoPlay,
    toggleAutoPlay
  };
}

