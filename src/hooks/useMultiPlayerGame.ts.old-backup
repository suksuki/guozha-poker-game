/**
 * å¤šäººæ¸¸æˆä¸» Hookï¼ˆé‡æ„ç‰ˆï¼‰
 * ä½¿ç”¨ rounds æ•°ç»„æ¶æ„ï¼Œç»Ÿä¸€ä½¿ç”¨ RoundScheduler è¿›è¡Œè°ƒåº¦
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { Card, GameStatus, Player, PlayerType, RoundRecord } from '../types/card';
import { dealCards, hasPlayableCards } from '../utils/cardUtils';
import { aiChoosePlay, AIConfig } from '../utils/aiPlayer';
import { voiceService } from '../services/voiceService';
import { generateRandomVoiceConfig } from '../services/voiceConfigService';
import { triggerFinishLastReaction, clearChatMessages } from '../services/chatService';
import { findNextActivePlayer, checkGameFinished, MultiPlayerGameState } from '../utils/gameStateUtils';
import { getGameConfig } from '../config/gameConfig';
import { Round } from '../utils/Round';
import { processPlayAsync } from '../utils/asyncPlayHandler';
import { RoundScheduler } from '../utils/roundScheduler';
import { getCurrentRound, getCurrentRoundNumber, getCurrentRoundScore, getLastPlay } from '../utils/gameStateUtils';
import { GameController } from '../utils/gameController';
import { useValidationModule } from './useValidationModule';
import { useTrackingModule } from './useTrackingModule';
import { useAudioModule } from './useAudioModule';

// æ¸¸æˆå®Œæ•´è®°å½•ï¼ˆç”¨äºä¿å­˜ï¼‰
export interface GameRecord {
  gameId: string;
  startTime: number;
  endTime?: number;
  playerCount: number;
  initialHands: Card[][];
  allRounds: RoundRecord[];
  finishOrder: number[];
  finalRankings?: any[];
  winner: number;
}

export interface GameConfig {
  playerCount: number;
  humanPlayerIndex: number;
  aiConfigs: { 
    apiKey?: string;
    strategy?: 'aggressive' | 'conservative' | 'balanced';
    algorithm?: 'simple' | 'mcts';
    mctsIterations?: number;
  }[];
  dealingAlgorithm?: 'random' | 'fair' | 'favor-human' | 'favor-ai' | 'balanced-score' | 'clustered';
  skipDealingAnimation?: boolean;
  dealingSpeed?: number;
  sortOrder?: 'asc' | 'desc' | 'grouped';
  cardTrackerEnabled?: boolean;
}

export function useMultiPlayerGame() {
  const gameConfig = getGameConfig();
  
  // ä½¿ç”¨ç³»ç»Ÿåº”ç”¨æ¨¡å—
  const { validateRoundEnd } = useValidationModule();
  const { initializeTracker, startRound: startTrackingRound, recordPlay: recordTrackingPlay, endRound: endTrackingRound } = useTrackingModule();
  const { announcePlay: announcePlayAudio, announcePass: announcePassAudio } = useAudioModule();
  
  // ä» localStorage è¯»å–è®¡åˆ†å™¨å¼€å…³é…ç½®ï¼ˆé»˜è®¤å…³é—­ï¼‰
  const cardTrackerEnabled = (() => {
    const saved = localStorage.getItem('cardTrackerEnabled');
    return saved !== null ? saved === 'true' : false;
  })();

  const [gameState, setGameState] = useState<MultiPlayerGameState>({
    status: GameStatus.WAITING,
    players: [],
    currentPlayerIndex: 0,
    winner: null,
    playerCount: 0,
    finishOrder: [],
    rounds: [],
    currentRoundIndex: -1
  });

  const gameStateRef = useRef(gameState);
  useEffect(() => {
    gameStateRef.current = gameState;
  }, [gameState]);

  // å‘ç‰ŒçŠ¶æ€
  const [isDealing, setIsDealing] = useState(false);
  const [pendingGameConfig, setPendingGameConfig] = useState<GameConfig | null>(null);
  
  // æ‰˜ç®¡çŠ¶æ€
  const [isAutoPlay, setIsAutoPlay] = useState(false);
  const isAutoPlayRef = useRef(false);
  
  useEffect(() => {
    isAutoPlayRef.current = isAutoPlay;
  }, [isAutoPlay]);

  // é˜²é‡å¤è°ƒç”¨æ ‡å¿—
  const isProcessingPlayRef = useRef<Map<number, number>>(new Map()); // playerIndex -> timestamp
  const isProcessingPassRef = useRef<Map<number, number>>(new Map()); // playerIndex -> timestamp

  // åˆ›å»ºè½®æ¬¡è°ƒåº¦å™¨
  const schedulerRef = useRef<RoundScheduler | null>(null);
  
  // åˆ›å»ºæ¸¸æˆæ§åˆ¶å™¨ï¼ˆç»Ÿä¸€ç®¡ç†è®¡åˆ†å’Œæ’åï¼‰
  const gameControllerRef = useRef<GameController | null>(null);
  
  // è·å–äººç±»ç©å®¶ç´¢å¼•
  const humanPlayerIndex = gameState.players.findIndex(p => p.isHuman);
  
  // åˆå§‹åŒ–æ¸¸æˆæ§åˆ¶å™¨å¹¶è®¢é˜…å›è°ƒ
  useEffect(() => {
    if (!gameControllerRef.current) {
      gameControllerRef.current = new GameController();
      
      // è®¢é˜…å›è°ƒ
      gameControllerRef.current.subscribe({
        onScoreChange: (playerIndex, newScore, _reason) => {
          setGameState(prev => ({
            ...prev,
            players: prev.players.map((p, i) => 
              i === playerIndex ? { ...p, score: newScore } : p
            )
          }));
        },
        onPlayerFinished: (playerIndex, finishOrder, finishedRank) => {
          // âœ… è¿™æ˜¯å”¯ä¸€æ›´æ–°äº‰ä¸Šæ¸¸åæ¬¡ï¼ˆfinishedRankï¼‰çš„åœ°æ–¹ï¼ˆé€šè¿‡ GameController å›è°ƒï¼‰
          // finishedRankï¼šå‡ºå®Œç‰Œçš„é¡ºåºï¼ˆç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰ï¼Œç«‹å³æ˜¾ç¤º
          // scoreRankï¼šåˆ†æ•°åæ¬¡ï¼Œåœ¨æ¸¸æˆç»“æŸæ—¶ç»Ÿä¸€è®¡ç®—
          console.log(`[useMultiPlayerGame] âœ… onPlayerFinished å›è°ƒè¢«è§¦å‘ - æ›´æ–°äº‰ä¸Šæ¸¸åæ¬¡`, {
            playerIndex,
            finishedRank, // äº‰ä¸Šæ¸¸åæ¬¡ï¼ˆå‡ºå®Œç‰Œçš„é¡ºåºï¼‰
            finishOrder,
            note: 'è¿™æ˜¯å”¯ä¸€æ›´æ–° React çŠ¶æ€ä¸­ finishedRankï¼ˆäº‰ä¸Šæ¸¸åæ¬¡ï¼‰çš„åœ°æ–¹ï¼ŒscoreRankï¼ˆåˆ†æ•°åæ¬¡ï¼‰åœ¨æ¸¸æˆç»“æŸæ—¶è®¾ç½®'
          });
          
          // ä½¿ç”¨å‡½æ•°å¼æ›´æ–°ï¼Œç¡®ä¿ä¸ä¼šè¦†ç›–å…¶ä»–æ­£åœ¨è¿›è¡Œçš„æ›´æ–°
          setGameState(prev => {
            // æ£€æŸ¥ç©å®¶æ˜¯å¦å·²ç»å­˜åœ¨ï¼ˆé˜²å¾¡æ€§æ£€æŸ¥ï¼‰
            if (playerIndex < 0 || playerIndex >= prev.players.length) {
              console.warn(`[useMultiPlayerGame] âš ï¸ ç©å®¶ç´¢å¼• ${playerIndex} æ— æ•ˆï¼Œè·³è¿‡æ›´æ–°`, {
                playerIndex,
                playersLength: prev.players.length
              });
              return prev;
            }
            
            const updatedPlayers = prev.players.map((p, i) => {
              if (i === playerIndex) {
                const updatedPlayer = { ...p, finishedRank }; // äº‰ä¸Šæ¸¸åæ¬¡
                console.log(`[useMultiPlayerGame] âœ… æ›´æ–°ç©å®¶ ${i} çš„äº‰ä¸Šæ¸¸åæ¬¡: ${p.finishedRank ?? 'null'} -> ${finishedRank}`, {
                  playerIndex: i,
                  playerName: p.name,
                  oldFinishedRank: p.finishedRank,
                  newFinishedRank: finishedRank,
                  handCount: p.hand.length,
                  note: 'finishedRank æ˜¯äº‰ä¸Šæ¸¸åæ¬¡ï¼ˆå‡ºå®Œç‰Œçš„é¡ºåºï¼‰ï¼ŒscoreRank æ˜¯åˆ†æ•°åæ¬¡ï¼ˆæ¸¸æˆç»“æŸæ—¶è®¡ç®—ï¼‰'
                });
                return updatedPlayer;
              }
              return p;
            });
            
            return {
              ...prev,
              finishOrder,
              players: updatedPlayers
            };
          });
        },
        onRoundScoreAllocated: (roundNumber, winnerIndex, roundScore) => {
          console.log(`[GameController] è½®æ¬¡${roundNumber}åˆ†æ•°å·²åˆ†é…`, {
            roundNumber,
            winnerIndex,
            roundScore
          });
        },
        onGameEnd: (finalRankings) => {
          console.log(`[GameController] æ¸¸æˆç»“æŸï¼Œæœ€ç»ˆæ’å`, {
            rankings: finalRankings.map(r => ({
              rank: r.rank, // åˆ†æ•°æ’åï¼ˆscoreRankï¼‰
              playerId: r.player.id,
              playerName: r.player.name,
              finalScore: r.finalScore,
              finishedRank: r.player.finishedRank, // äº‰ä¸Šæ¸¸åæ¬¡
              scoreRank: r.player.scoreRank // åˆ†æ•°åæ¬¡
            }))
          });
          
          // æ›´æ–°æ¸¸æˆçŠ¶æ€ï¼Œè®¾ç½® finalRankings å’Œç©å®¶çš„ scoreRank
          setGameState(prev => {
            // ä» finalRankings ä¸­æå–ç©å®¶å¹¶æ›´æ–° scoreRank
            const updatedPlayers = prev.players.map(player => {
              const ranking = finalRankings.find(r => r.player.id === player.id);
              if (ranking) {
                return {
                  ...player,
                  scoreRank: ranking.rank, // åˆ†æ•°åæ¬¡ï¼ˆæŒ‰æœ€ç»ˆåˆ†æ•°æ’åºï¼‰
                  score: ranking.finalScore // æœ€ç»ˆåˆ†æ•°
                };
              }
              return player;
            });
            
            return {
              ...prev,
              players: updatedPlayers,
              finalRankings: finalRankings // ä¿å­˜æœ€ç»ˆæ’åç”¨äºæ˜¾ç¤º
            };
          });
        }
      });
    }
    
    // åŒæ­¥ GameController çš„çŠ¶æ€ï¼ˆplayers å’Œ finishOrderï¼‰
    if (gameControllerRef.current && gameState.status === GameStatus.PLAYING) {
      gameControllerRef.current.updatePlayers(gameState.players);
      gameControllerRef.current.updateFinishOrder(gameState.finishOrder || []);
    }
  }, [gameState.status, gameState.players, gameState.finishOrder]);
  
  // åˆå§‹åŒ–è°ƒåº¦å™¨
  useEffect(() => {
    if (!schedulerRef.current) {
      schedulerRef.current = new RoundScheduler({
        isAutoPlay: isAutoPlay,
        humanPlayerIndex: humanPlayerIndex >= 0 ? humanPlayerIndex : 0,
        getGameState: () => {
          const state = gameStateRef.current;
          const currentRound = getCurrentRound(state);
          return {
            status: state.status,
            currentPlayerIndex: state.currentPlayerIndex,
            rounds: state.rounds,
            currentRoundIndex: state.currentRoundIndex,
            players: state.players,
            roundNumber: currentRound ? currentRound.roundNumber : 0,
            currentRound: currentRound
          };
        }
      });
    } else {
      schedulerRef.current.updateConfig({
        isAutoPlay: isAutoPlay,
        humanPlayerIndex: humanPlayerIndex >= 0 ? humanPlayerIndex : 0
      });
    }
    
    if (schedulerRef.current && gameState.status === GameStatus.PLAYING) {
      const currentRoundNumber = getCurrentRoundNumber(gameState);
      schedulerRef.current.updateRoundNumber(currentRoundNumber);
    }
  }, [isAutoPlay, humanPlayerIndex, gameState.status]);

  // ========== æ ¸å¿ƒå‡½æ•°ï¼šAIè‡ªåŠ¨å‡ºç‰Œ ==========
  
  const playNextTurnInternal = useCallback(async (targetPlayerIndex?: number) => {
    const currentState = gameStateRef.current;
    
    if (currentState.status !== GameStatus.PLAYING) {
      return;
    }

    // ç­‰å¾…æ­£åœ¨å¤„ç†çš„å‡ºç‰Œå®Œæˆ
    const currentRound = getCurrentRound(currentState);
    if (currentRound?.hasProcessingPlay()) {
      try {
        await currentRound.waitForPlayProcess(15000);
      } catch (error) {
        // è¶…æ—¶æˆ–é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œ
      }
    }

    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ’­æ”¾è¯­éŸ³
    if (voiceService.isCurrentlySpeaking()) {
      const initialState = gameStateRef.current;
      const initialPlayerIndex = initialState.currentPlayerIndex;
      
      await new Promise<void>((resolve) => {
        const checkInterval = setInterval(() => {
          const currentState = gameStateRef.current;
          const stateChanged = currentState.currentPlayerIndex !== initialPlayerIndex;
          
          if (!voiceService.isCurrentlySpeaking() || stateChanged) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 50);
        
        setTimeout(() => {
          clearInterval(checkInterval);
          resolve();
        }, 1000);
      });
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // ç­‰å¾…æœ€çŸ­é—´éš”
    if (currentRound) {
      await currentRound.waitForMinInterval();
    }

    const playerIndex = targetPlayerIndex !== undefined ? targetPlayerIndex : currentState.currentPlayerIndex;
    const currentPlayer = currentState.players[playerIndex];
    if (!currentPlayer) return;
    
    // å¦‚æœæŒ‡å®šäº†ç›®æ ‡ç©å®¶ç´¢å¼•ä¸”ä¸å½“å‰ç©å®¶ç´¢å¼•ä¸åŒï¼Œæ›´æ–°çŠ¶æ€
    if (targetPlayerIndex !== undefined && targetPlayerIndex !== currentState.currentPlayerIndex) {
      setGameState(prev => ({
        ...prev,
        currentPlayerIndex: targetPlayerIndex
      }));
      await new Promise(resolve => setTimeout(resolve, 50));
      const updatedState = gameStateRef.current;
      if (updatedState.currentPlayerIndex !== targetPlayerIndex) {
        console.warn('[playNextTurnInternal] çŠ¶æ€æ›´æ–°å¤±è´¥ï¼Œä½¿ç”¨å½“å‰ç©å®¶ç´¢å¼•', {
          targetPlayerIndex,
          actualPlayerIndex: updatedState.currentPlayerIndex,
          timestamp: Date.now()
        });
        return;
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦åªå‰©ä¸€ä¸ªç©å®¶è¿˜æ²¡å‡ºå®Œ
    // æ–°æ¶æ„ä¸‹ï¼Œä¸å†ç›´æ¥è°ƒç”¨ handleGameEndï¼Œè€Œæ˜¯ç»Ÿä¸€äº¤ç»™ GameController + checkGameFinished å¤„ç†
    const remainingPlayers = currentState.players.filter(p => p.hand.length > 0);
    if (remainingPlayers.length === 1) {
      const lastPlayerIndex = remainingPlayers[0].id;
      const lastPlayer = currentState.players[lastPlayerIndex];
      
      // ä»ç„¶è§¦å‘æœ€åä¸€åçš„èŠå¤©ååº”ï¼ˆUI/æƒ…ç»ªåé¦ˆï¼‰
      triggerFinishLastReaction(lastPlayer, undefined, currentState).catch(console.error);
      
      // äº¤ç»™åç»­è½®æ¬¡ç»“æŸ / checkGameFinished æµç¨‹ç»Ÿä¸€ç»“æŸæ¸¸æˆ
      // è¿™é‡Œä¸å†ç›´æ¥ç»“æŸï¼Œä»¥é¿å…ä¸ GameController ç®¡çº¿äº§ç”Ÿå†²çª
      console.log('[playNextTurnInternal] åªå‰©ä¸€ä¸ªç©å®¶ï¼Œå·²è§¦å‘èŠå¤©åé¦ˆï¼Œç­‰å¾…è½®æ¬¡ç»“æŸé€»è¾‘ç»Ÿä¸€ç»“æŸæ¸¸æˆ', {
        lastPlayerIndex,
        lastPlayerName: lastPlayer?.name,
        note: 'ä¸å†ç›´æ¥è°ƒç”¨ handleGameEndï¼Œç”± GameController + checkGameFinished è´Ÿè´£ç»ˆå±€'
      });
      // ä¸ returnï¼Œå…è®¸åç»­é€»è¾‘ç»§ç»­ï¼ˆä¾‹å¦‚è·³è¿‡å·²å‡ºå®Œç©å®¶ã€ç”±è°ƒåº¦å™¨æ¨è¿›ï¼‰
    }
    
    // å¦‚æœå½“å‰ç©å®¶å·²ç»å‡ºå®Œç‰Œäº†ï¼Œè·³è¿‡åˆ°ä¸‹ä¸€ä¸ªç©å®¶
    if (currentPlayer.hand.length === 0) {
      const nextPlayerIndex = findNextActivePlayer(playerIndex, currentState.players, currentState.playerCount);
      
      if (nextPlayerIndex === null) {
        // æ‰€æœ‰ç©å®¶éƒ½å‡ºå®Œäº†ï¼Œç»“æŸæ¸¸æˆ
        // ä½¿ç”¨ checkGameFinished ç»Ÿä¸€å¤„ç†ï¼Œå®ƒä¼šé€šè¿‡ GameController å®Œæˆæœ€ç»ˆè®¡åˆ†
        const finishOrder = gameControllerRef.current?.getFinishOrder() || currentState.finishOrder || [];
        const gameFinishedResult = checkGameFinished(
          currentState,
          currentState.players,
          finishOrder
        );
        
        if (gameFinishedResult) {
          // ä½¿ç”¨ GameController è®¡ç®—æœ€ç»ˆåˆ†æ•°å’Œæ’å
          if (gameControllerRef.current) {
            const { updatedPlayers: finalPlayers, finalRankings } = 
              gameControllerRef.current.calculateFinalScoresAndRankings(currentState.players);
            
            setGameState({
              ...gameFinishedResult,
              players: finalPlayers,
              finalRankings
            });
          } else {
            setGameState(gameFinishedResult);
          }
        }
        return;
      }
      
      setGameState(prev => {
        const currentRound = getCurrentRound(prev);
        
        return {
          ...prev,
          currentPlayerIndex: nextPlayerIndex,
          rounds: prev.rounds.map((r, i) => i === prev.currentRoundIndex ? (currentRound || r) : r)
        };
      });
      
      // å¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
      const nextPlayer = currentState.players[nextPlayerIndex];
      if (nextPlayer && nextPlayer.type === PlayerType.AI) {
        setTimeout(() => {
          if (schedulerRef.current) {
            schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
          }
        }, 100);
      }
      return;
    }

    // å¦‚æœå½“å‰ç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
    if (currentPlayer.type === PlayerType.AI) {
      const lastPlay = getLastPlay(currentState);
      const aiConfig = currentPlayer.aiConfig || { strategy: 'balanced' as const, algorithm: 'mcts' as const };
      
      try {
        const selectedCards = await aiChoosePlay(
          currentPlayer.hand,
          lastPlay,
          aiConfig
        );
        
        if (selectedCards && selectedCards.length > 0) {
          await playerPlayAsync(playerIndex, selectedCards);
        } else {
          // AIè¦ä¸èµ·
          await playerPassAsync(playerIndex);
        }
      } catch (error) {
        console.error('[playNextTurnInternal] AIå‡ºç‰Œå¤±è´¥:', error);
        // å‡ºé”™æ—¶ï¼Œè‡ªåŠ¨è¦ä¸èµ·
        await playerPassAsync(playerIndex);
      }
    } else if (currentPlayer.isHuman && isAutoPlayRef.current) {
      // æ‰˜ç®¡æ¨¡å¼ä¸‹çš„çœŸå®ç©å®¶ï¼Œä¹Ÿè‡ªåŠ¨å‡ºç‰Œ
      const lastPlay = getLastPlay(currentState);
      const aiConfig: AIConfig = { strategy: 'balanced' as const, algorithm: 'mcts' as const };
      
      try {
        const selectedCards = await aiChoosePlay(
          currentPlayer.hand,
          lastPlay,
          aiConfig
        );
        
        if (selectedCards && selectedCards.length > 0) {
          await playerPlayAsync(playerIndex, selectedCards);
        } else {
          await playerPassAsync(playerIndex);
        }
      } catch (error) {
        console.error('[playNextTurnInternal] æ‰˜ç®¡å‡ºç‰Œå¤±è´¥:', error);
        await playerPassAsync(playerIndex);
      }
    } else if (currentPlayer.isHuman && !isAutoPlayRef.current) {
      // æ‰‹åŠ¨ç©å®¶ï¼ˆéæ‰˜ç®¡ï¼‰ï¼šå¯åŠ¨è¶…æ—¶æœºåˆ¶
      const lastPlay = getLastPlay(currentState);
      // ä½¿ç”¨æœ€æ–°çš„é…ç½®
      const latestGameConfig = getGameConfig();
      const timeout = latestGameConfig.timingConfig?.playTimeout || 30000; // é»˜è®¤30ç§’
      const currentRound = getCurrentRound(currentState);
      const initialPlaysCount = currentRound?.getPlayCount() || 0;
      const initialCurrentPlayerIndex = currentState.currentPlayerIndex;
      
      console.warn(`[playNextTurnInternal] â†’ ç­‰å¾…æ‰‹åŠ¨ç©å®¶${playerIndex}æ“ä½œï¼Œè¶…æ—¶æ—¶é—´ï¼š${timeout}ms`, {
        playerIndex,
        playerName: currentPlayer.name,
        handCount: currentPlayer.hand.length,
        lastPlay,
        timeout,
        initialPlaysCount,
        timestamp: Date.now()
      });
      
      // åˆ›å»ºä¸€ä¸ª Promiseï¼Œç­‰å¾…ç©å®¶æ“ä½œæˆ–è¶…æ—¶
      let timeoutId: NodeJS.Timeout | null = null;
      let isResolved = false;
      
      const timeoutPromise = new Promise<void>((resolve) => {
        timeoutId = setTimeout(async () => {
          if (!isResolved) {
            isResolved = true;
            
            // æ£€æŸ¥ç©å®¶æ˜¯å¦å·²ç»æ“ä½œï¼ˆé€šè¿‡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼‰
            const latestState = gameStateRef.current;
            const latestRound = getCurrentRound(latestState);
            const latestPlaysCount = latestRound?.getPlayCount() || 0;
            const latestCurrentPlayerIndex = latestState.currentPlayerIndex;
            
            // å¦‚æœå‡ºç‰Œè®°å½•å¢åŠ äº†ï¼Œæˆ–è€…å½“å‰ç©å®¶ç´¢å¼•æ”¹å˜äº†ï¼Œè¯´æ˜ç©å®¶å·²ç»æ“ä½œäº†
            const playerHasActed = latestPlaysCount > initialPlaysCount || 
                                   latestCurrentPlayerIndex !== initialCurrentPlayerIndex ||
                                   latestCurrentPlayerIndex !== playerIndex;
            
            if (playerHasActed) {
              console.warn(`[playNextTurnInternal] â†’ æ‰‹åŠ¨ç©å®¶${playerIndex}å·²åœ¨è¶…æ—¶å‰æ“ä½œï¼Œè·³è¿‡è‡ªåŠ¨å¤„ç†`, {
                playerIndex,
                initialPlaysCount,
                latestPlaysCount,
                initialCurrentPlayerIndex,
                latestCurrentPlayerIndex,
                timestamp: Date.now()
              });
              resolve();
              return;
            }
            
            console.warn(`[playNextTurnInternal] âš ï¸ æ‰‹åŠ¨ç©å®¶${playerIndex}æ“ä½œè¶…æ—¶ï¼Œè‡ªåŠ¨å¤„ç†`, {
              playerIndex,
              playerName: currentPlayer.name,
              handCount: currentPlayer.hand.length,
              lastPlay,
              timeout,
              timestamp: Date.now()
            });
            
            // è·å–æœ€æ–°çš„ç©å®¶æ‰‹ç‰Œï¼ˆå¯èƒ½å·²ç»æ”¹å˜ï¼‰
            const latestPlayer = latestState.players[playerIndex];
            if (!latestPlayer || latestPlayer.hand.length === 0) {
              // ç©å®¶å·²ç»å‡ºå®Œç‰Œäº†ï¼Œä¸éœ€è¦å¤„ç†
              console.warn(`[playNextTurnInternal] â†’ ç©å®¶${playerIndex}å·²å‡ºå®Œç‰Œï¼Œè·³è¿‡è‡ªåŠ¨å¤„ç†`);
              resolve();
              return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰èƒ½æ‰“è¿‡çš„ç‰Œ
            const hasPlayable = lastPlay ? hasPlayableCards(latestPlayer.hand, lastPlay) : true;
            
            if (hasPlayable) {
              // æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä½¿ç”¨AIå‡ºç‰Œ
              const aiConfig: AIConfig = { strategy: 'balanced' as const, algorithm: 'mcts' as const };
              try {
                const selectedCards = await aiChoosePlay(latestPlayer.hand, lastPlay, aiConfig);
                if (selectedCards && selectedCards.length > 0) {
                  await playerPlayAsync(playerIndex, selectedCards);
                } else {
                  await playerPassAsync(playerIndex);
                }
              } catch (error) {
                console.error('[playNextTurnInternal] è¶…æ—¶åAIå‡ºç‰Œå¤±è´¥:', error);
                await playerPassAsync(playerIndex);
              }
            } else {
              // æ²¡æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œè‡ªåŠ¨è¦ä¸èµ·
              await playerPassAsync(playerIndex);
            }
            
            resolve();
          }
        }, timeout);
      });
      
      // ç­‰å¾…è¶…æ—¶ï¼ˆç©å®¶æ“ä½œä¼šé€šè¿‡ playerPlayAsync æˆ– playerPassAsync å¤„ç†ï¼Œè¿™é‡Œåªç­‰å¾…è¶…æ—¶ï¼‰
      await timeoutPromise;
      
      // æ¸…ç†å®šæ—¶å™¨ï¼ˆå¦‚æœè¿˜æ²¡è§¦å‘ï¼‰
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }
  }, []);

  // è®¾ç½®è°ƒåº¦å™¨çš„å›è°ƒ
  useEffect(() => {
    if (schedulerRef.current) {
      schedulerRef.current.onNextTurnCallback = playNextTurnInternal;
    }
  }, [playNextTurnInternal]);


  // ========== å¼€å§‹æ¸¸æˆ ==========
  
  const startGameInternal = useCallback((config: GameConfig, hands: Card[][]) => {
    clearChatMessages();

    const players: Player[] = hands.map((hand, index) => ({
      id: index,
      name: index === config.humanPlayerIndex ? 'ä½ ' : `ç©å®¶${index + 1}`,
      type: index === config.humanPlayerIndex ? PlayerType.HUMAN : PlayerType.AI,
      hand: hand,
      score: -100,
      isHuman: index === config.humanPlayerIndex,
      aiConfig: index === config.humanPlayerIndex ? undefined : {
        apiKey: '',
        strategy: config.aiConfigs[index]?.strategy || 'balanced',
        algorithm: config.aiConfigs[index]?.algorithm || 'mcts',
        mctsIterations: config.aiConfigs[index]?.mctsIterations || 100
      },
      voiceConfig: generateRandomVoiceConfig(index)
    }));

    const firstPlayer = Math.floor(Math.random() * config.playerCount);

    // åˆå§‹åŒ–è¿½è¸ªæ¨¡å—å¹¶åˆ›å»ºç¬¬1è½®ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (cardTrackerEnabled) {
      try {
        initializeTracker(hands, Date.now());
        startTrackingRound(1, players);
      } catch (error) {
        console.error(`[startGameInternal] âœ— è¿½è¸ªæ¨¡å—åˆå§‹åŒ–å¤±è´¥`, error);
      }
    }

    // åˆå§‹åŒ–æ¸¸æˆæ§åˆ¶å™¨
    if (gameControllerRef.current) {
      gameControllerRef.current.initializeGame(players, -100);
    }
    
    // åˆ›å»ºç¬¬ä¸€è½®ï¼ˆä½¿ç”¨æœ€æ–°çš„é…ç½®ï¼‰
    const latestGameConfig = getGameConfig();
    const firstRound = Round.createNew(1, Date.now(), latestGameConfig.timingConfig);
    
    setGameState({
      status: GameStatus.PLAYING,
      players,
      currentPlayerIndex: firstPlayer,
      winner: null,
      playerCount: config.playerCount,
      finishOrder: [],
      initialHands: hands.map(hand => [...hand]),
      rounds: [firstRound],
      currentRoundIndex: 0,
      gameRecord: {
        gameId: `game-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        startTime: Date.now(),
        playerCount: config.playerCount,
        initialHands: hands.map(hand => [...hand]),
        allRounds: [],
        finishOrder: [],
        finalRankings: [],
        winner: -1
      }
    });

    // å¦‚æœç¬¬ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
    if (firstPlayer !== config.humanPlayerIndex) {
      setTimeout(() => {
        if (schedulerRef.current) {
          schedulerRef.current.scheduleNextTurn(firstPlayer, 0);
        }
      }, 1000);
    }
  }, []);

  const startGame = useCallback((startConfig: GameConfig) => {
    const config: GameConfig = {
      ...startConfig,
      humanPlayerIndex: startConfig.humanPlayerIndex ?? 0
    };

    if (config.skipDealingAnimation) {
      const hands = dealCards(config.playerCount);
      startGameInternal(config, hands);
    } else {
      setPendingGameConfig(config);
      setIsDealing(true);
    }
  }, [startGameInternal]);

  const handleDealingComplete = useCallback((hands: Card[][]) => {
    if (pendingGameConfig) {
      startGameInternal(pendingGameConfig, hands);
      setPendingGameConfig(null);
    }
    setIsDealing(false);
  }, [pendingGameConfig, startGameInternal]);

  const handleDealingCancel = useCallback(() => {
    setPendingGameConfig(null);
    setIsDealing(false);
  }, []);

  // ========== ç©å®¶å‡ºç‰Œ ==========
  
  const playerPlay = useCallback((playerIndex: number, selectedCards: Card[]): boolean => {
    playerPlayAsync(playerIndex, selectedCards).catch(console.error);
    return true;
  }, []);

  const playerPlayAsync = useCallback(async (
    playerIndex: number,
    selectedCards: Card[]
  ): Promise<boolean> => {
    const currentState = gameStateRef.current;
    const isHumanPlayer = currentState.players[playerIndex]?.isHuman || false;
    const playerName = currentState.players[playerIndex]?.name || 'æœªçŸ¥';
    
    // é˜²é‡å¤è°ƒç”¨æ£€æŸ¥ï¼ˆä½¿ç”¨æ›´ä¸¥æ ¼çš„æ£€æŸ¥ï¼šæ£€æŸ¥ç©å®¶ç´¢å¼•å’Œè½®æ¬¡å·ï¼‰
    const now = Date.now();
    const currentRoundNum = getCurrentRoundNumber(currentState);
    const callKey = `${playerIndex}-${currentRoundNum}`;
    const lastProcessTime = isProcessingPlayRef.current.get(playerIndex);
    
    // å¦‚æœåŒä¸€ä¸ªç©å®¶åœ¨500mså†…é‡å¤è°ƒç”¨ï¼Œæˆ–è€…æ¸¸æˆçŠ¶æ€å·²æ”¹å˜ï¼Œè·³è¿‡
    if (lastProcessTime && now - lastProcessTime < 500) {
      const latestState = gameStateRef.current;
      const latestRoundNum = getCurrentRoundNumber(latestState);
      // å¦‚æœè½®æ¬¡å·æ”¹å˜äº†ï¼Œè¯´æ˜æ˜¯æ–°çš„è°ƒç”¨ï¼Œå…è®¸æ‰§è¡Œ
      if (latestRoundNum === currentRoundNum) {
        console.warn(`[playerPlayAsync] âš ï¸ æ£€æµ‹åˆ°é‡å¤è°ƒç”¨ï¼Œè·³è¿‡`, {
          playerIndex,
          playerName,
          callKey,
          lastProcessTime,
          currentTime: now,
          timeDiff: now - lastProcessTime,
          roundNumber: currentRoundNum
        });
        return false;
      }
    }
    isProcessingPlayRef.current.set(playerIndex, now);
    
    // æ¸…ç†æ—§çš„è®°å½•ï¼ˆè¶…è¿‡5ç§’çš„ï¼‰
    for (const [pid, timestamp] of isProcessingPlayRef.current.entries()) {
      if (now - timestamp > 5000) {
        isProcessingPlayRef.current.delete(pid);
      }
    }
    
    const round = getCurrentRound(currentState);
    const currentRoundNumber = getCurrentRoundNumber(currentState);
    
    if (isHumanPlayer) {
      console.error(`[playerPlayAsync] ğŸ”µ çœŸå®ç©å®¶å‡ºç‰Œå¼€å§‹`, {
        playerIndex,
        playerName,
        cardsCount: selectedCards.length,
        selectedCards: selectedCards.map((c: Card) => `${c.suit}-${c.rank}`),
        roundNumber: currentRoundNumber,
        currentPlayerIndex: currentState.currentPlayerIndex,
        timestamp: now
      });
    }
    
    if (!round) {
      console.error('[playerPlayAsync] âœ— currentRound æœªåˆå§‹åŒ–ï¼Œæ— æ³•å¤„ç†å‡ºç‰Œ', {
        playerIndex,
        timestamp: now
      });
      isProcessingPlayRef.current.delete(playerIndex);
      return false;
    }

    try {
      // æ£€æŸ¥è½®æ¬¡å·æ˜¯å¦åŒ¹é…
      if (round.roundNumber !== currentRoundNumber) {
        console.warn(`[playerPlayAsync] âš ï¸ è½®æ¬¡å·ä¸åŒ¹é…ï¼Œå¿½ç•¥æ—§è½®æ¬¡çš„å‡ºç‰Œè¯·æ±‚`, {
          requestRoundNumber: round.roundNumber,
          currentRoundNumber: currentRoundNumber,
          playerIndex,
          timestamp: now
        });
        isProcessingPlayRef.current.delete(playerIndex);
        return false;
      }
      
      // æ£€æŸ¥è½®æ¬¡æ˜¯å¦å·²ç»“æŸ
      if (round.isEnded()) {
        console.warn(`[playerPlayAsync] âš ï¸ è½®æ¬¡ ${round.roundNumber} å·²ç»“æŸï¼Œæ— æ³•å¤„ç†ç©å®¶ ${playerIndex} çš„å‡ºç‰Œ`, {
          roundNumber: round.roundNumber,
          playerIndex,
          timestamp: now
        });
        isProcessingPlayRef.current.delete(playerIndex);
        return false;
      }
      
      // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
      if (currentState.status !== GameStatus.PLAYING) {
        console.warn(`[playerPlayAsync] âš ï¸ æ¸¸æˆçŠ¶æ€ä¸æ˜¯PLAYINGï¼Œæ— æ³•å¤„ç†å‡ºç‰Œ`, {
          status: currentState.status,
          playerIndex,
          timestamp: now
        });
        isProcessingPlayRef.current.delete(playerIndex);
        return false;
      }
      
      // ä½¿ç”¨è¾…åŠ©å‡½æ•°å¤„ç†å¼‚æ­¥å‡ºç‰Œ
      const result = await processPlayAsync(
        round,
        playerIndex,
        selectedCards,
        currentState.players,
        currentState.playerCount,
        currentState.players.findIndex(p => p.isHuman),
        { 
          timingConfig: gameConfig.timingConfig, 
          cardTrackerEnabled: cardTrackerEnabled,
          announcementDelay: gameConfig.announcementDelay
        } as { timingConfig?: any; cardTrackerEnabled?: boolean; announcementDelay?: number },
        setGameState,
        () => gameStateRef.current,
        {
          recordTrackingPlay,
          announcePlayAudio
        }
      );

      if (result.status === 'completed') {
        const updatedState = gameStateRef.current;
        const updatedPlayer = updatedState.players[playerIndex];
        const updatedRound = getCurrentRound(updatedState);
        
        if (!updatedRound) {
          console.error('[playerPlayAsync] âš ï¸ æ— æ³•è·å–æ›´æ–°åçš„ Round å¯¹è±¡');
          return false;
        }
        
        if (isHumanPlayer) {
          console.error(`[playerPlayAsync] ğŸ”µ çœŸå®ç©å®¶å‡ºç‰Œå¤„ç†å®Œæˆ`, {
            playerIndex,
            playerName: updatedPlayer.name || 'æœªçŸ¥',
            handCount: updatedPlayer.hand.length,
            roundNumber: updatedRound.roundNumber,
            playsCount: updatedRound.getPlayCount(),
            timestamp: Date.now()
          });
        }
        
        // ========== æ£€æŸ¥æ˜¯å¦å‡ºå®Œç‰Œ ==========
        // æ ¹æ®æ–‡æ¡£ï¼šç©å®¶å‡ºå®Œç‰Œæ—¶ï¼Œç«‹å³æ ‡è®°ä¸ºå·²å‡ºå®Œï¼Œè®°å½•åˆ°finishOrderï¼Œè®¾ç½®finishedRank
        // ä½†æ¸¸æˆæµç¨‹ç»§ç»­ï¼Œéœ€è¦è½®è¯¢å…¶ä»–ç©å®¶ï¼ˆå› ä¸ºä¸çŸ¥é“æ˜¯å¦è¿˜æœ‰ä¸‹å®¶èƒ½åƒå¾—èµ·ï¼‰
        // æ³¨æ„ï¼šè½®æ¬¡åˆ†æ•°ä¸åœ¨å‡ºå®Œç‰Œæ—¶åˆ†é…ï¼Œè€Œæ˜¯åœ¨è½®æ¬¡ç»“æŸæ—¶åˆ†é…
        if (updatedPlayer.hand.length === 0 && gameControllerRef.current) {
          // ä½¿ç”¨ GameController è®°å½•ç©å®¶å‡ºå®Œç‰Œ
          // ç¡®ä¿ä¼ å…¥æœ€æ–°çš„ç©å®¶çŠ¶æ€ï¼ˆæ‰‹ç‰Œå·²æ›´æ–°ï¼‰
          // é‡è¦ï¼šupdatedPlayer æ˜¯ä» gameStateRef.current è·å–çš„ï¼Œæ‰‹ç‰Œåº”è¯¥å·²ç»æ˜¯ 0
          const currentPlayers = gameStateRef.current.players;
          
          // ç¡®ä¿å½“å‰ç©å®¶çš„æ‰‹ç‰ŒçŠ¶æ€æ­£ç¡®ï¼ˆé˜²å¾¡æ€§æ£€æŸ¥ï¼‰
          const playersWithCorrectHand = currentPlayers.map((p, i) => 
            i === playerIndex ? { ...p, hand: [] } : p
          );
          
          const { updatedPlayers: playersAfterFinish, newFinishOrder, finishedRank } = 
            gameControllerRef.current.recordPlayerFinished(playerIndex, playersWithCorrectHand);
          
          console.warn(`[playerPlayAsync] âœ“ ç©å®¶å‡ºå®Œç‰Œ`, {
            playerIndex,
            playerName: updatedPlayer.name,
            isHuman: isHumanPlayer,
            finishedRank, // äº‰ä¸Šæ¸¸åæ¬¡ï¼ˆå‡ºå®Œç‰Œçš„é¡ºåºï¼Œç¬¬ä¸€ä¸ªå‡ºå®Œçš„æ˜¯ç¬¬1åï¼‰
            finishOrder: newFinishOrder,
            handCount: currentPlayers[playerIndex]?.hand?.length || 0,
            remainingPlayers: currentPlayers.filter(p => p.hand.length > 0).length,
            note: 'ç«‹å³æ˜¾ç¤ºäº‰ä¸Šæ¸¸åæ¬¡ï¼ˆfinishedRankï¼‰ï¼Œåˆ†æ•°åæ¬¡ï¼ˆscoreRankï¼‰åœ¨æ¸¸æˆç»“æŸæ—¶è®¡ç®—',
            timestamp: Date.now()
          });
          
          // å…ˆåŒæ­¥ GameController çš„çŠ¶æ€ï¼Œç¡®ä¿çŠ¶æ€ä¸€è‡´
          gameControllerRef.current.updatePlayers(currentPlayers);
          
          // âœ… é‡è¦ï¼šrecordPlayerFinished ä¼šåŒæ­¥è§¦å‘å›è°ƒæ›´æ–° finishedRank
          // å›è°ƒä¸­çš„ setGameState æ˜¯å¼‚æ­¥çš„ï¼Œæˆ‘ä»¬éœ€è¦ç­‰å¾…å®ƒå®Œæˆ
          console.log(`[playerPlayAsync] âœ… å·²è°ƒç”¨ recordPlayerFinishedï¼Œç­‰å¾…å›è°ƒæ›´æ–°åæ¬¡`, {
            playerIndex,
            finishedRank,
            note: 'å›è°ƒä¼šåŒæ­¥è°ƒç”¨ï¼Œä½† setGameState æ˜¯å¼‚æ­¥çš„'
          });
          
          // ç­‰å¾…å›è°ƒçš„ setGameState å®Œæˆï¼ˆReact çŠ¶æ€æ›´æ–°æ˜¯å¼‚æ­¥çš„ï¼Œéœ€è¦ç»™æ—¶é—´ï¼‰
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // ç„¶åæ›´æ–° roundsï¼ˆä½¿ç”¨å‡½æ•°å¼æ›´æ–°ï¼Œç¡®ä¿ä¸ä¼šè¦†ç›–å›è°ƒæ›´æ–°çš„ finishedRankï¼‰
          setGameState(prev => {
            const latestRound = getCurrentRound(prev) || updatedRound;
            const updatedRounds = [...prev.rounds];
            if (prev.currentRoundIndex >= 0 && prev.currentRoundIndex < updatedRounds.length) {
              updatedRounds[prev.currentRoundIndex] = latestRound;
            }
            
            // é‡è¦ï¼šåªæ›´æ–° roundsï¼Œä¸è¦†ç›– players å’Œ finishOrderï¼ˆç”±å›è°ƒæ›´æ–°ï¼‰
            return {
              ...prev,
              rounds: updatedRounds
              // ä¸æ›´æ–° players å’Œ finishOrderï¼Œç”±å›è°ƒå¤„ç†
            };
          });
          
          // éªŒè¯ï¼šæ£€æŸ¥å›è°ƒæ˜¯å¦å·²æ›´æ–°çŠ¶æ€
          const stateAfterCallback = gameStateRef.current;
          const playerAfterCallback = stateAfterCallback.players[playerIndex];
          if (playerAfterCallback && playerAfterCallback.finishedRank === finishedRank) {
            console.log(`[playerPlayAsync] âœ… éªŒè¯é€šè¿‡ï¼šå›è°ƒå·²æ›´æ–°ç©å®¶åæ¬¡`, {
              playerIndex,
              finishedRank: playerAfterCallback.finishedRank,
              note: 'æ–°æµç¨‹æ­£å¸¸å·¥ä½œ'
            });
          } else {
            console.warn(`[playerPlayAsync] âš ï¸ éªŒè¯å¤±è´¥ï¼šå›è°ƒå¯èƒ½æœªæ›´æ–°ç©å®¶åæ¬¡`, {
              playerIndex,
              expectedFinishedRank: finishedRank,
              actualFinishedRank: playerAfterCallback?.finishedRank,
              playerExists: !!playerAfterCallback,
              note: 'å¯èƒ½éœ€è¦æ£€æŸ¥å›è°ƒæ˜¯å¦æ­£ç¡®è§¦å‘'
            });
          }
          
          // ========== å…³é”®ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦åªå‰©ä¸€ä¸ªç©å®¶ ==========
          // å¦‚æœå€’æ•°ç¬¬äºŒåå‡ºå®Œç‰Œååªå‰©ä¸€ä¸ªç©å®¶ï¼Œåº”è¯¥ç«‹å³ç»“æŸæ¸¸æˆï¼Œè€Œä¸æ˜¯ç»§ç»­è½®è¯¢
          const remainingPlayers = playersAfterFinish.filter(p => p.hand.length > 0);
          if (remainingPlayers.length === 1) {
            const lastPlayerIndex = remainingPlayers[0].id;
            const lastPlayer = playersAfterFinish[lastPlayerIndex];
            
            console.warn(`[playerPlayAsync] âš ï¸ å€’æ•°ç¬¬äºŒåå‡ºå®Œç‰Œï¼Œåªå‰©ä¸€ä¸ªç©å®¶ï¼Œäº¤ç»™ç»Ÿä¸€ç»“æŸç®¡çº¿å¤„ç†`, {
              lastPlayerIndex,
              lastPlayerName: lastPlayer?.name,
              finishOrder: newFinishOrder,
              finishedRank,
              timestamp: Date.now()
            });
            
            // è§¦å‘æœ€åä¸€åè¾“äº†çš„èŠå¤©ååº”ï¼ˆUI å±‚é¢çš„åé¦ˆï¼‰
            triggerFinishLastReaction(lastPlayer, undefined, updatedState).catch(console.error);
            
            // ä¸åœ¨è¿™é‡Œç›´æ¥ç»“æŸæ¸¸æˆï¼Œäº¤ç»™ RoundScheduler + checkGameFinished + GameController ç»Ÿä¸€å¤„ç†
            return true;
          }
        }
        
        // ä½¿ç”¨ RoundScheduler å¤„ç†è°ƒåº¦é€»è¾‘
        if (schedulerRef.current) {
          const handleRoundEnd = async (finalRound: Round, players: Player[], _nextPlayerIndex: number | null, savedWinnerIndex?: number | null) => {
            // Round.end() ä¸åˆ†é…åˆ†æ•°ï¼Œåªè¿”å›è½®æ¬¡ä¿¡æ¯
            const { updatedPlayers: playersFromRound, nextPlayerIndex: newNext, roundScore, winnerIndex } = finalRound.end(
              players,
              currentState.playerCount,
              savedWinnerIndex
            );
            
            // ä½¿ç”¨ GameController åˆ†é…è½®æ¬¡åˆ†æ•°
            let updatedPlayers = playersFromRound;
            if (gameControllerRef.current && roundScore > 0 && winnerIndex !== null) {
              const roundRecord = finalRound.toRecord();
              updatedPlayers = gameControllerRef.current.allocateRoundScore(
                finalRound.roundNumber,
                roundScore,
                winnerIndex,
                playersFromRound,
                roundRecord
              );
            }
            
            const roundRecord = finalRound.toRecord();
            
            if (cardTrackerEnabled) {
              try {
                endTrackingRound(finalRound.roundNumber, roundRecord.winnerId, roundRecord.winnerName || 'æœªçŸ¥', roundRecord.totalScore, updatedPlayers);
              } catch (error) {
                console.error(`[playerPlayAsync] âœ— è¿½è¸ªæ¨¡å—è®°å½•å¤±è´¥`, error);
              }
            }
            
            // ========== è½®æ¬¡ç»“æŸæ—¶çš„éªŒè¯ ==========
            // ä» rounds æ•°ç»„æå–æ‰€æœ‰å·²ç»“æŸçš„è½®æ¬¡è®°å½•è¿›è¡ŒéªŒè¯
            // æ³¨æ„ï¼šéœ€è¦æ’é™¤å½“å‰åˆšç»“æŸçš„è½®æ¬¡ï¼ˆfinalRoundï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬è¦ä½¿ç”¨æ–°çš„ roundRecord
            const stateForValidation = gameStateRef.current;
            const allRoundsRecords = stateForValidation.rounds
              .filter(r => r.isEnded() && r.roundNumber !== finalRound.roundNumber) // æ’é™¤å½“å‰è½®æ¬¡ï¼Œé¿å…é‡å¤
              .map(r => r.toRecord());
            // åŒ…å«å½“å‰åˆšç»“æŸçš„è½®æ¬¡ï¼ˆä½¿ç”¨æ–°çš„ roundRecordï¼‰
            const allRoundsWithCurrent = [...allRoundsRecords, roundRecord];
            
            // ä½¿ç”¨éªŒè¯æ¨¡å—
            const validationContext = {
              players: updatedPlayers,
              allRounds: allRoundsWithCurrent,
              currentRoundPlays: [],
              initialHands: stateForValidation.initialHands,
              trigger: 'roundEnd' as const,
              roundNumber: finalRound.roundNumber,
              context: `è½®æ¬¡ ${finalRound.roundNumber} ç»“æŸ`,
              timestamp: Date.now()
            };
            validateRoundEnd(validationContext);
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            const finishOrder = gameControllerRef.current?.getFinishOrder() || gameStateRef.current.finishOrder || [];
            const gameFinishedResult = checkGameFinished(
              gameStateRef.current,
              updatedPlayers,
              finishOrder
            );
            
            if (gameFinishedResult) {
              // ä½¿ç”¨ GameController è®¡ç®—æœ€ç»ˆåˆ†æ•°å’Œæ’å
              if (gameControllerRef.current) {
                const { updatedPlayers: finalPlayers, finalRankings } = 
                  gameControllerRef.current.calculateFinalScoresAndRankings(updatedPlayers);
                
                setGameState({
                  ...gameFinishedResult,
                  players: finalPlayers,
                  finalRankings
                });
              } else {
                setGameState(gameFinishedResult);
              }
              return;
            }
            
            // åˆ›å»ºæ–°è½®æ¬¡ï¼ˆä½¿ç”¨æœ€æ–°çš„é…ç½®ï¼‰
            // æ³¨æ„ï¼šæ–°è½®æ¬¡åˆ›å»ºæ—¶ï¼ŒlastPlay å’Œ lastPlayPlayerIndex è‡ªåŠ¨ä¸º null
            // è¿™ç¡®ä¿äº†æ–°è½®æ¬¡ä¸­æ¥é£åˆ¤æ–­çš„æ­£ç¡®æ€§ï¼šå½“æ¥é£ç©å®¶å‡ºç‰Œåï¼ŒlastPlayPlayerIndex ä¼šè¢«è®¾ç½®ä¸ºæ¥é£ç©å®¶çš„ç´¢å¼•
            const nextRoundNumber = finalRound.roundNumber + 1;
            const latestGameConfig = getGameConfig();
            const nextRound = Round.createNew(nextRoundNumber, Date.now(), latestGameConfig.timingConfig);
            
            // éªŒè¯æ–°è½®æ¬¡çŠ¶æ€ï¼šlastPlay å’Œ lastPlayPlayerIndex åº”è¯¥ä¸º null
            console.warn(`[useMultiPlayerGame] â†’ åˆ›å»ºæ–°è½®æ¬¡ ${nextRoundNumber}`, {
              nextRoundNumber,
              nextPlayerIndex: newNext,
              lastPlay: nextRound.getLastPlay(),
              lastPlayPlayerIndex: nextRound.getLastPlayPlayerIndex(),
              note: 'æ–°è½®æ¬¡å¼€å§‹æ—¶ï¼ŒlastPlay å’Œ lastPlayPlayerIndex è‡ªåŠ¨ä¸º nullï¼Œç¡®ä¿æ¥é£åˆ¤æ–­æ­£ç¡®'
            });
            
            if (cardTrackerEnabled) {
              try {
                startTrackingRound(nextRoundNumber, updatedPlayers);
              } catch (error) {
                console.error(`[playerPlayAsync] âœ— è¿½è¸ªæ¨¡å—åˆ›å»ºæ–°è½®æ¬¡å¤±è´¥`, error);
              }
            }
            
            setGameState(prev => {
              const updatedRounds = [...prev.rounds, nextRound];
              const newCurrentRoundIndex = updatedRounds.length - 1;
              
              return {
                ...prev,
                rounds: updatedRounds,
                currentRoundIndex: newCurrentRoundIndex,
                players: updatedPlayers,
                currentPlayerIndex: newNext !== null ? newNext : prev.currentPlayerIndex
              };
            });
            
            // æ›´æ–°è°ƒåº¦å™¨çš„è½®æ¬¡å·
            if (schedulerRef.current) {
              schedulerRef.current.updateRoundNumber(nextRoundNumber);
            }
            
            // å¦‚æœä¸‹ä¸€ä¸ªç©å®¶æ˜¯AIï¼Œè‡ªåŠ¨å‡ºç‰Œ
            const nextPlayerIndex = newNext !== null ? newNext : gameStateRef.current.currentPlayerIndex;
            const nextPlayer = updatedPlayers[nextPlayerIndex];
            if (nextPlayer && (nextPlayer.type === PlayerType.AI || (nextPlayer.isHuman && isAutoPlayRef.current))) {
              setTimeout(() => {
                if (schedulerRef.current) {
                  schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
                }
              }, 500);
            }
          };
          
          await (schedulerRef.current as any).onPlayCompleted(
            playerIndex,
            updatedRound,
            updatedState.players,
            updatedState.playerCount,
            setGameState,
            handleRoundEnd
          );
        }
        
        return true;
      }
      
      return true;
    } catch (error) {
      console.error('[playerPlayAsync] å‡ºç‰Œå¤„ç†å¤±è´¥:', error);
      isProcessingPlayRef.current.delete(playerIndex);
      return false;
    } finally {
      // å»¶è¿Ÿæ¸…ç†ï¼Œç¡®ä¿çŠ¶æ€æ›´æ–°å®Œæˆ
      setTimeout(() => {
        isProcessingPlayRef.current.delete(playerIndex);
      }, 1000);
    }
  }, [validateRoundEnd, initializeTracker, startTrackingRound, recordTrackingPlay, endTrackingRound, announcePlayAudio]);

  // ========== ç©å®¶è¦ä¸èµ· ==========
  
  const playerPass = useCallback((playerIndex: number) => {
    playerPassAsync(playerIndex).catch(console.error);
  }, []);

  const playerPassAsync = useCallback(async (playerIndex: number): Promise<void> => {
    const currentState = gameStateRef.current;
    const isHumanPlayer = currentState.players[playerIndex]?.isHuman || false;
    const playerName = currentState.players[playerIndex]?.name || 'æœªçŸ¥';
    
    // é˜²é‡å¤è°ƒç”¨æ£€æŸ¥ï¼ˆä½¿ç”¨æ›´ä¸¥æ ¼çš„æ£€æŸ¥ï¼šæ£€æŸ¥ç©å®¶ç´¢å¼•å’Œè½®æ¬¡å·ï¼‰
    const now = Date.now();
    const currentRoundNum = getCurrentRoundNumber(currentState);
    const lastProcessTime = isProcessingPassRef.current.get(playerIndex);
    
    // å¦‚æœåŒä¸€ä¸ªç©å®¶åœ¨500mså†…é‡å¤è°ƒç”¨ï¼Œæˆ–è€…æ¸¸æˆçŠ¶æ€å·²æ”¹å˜ï¼Œè·³è¿‡
    if (lastProcessTime && now - lastProcessTime < 500) {
      const latestState = gameStateRef.current;
      const latestRoundNum = getCurrentRoundNumber(latestState);
      // å¦‚æœè½®æ¬¡å·æ”¹å˜äº†ï¼Œè¯´æ˜æ˜¯æ–°çš„è°ƒç”¨ï¼Œå…è®¸æ‰§è¡Œ
      if (latestRoundNum === currentRoundNum) {
        console.warn(`[playerPassAsync] âš ï¸ æ£€æµ‹åˆ°é‡å¤è°ƒç”¨ï¼Œè·³è¿‡`, {
          playerIndex,
          playerName,
          lastProcessTime,
          currentTime: now,
          timeDiff: now - lastProcessTime,
          roundNumber: currentRoundNum
        });
        return;
      }
    }
    isProcessingPassRef.current.set(playerIndex, now);
    
    // æ¸…ç†æ—§çš„è®°å½•ï¼ˆè¶…è¿‡5ç§’çš„ï¼‰
    for (const [pid, timestamp] of isProcessingPassRef.current.entries()) {
      if (now - timestamp > 5000) {
        isProcessingPassRef.current.delete(pid);
      }
    }
    
    const round = getCurrentRound(currentState);
    const currentRoundNumber = getCurrentRoundNumber(currentState);
    const lastPlay = getLastPlay(currentState);
    
    if (isHumanPlayer) {
      console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ·å¼€å§‹`, {
        playerIndex,
        playerName,
        roundNumber: currentRoundNumber,
        timestamp: now
      });
    }
    
    if (!round) {
      if (isHumanPlayer) {
        console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ· - ä½¿ç”¨æ—§é€»è¾‘ï¼ˆæ— Roundå¯¹è±¡ï¼‰`);
      }
      isProcessingPassRef.current.delete(playerIndex);
      return;
    }
    
    if (round.isEnded()) {
      if (isHumanPlayer) {
        console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ· - è½®æ¬¡å·²ç»“æŸï¼Œæ— æ³•å¤„ç†`);
      }
      isProcessingPassRef.current.delete(playerIndex);
      return;
    }
    
    // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
    if (currentState.status !== GameStatus.PLAYING) {
      console.warn(`[playerPassAsync] âš ï¸ æ¸¸æˆçŠ¶æ€ä¸æ˜¯PLAYINGï¼Œæ— æ³•å¤„ç†è¦ä¸èµ·`, {
        status: currentState.status,
        playerIndex,
        timestamp: now
      });
      isProcessingPassRef.current.delete(playerIndex);
      return;
    }
    
    // å¼ºåˆ¶å‡ºç‰Œè§„åˆ™ï¼šå¦‚æœæœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¸èƒ½è¦ä¸èµ·
    const player = currentState.players[playerIndex];
    if (lastPlay && player) {
      const hasPlayable = hasPlayableCards(player.hand, lastPlay);
      if (hasPlayable) {
        if (isHumanPlayer) {
          console.error(`[playerPassAsync] ğŸ”µ çœŸå®ç©å®¶è¦ä¸èµ· - æœ‰èƒ½æ‰“è¿‡çš„ç‰Œï¼Œä¸å…è®¸è¦ä¸èµ·`);
        }
        return;
      }
    }
    
    try {
      // è®°å½•è¦ä¸èµ·
      round.recordPass(playerIndex);
      
      // æ’­æ”¾"è¦ä¸èµ·"è¯­éŸ³
      await announcePassAudio(player?.voiceConfig);
      
      // ä½¿ç”¨ RoundScheduler å¤„ç†è°ƒåº¦é€»è¾‘
      if (schedulerRef.current) {
        const handleRoundEnd = async (finalRound: Round, players: Player[], _nextPlayerIndex: number | null, savedWinnerIndex?: number | null) => {
          // Round.end() ä¸åˆ†é…åˆ†æ•°ï¼Œåªè¿”å›è½®æ¬¡ä¿¡æ¯
          const { updatedPlayers: playersFromRound, nextPlayerIndex: newNext, roundScore, winnerIndex } = finalRound.end(
            players,
            currentState.playerCount,
            savedWinnerIndex
          );
          
          // ä½¿ç”¨ GameController åˆ†é…è½®æ¬¡åˆ†æ•°
          let updatedPlayers = playersFromRound;
          if (gameControllerRef.current && roundScore > 0 && winnerIndex !== null) {
            const roundRecord = finalRound.toRecord();
            updatedPlayers = gameControllerRef.current.allocateRoundScore(
              finalRound.roundNumber,
              roundScore,
              winnerIndex,
              playersFromRound,
              roundRecord
            );
          }
          
          const roundRecord = finalRound.toRecord();
          
          if (cardTrackerEnabled) {
            try {
              endTrackingRound(finalRound.roundNumber, roundRecord.winnerId, roundRecord.winnerName || 'æœªçŸ¥', roundRecord.totalScore, updatedPlayers);
            } catch (error) {
              console.error(`[playerPassAsync] âœ— è¿½è¸ªæ¨¡å—è®°å½•å¤±è´¥`, error);
            }
          }
          
          // ========== è½®æ¬¡ç»“æŸæ—¶çš„éªŒè¯ ==========
          // ä» rounds æ•°ç»„æå–æ‰€æœ‰å·²ç»“æŸçš„è½®æ¬¡è®°å½•è¿›è¡ŒéªŒè¯
          // æ³¨æ„ï¼šéœ€è¦æ’é™¤å½“å‰åˆšç»“æŸçš„è½®æ¬¡ï¼ˆfinalRoundï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬è¦ä½¿ç”¨æ–°çš„ roundRecord
          const stateForValidation = gameStateRef.current;
          const allRoundsRecords = stateForValidation.rounds
            .filter(r => r.isEnded() && r.roundNumber !== finalRound.roundNumber) // æ’é™¤å½“å‰è½®æ¬¡ï¼Œé¿å…é‡å¤
            .map(r => r.toRecord());
          // åŒ…å«å½“å‰åˆšç»“æŸçš„è½®æ¬¡ï¼ˆä½¿ç”¨æ–°çš„ roundRecordï¼‰
          const allRoundsWithCurrent = [...allRoundsRecords, roundRecord];
          
          // ä½¿ç”¨éªŒè¯æ¨¡å—
          const validationContext = {
            players: updatedPlayers,
            allRounds: allRoundsWithCurrent,
            currentRoundPlays: [],
            initialHands: stateForValidation.initialHands,
            trigger: 'roundEnd' as const,
            roundNumber: finalRound.roundNumber,
            context: `è½®æ¬¡ ${finalRound.roundNumber} ç»“æŸï¼ˆè¦ä¸èµ·è§¦å‘ï¼‰`,
            timestamp: Date.now()
          };
          validateRoundEnd(validationContext);
          
          // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
          const finishOrder = gameControllerRef.current?.getFinishOrder() || gameStateRef.current.finishOrder || [];
          const gameFinishedResult = checkGameFinished(
            gameStateRef.current,
            updatedPlayers,
            finishOrder
          );
          
          if (gameFinishedResult) {
            // ä½¿ç”¨ GameController è®¡ç®—æœ€ç»ˆåˆ†æ•°å’Œæ’å
            if (gameControllerRef.current) {
              const { updatedPlayers: finalPlayers, finalRankings } = 
                gameControllerRef.current.calculateFinalScoresAndRankings(updatedPlayers);
              
              setGameState({
                ...gameFinishedResult,
                players: finalPlayers,
                finalRankings
              });
            } else {
              setGameState(gameFinishedResult);
            }
            return;
          }
          
          const nextRoundNumber = finalRound.roundNumber + 1;
          const latestGameConfig = getGameConfig();
          const nextRound = Round.createNew(nextRoundNumber, Date.now(), latestGameConfig.timingConfig);
          
          // éªŒè¯æ–°è½®æ¬¡çŠ¶æ€ï¼šlastPlay å’Œ lastPlayPlayerIndex åº”è¯¥ä¸º null
          console.warn(`[useMultiPlayerGame] â†’ åˆ›å»ºæ–°è½®æ¬¡ ${nextRoundNumber}`, {
            nextRoundNumber,
            nextPlayerIndex: newNext,
            lastPlay: nextRound.getLastPlay(),
            lastPlayPlayerIndex: nextRound.getLastPlayPlayerIndex(),
            note: 'æ–°è½®æ¬¡å¼€å§‹æ—¶ï¼ŒlastPlay å’Œ lastPlayPlayerIndex è‡ªåŠ¨ä¸º nullï¼Œç¡®ä¿æ¥é£åˆ¤æ–­æ­£ç¡®'
          });
          
          if (cardTrackerEnabled) {
            try {
              startTrackingRound(nextRoundNumber, updatedPlayers);
            } catch (error) {
              console.error(`[playerPassAsync] âœ— è¿½è¸ªæ¨¡å—åˆ›å»ºæ–°è½®æ¬¡å¤±è´¥`, error);
            }
          }
          
          setGameState(prev => {
            const updatedRounds = [...prev.rounds, nextRound];
            const newCurrentRoundIndex = updatedRounds.length - 1;
            
            return {
              ...prev,
              rounds: updatedRounds,
              currentRoundIndex: newCurrentRoundIndex,
              players: updatedPlayers,
              currentPlayerIndex: newNext !== null ? newNext : prev.currentPlayerIndex
            };
          });
          
          if (schedulerRef.current) {
            schedulerRef.current.updateRoundNumber(nextRoundNumber);
          }
          
          const nextPlayerIndex = newNext !== null ? newNext : gameStateRef.current.currentPlayerIndex;
          const nextPlayer = updatedPlayers[nextPlayerIndex];
          if (nextPlayer && (nextPlayer.type === PlayerType.AI || (nextPlayer.isHuman && isAutoPlayRef.current))) {
            setTimeout(() => {
              if (schedulerRef.current) {
                schedulerRef.current.scheduleNextTurn(nextPlayerIndex, 0);
              }
            }, 500);
          }
        };
        
        await (schedulerRef.current as any).onPassCompleted(
          playerIndex,
          round,
          currentState.players,
          currentState.playerCount,
          setGameState,
          handleRoundEnd
        );
      }
    } catch (error) {
      console.error('[playerPassAsync] è¦ä¸èµ·å¤„ç†å¤±è´¥:', error);
      isProcessingPassRef.current.delete(playerIndex);
    } finally {
      // å»¶è¿Ÿæ¸…ç†ï¼Œç¡®ä¿çŠ¶æ€æ›´æ–°å®Œæˆ
      setTimeout(() => {
        isProcessingPassRef.current.delete(playerIndex);
      }, 1000);
    }
  }, [validateRoundEnd, startTrackingRound, endTrackingRound, announcePassAudio]);

  // ========== AIå»ºè®®å‡ºç‰Œ ==========
  
  const suggestPlay = useCallback(async (
    playerIndex: number,
    aiConfig: AIConfig
  ): Promise<Card[] | null> => {
    const currentState = gameStateRef.current;
    const player = currentState.players[playerIndex];
    if (!player) return null;

    try {
      const aiConfigWithContext = {
        ...aiConfig,
        perfectInformation: true,
        allPlayerHands: currentState.players.map(p => [...p.hand]),
        currentRoundScore: getCurrentRoundScore(currentState) || 0,
        playerCount: currentState.playerCount
      };
      
      const suggestedCards = await aiChoosePlay(
        player.hand,
        getLastPlay(currentState),
        aiConfigWithContext
      );
      return suggestedCards;
    } catch (error) {
      console.error('AIå»ºè®®å¤±è´¥:', error);
      return null;
    }
  }, []);

  // ========== é‡ç½®æ¸¸æˆ ==========
  
  const resetGame = useCallback(() => {
    // é‡ç½®æ¸¸æˆæ§åˆ¶å™¨
    if (gameControllerRef.current) {
      gameControllerRef.current.reset();
    }
    
    setGameState({
      status: GameStatus.WAITING,
      players: [],
      currentPlayerIndex: 0,
      winner: null,
      playerCount: 0,
      finishOrder: [],
      rounds: [],
      currentRoundIndex: -1
    });
  }, []);

  // ========== åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€ ==========
  
  const toggleAutoPlay = useCallback(() => {
    setIsAutoPlay(prev => {
      const newValue = !prev;
      console.log('[AutoPlay] ğŸ”„ åˆ‡æ¢æ‰˜ç®¡çŠ¶æ€:', newValue ? 'å¼€å¯' : 'å…³é—­');
      
      if (newValue) {
        const currentState = gameStateRef.current;
        if (currentState.status === GameStatus.PLAYING) {
          const currentPlayer = currentState.players[currentState.currentPlayerIndex];
          if (currentPlayer && currentPlayer.isHuman) {
            console.log('[AutoPlay] ğŸš€ å¼€å¯æ‰˜ç®¡æ—¶ï¼Œå½“å‰è½®åˆ°äººç±»ç©å®¶ï¼Œç«‹å³è§¦å‘', {
              playerIndex: currentState.currentPlayerIndex,
              playerName: currentPlayer.name,
              handCount: currentPlayer.hand.length
            });
            setTimeout(() => {
              if (schedulerRef.current) {
                schedulerRef.current.scheduleNextTurn(undefined, 0);
              }
            }, 500);
          }
        }
      }
      
      return newValue;
    });
  }, []);

  // ========== AIè‡ªåŠ¨å‡ºç‰Œ useEffect ==========
  
  useEffect(() => {
    if (gameState.status !== GameStatus.PLAYING) return;
    
    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (!currentPlayer) return;
    
    // å¦‚æœå½“å‰ç©å®¶æ˜¯AIæˆ–æ‰˜ç®¡æ¨¡å¼ä¸‹çš„çœŸå®ç©å®¶ï¼Œè‡ªåŠ¨å‡ºç‰Œ
    const shouldAutoPlay = currentPlayer.type === PlayerType.AI || 
                          (currentPlayer.isHuman && isAutoPlay);
    
    if (shouldAutoPlay) {
      const timer = setTimeout(() => {
        if (schedulerRef.current) {
          schedulerRef.current.scheduleNextTurn(gameState.currentPlayerIndex, 0);
        }
      }, 500);
      
      return () => clearTimeout(timer);
    }
  }, [gameState.currentPlayerIndex, gameState.status, isAutoPlay]);

  return {
    gameState,
    startGame,
    playerPlay,
    playerPlayAsync,
    playerPass,
    playerPassAsync,
    suggestPlay,
    resetGame,
    isDealing,
    pendingGameConfig,
    handleDealingComplete,
    handleDealingCancel,
    isAutoPlay,
    toggleAutoPlay
  };
}
