
> guozha-poker-game@1.0.0 test:realtime
> vitest --run --reporter=verbose --no-coverage


 RUN  v1.6.1 /home/jin/guozha_poker_game

stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别单张

============================================================
📋 测试：识别单张
  出牌: spades-5
  识别结果: 类型=single, 值=5
  ✅ 单张识别正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别对子

============================================================
📋 测试：识别对子
  出牌: 2张相同点数
  识别结果: 类型=pair, 值=3
  ✅ 对子识别正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别三张

============================================================
📋 测试：识别三张
  出牌: 3张相同点数
  识别结果: 类型=triple, 值=4
  ✅ 三张识别正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别炸弹（4-6张）

============================================================
📋 测试：识别炸弹
  出牌: 4张相同点数
  识别结果: 类型=bomb, 值=5
  ✅ 4张炸弹识别正确
  出牌: 5张相同点数
  识别结果: 类型=bomb, 值=5
  ✅ 5张炸弹识别正确
  出牌: 6张相同点数
  识别结果: 类型=bomb, 值=5
  ✅ 6张炸弹识别正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别墩（7张及以上）

============================================================
📋 测试：识别墩
  出牌: 7张相同点数
  识别结果: 类型=dun, 值=6
  ✅ 7张墩识别正确
  出牌: 8张相同点数
  识别结果: 类型=dun, 值=6
  ✅ 8张墩识别正确
  出牌: 9张相同点数
  识别结果: 类型=dun, 值=6
  ✅ 9张墩识别正确
  出牌: 10张相同点数
  识别结果: 类型=dun, 值=6
  ✅ 10张墩识别正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断单张压牌

============================================================
📋 测试：单张压牌规则
  上家: 单张3
  测试1: 单张4 能否压过? true
  测试2: 单张3 能否压过? false (相同点数不能压过)
  ✅ 单张压牌规则正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断对子压牌

============================================================
📋 测试：对子压牌规则
  上家: 对子3
  测试: 对子4 能否压过? true
  ✅ 对子压牌规则正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断炸弹压单张/对子/三张

============================================================
📋 测试：炸弹压牌规则
  炸弹: 4张5
  测试1: 炸弹能否压单张? true
  测试2: 炸弹能否压对子? true
  测试3: 炸弹能否压三张? true
  ✅ 炸弹压牌规则正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断墩压任何非墩牌型

============================================================
📋 测试：墩压牌规则
  墩: 7张6
  测试1: 墩能否压单张? true
  测试2: 墩能否压炸弹? true
  ✅ 墩压牌规则正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断墩压墩（数量多的赢）

============================================================
📋 测试：墩压墩规则
  上家: 7张7
  测试: 8张8 能否压过? true
  ✅ 墩压墩规则正确（数量多的赢）


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断炸弹压炸弹（数量多的赢）

============================================================
📋 测试：炸弹压炸弹规则
  上家: 4张9
  测试: 5张10 能否压过? true
  ✅ 炸弹压炸弹规则正确（数量多的赢）


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 出牌查找测试 > 应该能找到可以出的牌（接风状态）

============================================================
📋 测试：接风状态下找可出的牌
  手牌: 7张
  找到可出牌组合: 10种
    组合1: 1张, 类型=single
    组合2: 1张, 类型=single
    组合3: 1张, 类型=single
    组合4: 1张, 类型=single
    组合5: 1张, 类型=single
  ✅ 接风状态下能找到可出的牌


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 出牌查找测试 > 应该能找到可以压过上家的牌

============================================================
📋 测试：找能压过上家的牌
  手牌: 9张
  上家: 单张3
  找到可压过的牌组合: 5种
    组合1: 1张, 类型=single, 值=4
    组合2: 1张, 类型=single, 值=5
    组合3: 1张, 类型=single, 值=6
    组合4: 1张, 类型=single, 值=7
    组合5: 4张, 类型=bomb, 值=7
  ✅ 能找到能压过上家的牌


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 出牌查找测试 > 应该正确判断是否有能打过的牌

============================================================
📋 测试：判断是否有能打过的牌
  手牌: 4张
  上家: 单张3
  是否有能打过的牌: true
  ✅ 正确判断有能打过的牌


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确识别分牌

============================================================
📋 测试：识别分牌
  分牌测试:
    5: 是分牌=true, 分值=5
    10: 是分牌=true, 分值=10
    13: 是分牌=true, 分值=10
  非分牌测试:
    3: 是分牌=false, 分值=0
    4: 是分牌=false, 分值=0
  ✅ 分牌识别正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确计算分牌总分

============================================================
📋 测试：计算分牌总分
  牌组: 6张
  计算总分: 40分
  期望总分: 40分
  ✅ 分牌总分计算正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确计算墩的数量

============================================================
📋 测试：计算墩的数量
  墩数计算测试:
    7张 = 1墩 (期望: 1墩)
    8张 = 2墩 (期望: 2墩)
    9张 = 4墩 (期望: 4墩)
    10张 = 8墩 (期望: 8墩)
    11张 = 16墩 (期望: 16墩)
    12张 = 32墩 (期望: 32墩)
    13张 = 64墩 (期望: 64墩)
  ✅ 墩的数量计算正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确计算墩的分数（4人游戏）

============================================================
📋 测试：计算墩的分数（4人游戏）
  玩家数: 4人
  1墩:
    出墩玩家得分: 90 (期望: 90)
    其他玩家扣分: 30 (期望: 30)
  2墩:
    出墩玩家得分: 180 (期望: 180)
    其他玩家扣分: 60 (期望: 60)
  4墩:
    出墩玩家得分: 360 (期望: 360)
    其他玩家扣分: 120 (期望: 120)
  ✅ 墩的分数计算正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 综合场景测试 > 应该正确处理完整的出牌流程

============================================================
📋 测试：完整出牌流程
  玩家A出牌: 单张3
  玩家B可出的牌: 2种
  玩家B出牌: 单张4
  ✅ 完整出牌流程正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 综合场景测试 > 应该正确处理炸弹压单张的场景

============================================================
📋 测试：炸弹压单张场景
  上家: 单张14
  炸弹: 4张3
  能否压过: true
  ✅ 炸弹压单张场景正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 综合场景测试 > 应该正确处理墩压炸弹的场景

============================================================
📋 测试：墩压炸弹场景
  上家: 6张炸弹15
  墩: 7张3
  能否压过: true
  ✅ 墩压炸弹场景正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 边界情况测试 > 应该正确处理空手牌

============================================================
📋 测试：空手牌处理
  手牌: 0张
  可出的牌: 0种
  ✅ 空手牌处理正确


stdout | tests/playCardRegression.test.ts > 打牌出牌回归测试 > 边界情况测试 > 应该正确处理无法压过的情况

============================================================
📋 测试：无法压过的情况
  手牌: 单张3, 单张4
  上家: 单张A
  可出的牌: 0种
  是否有能打过的牌: false
  ✅ 无法压过的情况处理正确


 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别单张
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别对子
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别三张
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别炸弹（4-6张）
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 牌型识别测试 > 应该正确识别墩（7张及以上）
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断单张压牌
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断对子压牌
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断炸弹压单张/对子/三张
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断墩压任何非墩牌型
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断墩压墩（数量多的赢）
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 压牌规则测试 > 应该正确判断炸弹压炸弹（数量多的赢）
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 出牌查找测试 > 应该能找到可以出的牌（接风状态）
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 出牌查找测试 > 应该能找到可以压过上家的牌
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 出牌查找测试 > 应该正确判断是否有能打过的牌
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确识别分牌
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确计算分牌总分
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确计算墩的数量
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 计分规则测试 > 应该正确计算墩的分数（4人游戏）
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 综合场景测试 > 应该正确处理完整的出牌流程
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 综合场景测试 > 应该正确处理炸弹压单张的场景
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 综合场景测试 > 应该正确处理墩压炸弹的场景
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 边界情况测试 > 应该正确处理空手牌
 ✓ tests/playCardRegression.test.ts > 打牌出牌回归测试 > 边界情况测试 > 应该正确处理无法压过的情况
stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': 'Mock LLM strategy', '是否使用LLM': true }

stdout | tests/chatService.test.ts > 聊天服务 > triggerRandomChat > 应该根据概率触发随机闲聊
[ChatService] 调用策略生成随机闲聊，策略: llm
[ChatService] ✅ 收到聊天消息: 随机闲聊

stdout | tests/chatService.test.ts > 聊天服务 > triggerEventChat > 应该触发大墩事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerEventChat > 应该触发分牌被捡走事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 对骂内容

stdout | tests/chatService.test.ts > 聊天服务 > triggerEventChat > 应该触发好牌事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerBigDunReaction > 应该为大墩触发其他玩家的反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerScoreStolenReaction > 应该触发分牌被捡走反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 对骂内容

stdout | tests/chatService.test.ts > 聊天服务 > triggerGoodPlayReaction > 应该触发好牌反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发坏运气反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发获胜反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发失败反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发第一个出完反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发最后一个出完反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在形成炸弹时触发聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在形成墩时触发聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在抓到超大牌时触发聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在手牌质量差时触发聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该优先检测炸弹/墩而不是超大牌
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

 ✓ tests/chatService.test.ts > 聊天服务 > 消息管理 > 应该能够添加聊天消息
 ✓ tests/chatService.test.ts > 聊天服务 > 消息管理 > 应该能够获取所有聊天消息
 ✓ tests/chatService.test.ts > 聊天服务 > 消息管理 > 应该能够清空聊天消息
 ✓ tests/chatService.test.ts > 聊天服务 > 消息管理 > 应该限制消息数量在配置的最大值以内
 ✓ tests/chatService.test.ts > 聊天服务 > createChatMessage > 应该创建正确的聊天消息
 ✓ tests/chatService.test.ts > 聊天服务 > triggerRandomChat > 应该根据概率触发随机闲聊
 ✓ tests/chatService.test.ts > 聊天服务 > triggerRandomChat > 应该根据概率不触发随机闲聊
 ✓ tests/chatService.test.ts > 聊天服务 > triggerEventChat > 应该触发大墩事件聊天
 ✓ tests/chatService.test.ts > 聊天服务 > triggerEventChat > 应该触发分牌被捡走事件聊天
 ✓ tests/chatService.test.ts > 聊天服务 > triggerEventChat > 应该触发好牌事件聊天
 ✓ tests/chatService.test.ts > 聊天服务 > triggerBigDunReaction > 应该为大墩触发其他玩家的反应
 ✓ tests/chatService.test.ts > 聊天服务 > triggerBigDunReaction > 不应该为小墩触发反应
 ✓ tests/chatService.test.ts > 聊天服务 > triggerScoreStolenReaction > 应该触发分牌被捡走反应
 ✓ tests/chatService.test.ts > 聊天服务 > triggerScoreStolenReaction > 不应该在没有分牌被捡走时触发
 ✓ tests/chatService.test.ts > 聊天服务 > triggerGoodPlayReaction > 应该触发好牌反应
 ✓ tests/chatService.test.ts > 聊天服务 > triggerTaunt > 应该触发对骂
 ✓ tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发坏运气反应
 ✓ tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发获胜反应
 ✓ tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发失败反应
 ✓ tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发第一个出完反应
 ✓ tests/chatService.test.ts > 聊天服务 > 其他事件反应函数 > 应该触发最后一个出完反应
 ✓ tests/chatService.test.ts > 聊天服务 > ChatService类方法 > 应该能够获取最新消息
 ✓ tests/chatService.test.ts > 聊天服务 > ChatService类方法 > 应该能够获取消息数量
 ✓ tests/chatService.test.ts > 聊天服务 > ChatService类方法 > 应该能够更新配置
 ✓ tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在形成炸弹时触发聊天
 ✓ tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在形成墩时触发聊天
 ✓ tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在抓到超大牌时触发聊天
 ✓ tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该在手牌质量差时触发聊天
 ✓ tests/chatService.test.ts > 聊天服务 > triggerSortingReaction - 理牌聊天触发 > 应该优先检测炸弹/墩而不是超大牌
stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

 ✓ tests/round.test.ts > Round 类单元测试 > 创建和初始化 > 应该正确创建新轮次
 ✓ tests/round.test.ts > Round 类单元测试 > 创建和初始化 > 应该正确设置轮次编号
 ✓ tests/round.test.ts > Round 类单元测试 > 创建和初始化 > 应该正确设置开始时间
 ✓ tests/round.test.ts > Round 类单元测试 > 时间控制 > 应该正确配置时间参数
 ✓ tests/round.test.ts > Round 类单元测试 > 时间控制 > 应该允许立即出牌（如果距离上次出牌时间足够）
 ✓ tests/round.test.ts > Round 类单元测试 > 时间控制 > 应该要求等待最短间隔
stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

 ✓ tests/round.test.ts > Round 类单元测试 > 时间控制 > 应该正确等待最短间隔
stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/scoringService.test.ts > scoringService - 出牌时计分 > handleDunScoring > 应该正确处理墩的计分
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 玩家1 事件: dun_played
[LLMChatStrategy] 生成的Prompt长度: 870

stdout | tests/scoringService.test.ts > scoringService - 游戏结束计分 > calculateFinalRankings > 应该正确计算最终排名和分数
[calculateFinalRankings] 排序后的玩家顺序（按手牌数，然后按finishOrder）: {
  rankings: [
    {
      rank: 1,
      playerId: 0,
      playerName: '玩家1',
      handCount: 0,
      finishOrderIndex: 0,
      score: 50
    },
    {
      rank: 2,
      playerId: 1,
      playerName: '玩家2',
      handCount: 0,
      finishOrderIndex: 1,
      score: 30
    },
    {
      rank: 3,
      playerId: 2,
      playerName: '玩家3',
      handCount: 0,
      finishOrderIndex: 2,
      score: 10
    }
  ],
  finishOrder: [ 0, 1, 2 ]
}
[calculateFinalRankings] 应用最终规则前: {
  firstPlayer: { id: 0, name: '玩家1', score: 50, handCount: 0 },
  lastPlayer: { id: 2, name: '玩家3', score: 10, handCount: 0 },
  isSamePlayer: false
}
[calculateFinalRankings] 应用最终规则后: {
  firstPlayer: { id: 0, name: '玩家1', score: 80, adjustment: '+30' },
  lastPlayer: { id: 2, name: '玩家3', score: -20, adjustment: '-30' },
  totalAdjustment: 0
}

stderr | tests/scoringService.test.ts > scoringService - 游戏结束计分 > calculateFinalRankings > 应该正确计算最终排名和分数
[ScoreValidation] ⚠️ 分数总和不为0！总和=90 {
  totalScore: 90,
  playerCount: 3,
  finishOrderLength: 3,
  finishOrder: [ 0, 1, 2 ],
  missingInRankings: [],
  missingInFinishOrder: [],
  playerDetails: [
    {
      name: '玩家1',
      id: 0,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 50,
      finalRuleAdjustment: 30,
      finalScore: 80,
      handCount: 0,
      finishOrder: 0,
      otherScoreSources: 150
    },
    {
      name: '玩家2',
      id: 1,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 30,
      finalRuleAdjustment: 0,
      finalScore: 30,
      handCount: 0,
      finishOrder: 1,
      otherScoreSources: 130
    },
    {
      name: '玩家3',
      id: 2,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 10,
      finalRuleAdjustment: -30,
      finalScore: -20,
      handCount: 0,
      finishOrder: 2,
      otherScoreSources: 110
    }
  ],
  summary: {
    totalInitialScore: -300,
    totalRoundScore: 0,
    totalFinalRuleAdjustment: 0,
    totalOtherScoreSources: 390,
    totalFinalScore: 90,
    expectedTotal: 0
  },
  allRoundsInfo: [
    { playerName: '玩家1', roundsWon: [] },
    { playerName: '玩家2', roundsWon: [] },
    { playerName: '玩家3', roundsWon: [] }
  ]
}

stdout | tests/scoringService.test.ts > scoringService - 游戏结束计分 > calculateFinalRankings > 应该正确处理最后一名未出的分牌给第二名
[calculateFinalRankings] 排序后的玩家顺序（按手牌数，然后按finishOrder）: {
  rankings: [
    {
      rank: 1,
      playerId: 0,
      playerName: '玩家1',
      handCount: 0,
      finishOrderIndex: 0,
      score: 50
    },
    {
      rank: 2,
      playerId: 1,
      playerName: '玩家2',
      handCount: 0,
      finishOrderIndex: 1,
      score: 30
    },
    {
      rank: 3,
      playerId: 2,
      playerName: '玩家3',
      handCount: 2,
      finishOrderIndex: 2,
      score: 10
    }
  ],
  finishOrder: [ 0, 1, 2 ]
}
[calculateFinalRankings] 应用最终规则前: {
  firstPlayer: { id: 0, name: '玩家1', score: 50, handCount: 0 },
  lastPlayer: { id: 2, name: '玩家3', score: 10, handCount: 2 },
  isSamePlayer: false
}
[calculateFinalRankings] 应用最终规则后: {
  firstPlayer: { id: 0, name: '玩家1', score: 80, adjustment: '+30' },
  lastPlayer: { id: 2, name: '玩家3', score: -20, adjustment: '-30' },
  totalAdjustment: 0
}
[calculateFinalRankings] 最后一名(玩家3)还有20分未出，但已经在 GameController 中处理过了（已转移给第二名），跳过

stderr | tests/scoringService.test.ts > scoringService - 游戏结束计分 > calculateFinalRankings > 应该正确处理最后一名未出的分牌给第二名
[ScoreValidation] ⚠️ 分数总和不为0！总和=90 {
  totalScore: 90,
  playerCount: 3,
  finishOrderLength: 3,
  finishOrder: [ 0, 1, 2 ],
  missingInRankings: [],
  missingInFinishOrder: [],
  playerDetails: [
    {
      name: '玩家1',
      id: 0,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 50,
      finalRuleAdjustment: 30,
      finalScore: 80,
      handCount: 0,
      finishOrder: 0,
      otherScoreSources: 150
    },
    {
      name: '玩家2',
      id: 1,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 30,
      finalRuleAdjustment: 0,
      finalScore: 30,
      handCount: 0,
      finishOrder: 1,
      otherScoreSources: 130
    },
    {
      name: '玩家3',
      id: 2,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 10,
      finalRuleAdjustment: -30,
      finalScore: -20,
      handCount: 2,
      finishOrder: 2,
      otherScoreSources: 110
    }
  ],
  summary: {
    totalInitialScore: -300,
    totalRoundScore: 0,
    totalFinalRuleAdjustment: 0,
    totalOtherScoreSources: 390,
    totalFinalScore: 90,
    expectedTotal: 0
  },
  allRoundsInfo: [
    { playerName: '玩家1', roundsWon: [] },
    { playerName: '玩家2', roundsWon: [] },
    { playerName: '玩家3', roundsWon: [] }
  ]
}

stdout | tests/scoringService.test.ts > scoringService - 游戏结束计分 > applyFinalGameRules > 应该正确应用最终规则并更新玩家分数
[calculateFinalRankings] 排序后的玩家顺序（按手牌数，然后按finishOrder）: {
  rankings: [
    {
      rank: 1,
      playerId: 0,
      playerName: '玩家1',
      handCount: 0,
      finishOrderIndex: 0,
      score: 50
    },
    {
      rank: 2,
      playerId: 1,
      playerName: '玩家2',
      handCount: 0,
      finishOrderIndex: 1,
      score: 30
    },
    {
      rank: 3,
      playerId: 2,
      playerName: '玩家3',
      handCount: 0,
      finishOrderIndex: 2,
      score: 10
    }
  ],
  finishOrder: [ 0, 1, 2 ]
}
[calculateFinalRankings] 应用最终规则前: {
  firstPlayer: { id: 0, name: '玩家1', score: 50, handCount: 0 },
  lastPlayer: { id: 2, name: '玩家3', score: 10, handCount: 0 },
  isSamePlayer: false
}
[calculateFinalRankings] 应用最终规则后: {
  firstPlayer: { id: 0, name: '玩家1', score: 80, adjustment: '+30' },
  lastPlayer: { id: 2, name: '玩家3', score: -20, adjustment: '-30' },
  totalAdjustment: 0
}

stderr | tests/scoringService.test.ts > scoringService - 游戏结束计分 > applyFinalGameRules > 应该正确应用最终规则并更新玩家分数
[ScoreValidation] ⚠️ 分数总和不为0！总和=90 {
  totalScore: 90,
  playerCount: 3,
  finishOrderLength: 3,
  finishOrder: [ 0, 1, 2 ],
  missingInRankings: [],
  missingInFinishOrder: [],
  playerDetails: [
    {
      name: '玩家1',
      id: 0,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 50,
      finalRuleAdjustment: 30,
      finalScore: 80,
      handCount: 0,
      finishOrder: 0,
      otherScoreSources: 150
    },
    {
      name: '玩家2',
      id: 1,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 30,
      finalRuleAdjustment: 0,
      finalScore: 30,
      handCount: 0,
      finishOrder: 1,
      otherScoreSources: 130
    },
    {
      name: '玩家3',
      id: 2,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 10,
      finalRuleAdjustment: -30,
      finalScore: -20,
      handCount: 0,
      finishOrder: 2,
      otherScoreSources: 110
    }
  ],
  summary: {
    totalInitialScore: -300,
    totalRoundScore: 0,
    totalFinalRuleAdjustment: 0,
    totalOtherScoreSources: 390,
    totalFinalScore: 90,
    expectedTotal: 0
  },
  allRoundsInfo: [
    { playerName: '玩家1', roundsWon: [] },
    { playerName: '玩家2', roundsWon: [] },
    { playerName: '玩家3', roundsWon: [] }
  ]
}

 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > isScoreCard > 应该正确识别5为分牌
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > isScoreCard > 应该正确识别10为分牌
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > isScoreCard > 应该正确识别K为分牌
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > isScoreCard > 应该正确识别非分牌
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > getCardScore > 应该正确计算5的分值
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > getCardScore > 应该正确计算10的分值
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > getCardScore > 应该正确计算K的分值
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > getCardScore > 应该正确计算非分牌的分值
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateCardsScore > 应该正确计算一组牌的总分值
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateCardsScore > 应该正确处理空数组
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateCardsScore > 应该正确处理只有非分牌的情况
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunCount > 应该正确计算7张=1墩
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunCount > 应该正确计算8张=2墩
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunCount > 应该正确计算9张=4墩
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunCount > 应该正确计算10张=8墩
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunCount > 应该正确计算11张=16墩
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunCount > 少于7张应该返回0
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunScore > 5人游戏，1墩：出墩玩家+120分，其他玩家各-30分
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunScore > 5人游戏，2墩：出墩玩家+240分，其他玩家各-60分
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunScore > 5人游戏，4墩：出墩玩家+480分，其他玩家各-120分
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunScore > 4人游戏，1墩：出墩玩家+90分，其他玩家各-30分
 ✓ tests/scoringService.test.ts > scoringService - 基础计分功能 > calculateDunScore > 0墩应该返回0分
 ✓ tests/scoringService.test.ts > scoringService - 出牌时计分 > handleDunScoring > 应该正确处理墩的计分
 ✓ tests/scoringService.test.ts > scoringService - 出牌时计分 > handleDunScoring > 非墩的牌不应该触发墩的计分
 ✓ tests/scoringService.test.ts > scoringService - 出牌时计分 > updatePlayerAfterPlay > 应该正确更新玩家手牌和分数
 ✓ tests/scoringService.test.ts > scoringService - 游戏结束计分 > initializePlayerScores > 应该将所有玩家的初始分数设置为-100
 ✓ tests/scoringService.test.ts > scoringService - 游戏结束计分 > calculateFinalRankings > 应该正确计算最终排名和分数
 ✓ tests/scoringService.test.ts > scoringService - 游戏结束计分 > calculateFinalRankings > 应该正确处理最后一名未出的分牌给第二名
 × tests/scoringService.test.ts > scoringService - 游戏结束计分 > applyFinalGameRules > 应该正确应用最终规则并更新玩家分数
   → expected undefined not to be undefined
stdout | LLMChatStrategy.checkAvailableModels (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:405:17)
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]

stdout | LLMChatStrategy.callLLMAPI (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:439:13)
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 870
}

stdout | LLMChatStrategy.callLLMAPI (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:477:15)
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：玩家1\\n玩家类型：AI\\n手牌数量：0张\\n手牌详情：无\\n当前得分：-100分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：出墩\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > GameController 类测试 > 应该正确分配轮次分数
[allocateRoundScore] 轮次1结束，玩家1获得25分（从-100变为-75）

stdout | tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > playManager 模块测试 > 应该正确处理墩的计分
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 玩家1 事件: dun_played
[LLMChatStrategy] 生成的Prompt长度: 870

 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌组创建和洗牌 > 应该创建包含54张牌的完整牌组
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌组创建和洗牌 > 洗牌应该改变牌的顺序
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌组创建和洗牌 > 发牌应该给每个玩家相同数量的牌（4人游戏）
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 分牌识别 > 应该正确识别分牌（5、10、K）
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 分牌识别 > 应该正确计算单张牌的分值
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 分牌识别 > 应该正确计算一组牌的总分值
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型识别 > 应该正确识别单张
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型识别 > 应该正确识别对子
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型识别 > 应该正确识别三张
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型识别 > 应该正确识别炸弹（4张）
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型识别 > 应该正确识别炸弹（5张）
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型识别 > 应该正确识别墩（7张）
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型识别 > 应该拒绝不合法的牌型
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型比较 > 应该正确比较单张牌的大小
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型比较 > 应该正确处理炸弹压过普通牌型
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型比较 > 应该正确处理更大的炸弹压过小炸弹
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 牌型比较 > 应该正确处理墩压过所有牌型
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 墩的计算 > 应该正确计算墩的数量
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > cardUtils 模块测试 > 墩的计算 > 应该正确计算墩的分数（4人游戏）
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > Round 类测试 > 应该正确创建新轮次
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > Round 类测试 > 应该正确记录出牌
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > Round 类测试 > 应该正确计算轮次总分
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > Round 类测试 > 应该正确结束轮次
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > GameController 类测试 > 应该正确初始化游戏
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > GameController 类测试 > 应该正确分配轮次分数
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > playManager 模块测试 > 应该正确处理墩的计分
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > playManager 模块测试 > 应该正确更新玩家出牌后的手牌
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > Game 类集成测试 > 应该正确初始化游戏
 ✓ tests/comprehensiveUnitTests.test.ts > 完整单元测试套件 > Game 类集成测试 > 应该正确创建新轮次
stdout | LLMChatStrategy.checkAvailableModels (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:405:17)
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]

stdout | LLMChatStrategy.callLLMAPI (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:439:13)
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 870
}

stdout | LLMChatStrategy.callLLMAPI (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:477:15)
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：玩家1\\n玩家类型：AI\\n手牌数量：0张\\n手牌详情：无\\n当前得分：-100分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：出墩\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

stdout | tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理一轮完整的出牌流程

📋 测试：完整轮次流程

stdout | tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理一轮完整的出牌流程
  ✅ 玩家0出牌完成

stdout | tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理一轮完整的出牌流程
  ✅ 玩家1出牌完成
  ✅ 玩家2、3要不起
  ✅ 轮次应该结束
  ✅ 轮次结束，返回轮次信息正确（分数由 GameController 分配）


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理有分牌的轮次

📋 测试：有分牌的轮次流程

 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理一轮完整的出牌流程
stdout | tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理有分牌的轮次
  ✅ 玩家0出牌，轮次分数: 5

stdout | tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理有分牌的轮次
  ✅ 玩家1出牌，轮次分数: 15
  ✅ 轮次结束，返回轮次分数 15，接风玩家 1（分数由 GameController 分配）


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 接风流程 > 应该正确处理接风情况

📋 测试：接风流程

 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 完整轮次流程 > 应该正确处理有分牌的轮次
stdout | tests/roundRegression.test.ts > Round 类回归测试 > 接风流程 > 应该正确处理接风情况
  ✅ 接风判断逻辑正常


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 时间控制流程 > 应该正确控制出牌间隔

📋 测试：时间控制

 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 接风流程 > 应该正确处理接风情况
stdout | tests/roundRegression.test.ts > Round 类回归测试 > 时间控制流程 > 应该正确控制出牌间隔
  需要等待 50ms 后才能出牌

stdout | tests/roundRegression.test.ts > Round 类回归测试 > 时间控制流程 > 应该正确控制出牌间隔
  ✅ 出牌间隔控制正常: 第一次 11ms, 第二次 11ms


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 时间控制流程 > 应该正确触发超时

📋 测试：超时机制

 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 时间控制流程 > 应该正确控制出牌间隔
stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 分数分配回归测试 > 轮次分数应该正确分配给获胜玩家
[allocateRoundScore] 轮次1结束，玩家1获得25分（从-100变为-75）

stdout | tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 分数分配回归测试 > 墩的分数应该正确分配给所有玩家
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 玩家1 事件: dun_played
[LLMChatStrategy] 生成的Prompt长度: 870

 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 发牌随机性回归测试 > 发牌应该是随机的，不应该每次都一样
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 发牌随机性回归测试 > 发牌后不应该自动排序（保持随机顺序）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 发牌随机性回归测试 > 多次发牌应该产生不同的结果
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 牌型识别回归测试 > 应该正确识别所有合法牌型（不会误判）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 牌型识别回归测试 > 应该拒绝不合法的牌型组合（不会误接受）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 牌型比较回归测试 > 应该正确比较牌的大小（不会出现错误的大小关系）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 牌型比较回归测试 > 应该正确处理炸弹压过普通牌型（不会出现炸弹被普通牌压过）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 牌型比较回归测试 > 应该正确处理更大的炸弹压过小炸弹（不会出现小炸弹压过大炸弹）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 牌型比较回归测试 > 应该正确处理墩压过所有牌型（不会出现其他牌型压过墩）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 分数计算回归测试 > 应该正确计算分牌的分值（不会出现计算错误）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 分数计算回归测试 > 应该正确计算墩的数量（不会出现计算错误）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 分数计算回归测试 > 应该正确计算墩的分数（不会出现分配错误）
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 游戏状态回归测试 > 游戏初始化后应该处于正确的状态
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 游戏状态回归测试 > 轮次应该正确创建和结束
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 分数分配回归测试 > 轮次分数应该正确分配给获胜玩家
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 分数分配回归测试 > 墩的分数应该正确分配给所有玩家
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 边界情况回归测试 > 空手牌应该正确处理
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 边界情况回归测试 > 只有一张牌时应该能出牌
 ✓ tests/comprehensiveRegressionTests.test.ts > 完整回归测试套件 > 边界情况回归测试 > 最大墩数应该正确处理
stdout | LLMChatStrategy.checkAvailableModels (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:405:17)
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]

stdout | LLMChatStrategy.callLLMAPI (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:439:13)
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 870
}

stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/integrationTests.test.ts > 集成测试套件 > Game + Round + GameController 集成 > 应该正确处理轮次结束和分数分配
[allocateRoundScore] 轮次1结束，玩家1获得5分（从-100变为-95）

stdout | tests/integrationTests.test.ts > 集成测试套件 > 异步出牌处理集成 > 应该正确处理异步出牌流程
[SystemAnnouncement] announcePlay 被调用 { playType: 'single', text: 'K', hasVoiceConfig: false, cardsCount: 1 }
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'K',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: K... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "K..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "K..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-YunxiNeural

stderr | tests/integrationTests.test.ts > 集成测试套件 > 异步出牌处理集成 > 应该正确处理异步出牌流程
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用

 ✓ tests/integrationTests.test.ts > 集成测试套件 > Game + Round + GameController 集成 > 应该完成完整的游戏初始化流程
 ✓ tests/integrationTests.test.ts > 集成测试套件 > Game + Round + GameController 集成 > 应该正确处理轮次创建和出牌流程
 ✓ tests/integrationTests.test.ts > 集成测试套件 > Game + Round + GameController 集成 > 应该正确处理轮次结束和分数分配
 ✓ tests/integrationTests.test.ts > 集成测试套件 > RoundScheduler + Game 集成 > 应该正确创建调度器并管理出牌顺序
 ✓ tests/integrationTests.test.ts > 集成测试套件 > 完整游戏流程集成测试 > 应该能够完成一轮完整的游戏流程
stderr | tests/integrationTests.test.ts > 集成测试套件 > 异步出牌处理集成 > 应该正确处理异步出牌流程
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at AzureSpeechTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:101:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 报牌播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:434:14)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/integrationTests.test.ts > 集成测试套件 > 异步出牌处理集成 > 应该正确处理异步出牌流程
[TTSServiceManager] ✅ 提供者 azure 成功生成音频: 9.56 KB
[TTSAudioService] ✅ 📢报牌场景 - TTS服务返回音频: 9.56 KB (provider: azure)
[TTSAudioService] TTS服务返回音频: 9.56 KB
[TTSAudioService] 💾 已缓存音频: K... (provider: azure, channel: 8)
[TTSAudioService] TTS服务音频生成成功: K... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "K..." (时长: 1.00s, 采样率: 44100Hz, 声道: 报牌（中央）)
[TTSAudioService] 调用 onStart 回调 (声道: 报牌（中央）)
[SystemAnnouncement] 报牌语音开始播放: K
[TTSAudioService] 🎯 报牌请求：使用独立报牌通道，与聊天通道隔离
[TTSAudioService] 声道 报牌（中央） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '报牌（中央）',
  segGain: 1.2,
  roleGain: 1.2,
  panner: 0,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

 × tests/round.test.ts > Round 类单元测试 > 时间控制 > 应该正确开始和清除超时计时器 5005ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 ✓ tests/round.test.ts > Round 类单元测试 > 时间控制 > 应该正确获取已等待时间
 ✓ tests/round.test.ts > Round 类单元测试 > 出牌记录 > 应该正确记录出牌
 ✓ tests/round.test.ts > Round 类单元测试 > 出牌记录 > 应该正确累加分牌分数
 ✓ tests/round.test.ts > Round 类单元测试 > 出牌记录 > 应该正确记录要不起
 ✓ tests/round.test.ts > Round 类单元测试 > 出牌记录 > 已结束的轮次不应该允许记录出牌
 ✓ tests/round.test.ts > Round 类单元测试 > 接风判断 > 应该正确判断接风状态
 ✓ tests/round.test.ts > Round 类单元测试 > 轮次结束判断 > 应该正确判断轮次是否应该结束
 ✓ tests/round.test.ts > Round 类单元测试 > 结束轮次 > 应该正确结束轮次并返回轮次信息（不分配分数）
 ✓ tests/round.test.ts > Round 类单元测试 > 结束轮次 > 应该正确生成轮次记录
 ✓ tests/round.test.ts > Round 类单元测试 > 结束轮次 > 已结束的轮次不应该再次结束
 ✓ tests/round.test.ts > Round 类单元测试 > 异步出牌处理 > 应该正确检查是否有正在处理的出牌
 ✓ tests/round.test.ts > Round 类单元测试 > 异步出牌处理 > 应该正确处理异步出牌
 ✓ tests/round.test.ts > Round 类单元测试 > 异步出牌处理 > 应该正确处理异步出牌失败
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 基本渲染 > 应该渲染空状态
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 基本渲染 > 应该渲染分组手牌
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 基本渲染 > 应该按点数排序显示
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 紧凑模式显示 > 应该显示叠放卡片
 × tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 紧凑模式显示 > 应该显示数量徽章（多张牌时）
   → expected null to be truthy
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 紧凑模式显示 > 不应该显示数量徽章（单张牌时）
 ✓ tests/round.test.ts > Round 类单元测试 > 异步出牌处理 > 应该等待正在处理的出牌完成
 ✓ tests/round.test.ts > Round 类单元测试 > 统计信息 > 应该正确获取轮次统计信息
 ✓ tests/round.test.ts > Round 类单元测试 > 克隆和序列化 > 应该正确克隆轮次
 ✓ tests/round.test.ts > Round 类单元测试 > 克隆和序列化 > 应该正确转换为记录
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 展开/收起功能 > 应该能够展开卡片组 331ms
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 展开/收起功能 > 应该能够收起卡片组 322ms
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 展开/收起功能 > 展开时应该显示所有卡片 324ms
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 展开/收起功能 > 展开时应该显示点数标签和数量 337ms
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 卡片选择 > 应该能够点击卡片选择
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 卡片选择 > 应该显示选中状态
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 卡片选择 > 应该显示选中指示器（紧凑模式）
stdout | tests/roundRegression.test.ts > Round 类回归测试 > 异步处理流程 > 应该按顺序处理多个异步出牌

📋 测试：异步处理顺序

 × tests/roundRegression.test.ts > Round 类回归测试 > 时间控制流程 > 应该正确触发超时 5005ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 卡片选择 > 应该显示选中数量（展开模式） 314ms
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 卡片选择 > 选中卡片应该有has-selected类
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 悬停效果 > 悬停时应该添加hovered类
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 回调函数 > 应该调用onToggleExpand回调
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 回调函数 > onToggleExpand应该是可选的
stdout | tests/roundRegression.test.ts > Round 类回归测试 > 异步处理流程 > 应该按顺序处理多个异步出牌
  ✅ 异步处理顺序正确: 1 -> 2 -> 3 -> 4 


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 轮次结束场景 > 应该正确处理所有人都要不起的情况

📋 测试：所有人都要不起
  ✅ 所有人都要不起，轮次正确结束（分数由 GameController 分配）


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 轮次结束场景 > 应该正确处理有人出完牌的情况

📋 测试：有人出完牌
  ✅ 玩家出完牌，轮次正确结束（分数由 GameController 分配）


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 多轮次场景 > 应该正确处理连续多轮

📋 测试：连续多轮
  第1轮: 获胜者=玩家1, 分数=5
  第2轮: 获胜者=玩家1, 分数=5
  第3轮: 获胜者=玩家1, 分数=5
  ✅ 连续多轮处理正确


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 边界情况 > 应该正确处理空轮次（没有人出牌）

📋 测试：空轮次
  ✅ 空轮次处理正确


stdout | tests/roundRegression.test.ts > Round 类回归测试 > 边界情况 > 应该正确处理没有分牌的轮次

📋 测试：没有分牌的轮次
  ✅ 没有分牌的轮次处理正确（分数由 GameController 分配）


 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 异步处理流程 > 应该按顺序处理多个异步出牌
 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 轮次结束场景 > 应该正确处理所有人都要不起的情况
 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 轮次结束场景 > 应该正确处理有人出完牌的情况
 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 多轮次场景 > 应该正确处理连续多轮
 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 边界情况 > 应该正确处理空轮次（没有人出牌）
 ✓ tests/roundRegression.test.ts > Round 类回归测试 > 边界情况 > 应该正确处理没有分牌的轮次
stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 不同玩家数的墩计分测试 > 应该正确处理4人游戏的墩计分
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 玩家1 事件: dun_played
[LLMChatStrategy] 生成的Prompt长度: 870

stdout | tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 不同玩家数的墩计分测试 > 应该正确处理8人游戏的墩计分
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 玩家1 事件: dun_played
[LLMChatStrategy] 生成的Prompt长度: 870

stdout | tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 边界情况测试 > 应该正确处理最后一名没有未出分牌的情况
[calculateFinalRankings] 排序后的玩家顺序（按手牌数，然后按finishOrder）: {
  rankings: [
    {
      rank: 1,
      playerId: 0,
      playerName: '玩家1',
      handCount: 0,
      finishOrderIndex: 0,
      score: 50
    },
    {
      rank: 2,
      playerId: 1,
      playerName: '玩家2',
      handCount: 0,
      finishOrderIndex: 1,
      score: 30
    },
    {
      rank: 3,
      playerId: 2,
      playerName: '玩家3',
      handCount: 0,
      finishOrderIndex: 2,
      score: 10
    }
  ],
  finishOrder: [ 0, 1, 2 ]
}
[calculateFinalRankings] 应用最终规则前: {
  firstPlayer: { id: 0, name: '玩家1', score: 50, handCount: 0 },
  lastPlayer: { id: 2, name: '玩家3', score: 10, handCount: 0 },
  isSamePlayer: false
}
[calculateFinalRankings] 应用最终规则后: {
  firstPlayer: { id: 0, name: '玩家1', score: 80, adjustment: '+30' },
  lastPlayer: { id: 2, name: '玩家3', score: -20, adjustment: '-30' },
  totalAdjustment: 0
}

stderr | tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 边界情况测试 > 应该正确处理最后一名没有未出分牌的情况
[ScoreValidation] ⚠️ 分数总和不为0！总和=90 {
  totalScore: 90,
  playerCount: 3,
  finishOrderLength: 3,
  finishOrder: [ 0, 1, 2 ],
  missingInRankings: [],
  missingInFinishOrder: [],
  playerDetails: [
    {
      name: '玩家1',
      id: 0,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 50,
      finalRuleAdjustment: 30,
      finalScore: 80,
      handCount: 0,
      finishOrder: 0,
      otherScoreSources: 150
    },
    {
      name: '玩家2',
      id: 1,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 30,
      finalRuleAdjustment: 0,
      finalScore: 30,
      handCount: 0,
      finishOrder: 1,
      otherScoreSources: 130
    },
    {
      name: '玩家3',
      id: 2,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: 10,
      finalRuleAdjustment: -30,
      finalScore: -20,
      handCount: 0,
      finishOrder: 2,
      otherScoreSources: 110
    }
  ],
  summary: {
    totalInitialScore: -300,
    totalRoundScore: 0,
    totalFinalRuleAdjustment: 0,
    totalOtherScoreSources: 390,
    totalFinalScore: 90,
    expectedTotal: 0
  },
  allRoundsInfo: [
    { playerName: '玩家1', roundsWon: [] },
    { playerName: '玩家2', roundsWon: [] },
    { playerName: '玩家3', roundsWon: [] }
  ]
}

 ✓ tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 不同玩家数的墩计分测试 > 应该正确处理4人游戏的墩计分
 ✓ tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 不同玩家数的墩计分测试 > 应该正确处理8人游戏的墩计分
 ✓ tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 边界情况测试 > 应该正确处理最后一名没有未出分牌的情况
 ✓ tests/scoringServiceRegression.test.ts > scoringService - 回归测试 > 分牌计算准确性测试 > 应该正确计算各种分牌组合
stdout | LLMChatStrategy.checkAvailableModels (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:405:17)
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]

stdout | LLMChatStrategy.callLLMAPI (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:439:13)
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 870
}
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 870
}

stdout | LLMChatStrategy.callLLMAPI (/home/jin/guozha_poker_game/src/chat/strategy/LLMChatStrategy.ts:477:15)
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：玩家1\\n玩家类型：AI\\n手牌数量：0张\\n手牌详情：无\\n当前得分：-100分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：出墩\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：玩家1\\n玩家类型：AI\\n手牌数量：0张\\n手牌详情：无\\n当前得分：-100分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：出墩\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 多组卡片 > 应该能够同时展开多个组 627ms
 ✓ tests/compactHandCards.test.tsx > 紧凑型手牌组件测试 > 多组卡片 > 应该独立管理每组的展开状态 644ms
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 基本渲染 > 应该渲染关闭状态的按钮
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 基本渲染 > 按钮应该有正确的样式类
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 基本渲染 > 点击按钮应该打开指南
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 基本渲染 > 打开后应该显示指南容器
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 标签页切换 > 应该显示所有标签页按钮
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 标签页切换 > 应该默认显示教程标签页
 ✓ tests/cardUtils.test.ts > cardUtils > createDeck > 应该创建包含54张牌的完整牌组（包括大小王）
 ✓ tests/cardUtils.test.ts > cardUtils > shuffleDeck > 应该洗牌并改变顺序
 ✓ tests/cardUtils.test.ts > cardUtils > shuffleDeck > 应该保持所有牌都在
 ✓ tests/cardUtils.test.ts > cardUtils > dealCards > 应该为每个玩家发一副完整的牌
 ✓ tests/cardUtils.test.ts > cardUtils > dealCards > 应该为不同玩家发不同的牌
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该识别单张
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该识别对子
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该识别三张
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该识别炸弹（4张）
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该识别炸弹（5张）
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该识别炸弹（6张）
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该识别墩（7张及以上）
 ✓ tests/cardUtils.test.ts > cardUtils > getCardType > 应该拒绝不合法的牌型
 ✓ tests/cardUtils.test.ts > cardUtils > 大小王特殊规则 > 4张以下的小王应该只能单独出
 ✓ tests/cardUtils.test.ts > cardUtils > 大小王特殊规则 > 4张以下的大小王混合应该被拒绝
 ✓ tests/cardUtils.test.ts > cardUtils > 大小王特殊规则 > 4张及以上大小王可以一起出作为炸弹
 ✓ tests/cardUtils.test.ts > cardUtils > 大小王特殊规则 > 7张及以上大小王可以一起出作为墩
 ✓ tests/cardUtils.test.ts > cardUtils > canBeat > 没有上家出牌时，可以出任何牌
 ✓ tests/cardUtils.test.ts > cardUtils > canBeat > 炸弹可以压过单张
 ✓ tests/cardUtils.test.ts > cardUtils > canBeat > 墩可以压过炸弹
 ✓ tests/cardUtils.test.ts > cardUtils > canBeat > 同类型牌型，值大的可以压过值小的
 ✓ tests/cardUtils.test.ts > cardUtils > canBeat > 同类型炸弹，数量多的可以压过数量少的
 ✓ tests/cardUtils.test.ts > cardUtils > sortCards > 应该按rank排序
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 没有上家出牌时，应该返回true（可以出任何牌）
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 空手牌时，应该返回false
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 有能打过的牌时，应该返回true
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 没有能打过的牌时，应该返回false
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 有炸弹可以压过单张时，应该返回true
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 有对子可以压过单张时，应该返回true
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 只有相同rank但更小的牌时，应该返回false
 ✓ tests/cardUtils.test.ts > cardUtils > hasPlayableCards - 强制出牌规则 > 有墩可以压过炸弹时，应该返回true
 ✓ tests/cardUtils.test.ts > cardUtils > findPlayableCards > 没有上家出牌时，应该返回所有合法牌型
 ✓ tests/cardUtils.test.ts > cardUtils > findPlayableCards > 有上家出牌时，应该只返回能打过的牌
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 标签页切换 > 应该能够切换到规则标签页
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 标签页切换 > 应该能够切换到计分标签页
stdout | tests/integrationTests.test.ts > 集成测试套件 > 异步出牌处理集成 > 应该正确处理异步出牌流程
<empty line>
stderr | tests/integrationTests.test.ts > 集成测试套件 > 异步出牌处理集成 > 应该正确处理异步出牌流程
测试中的预期错误: expected 'failed' to be 'completed' // Object.is equality

stdout | tests/integrationTests.test.ts > 集成测试套件 > 分数计算和排名集成 > 应该正确计算和分配多轮次的分数
[allocateRoundScore] 轮次1结束，玩家1获得25分（从-100变为-75）
[allocateRoundScore] 轮次2结束，玩家2获得50分（从-100变为-50）
[allocateRoundScore] 轮次3结束，玩家3获得75分（从-100变为-25）

 ✓ tests/integrationTests.test.ts > 集成测试套件 > 异步出牌处理集成 > 应该正确处理异步出牌流程 5059ms
 ✓ tests/integrationTests.test.ts > 集成测试套件 > 分数计算和排名集成 > 应该正确计算和分配多轮次的分数
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 关闭功能 > 点击关闭按钮应该关闭指南
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 关闭功能 > 点击遮罩层应该关闭指南
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 关闭功能 > 点击容器内部不应该关闭指南
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 内容显示 > 教程标签页应该显示教程内容
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 内容显示 > 应该显示教程卡片
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 内容显示 > 应该显示步骤内容
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 内容显示 > 应该显示流程图
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 多语言支持 > 应该使用i18n翻译函数
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 多语言支持 > 应该支持中文翻译
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 多语言支持 > 应该支持英文翻译
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 交互功能 > 标签页切换时应该更新活动状态
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 交互功能 > 应该正确显示步骤编号
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 样式和布局 > 按钮应该有正确的样式类
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 样式和布局 > 打开时应该显示遮罩层
 ✓ tests/gameRulesGuide.test.tsx > 游戏规则指南组件测试 > 样式和布局 > 容器应该有正确的样式类
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 配置系统 > 应该正确构建命名空间
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 配置系统 > 应该正确解析命名空间
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 配置系统 > 应该正确获取资源路径
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 配置系统 > 应该包含默认框架配置
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 翻译管理器 > 应该正确初始化管理器
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 翻译管理器 > 应该正确获取翻译
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 翻译管理器 > 应该检查翻译是否存在
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 翻译管理器 > 应该支持语言切换
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 翻译管理器 > 应该支持语言切换监听器
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 翻译管理器 > 应该正确注册命名空间
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 资源加载器 > 应该正确初始化加载器
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 资源加载器 > 应该正确获取资源路径
 ✓ tests/i18nFramework.test.ts > i18n 框架核心功能 > 资源加载器 > 应该支持清除缓存
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useComponentTranslation > 应该正确返回翻译函数和命名空间
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useComponentTranslation > 应该正确翻译组件文本
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useFeatureTranslation > 应该正确返回翻译函数和命名空间
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useFeatureTranslation > 应该正确翻译功能文本
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useSharedTranslation > 应该正确返回翻译函数和命名空间
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useSharedTranslation > 应该正确翻译共享文本
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useLanguage > 应该正确返回语言信息
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useLanguage > 应该支持语言切换
 ✓ tests/i18nFramework.test.ts > i18n Hooks > useLanguage > 应该包含所有支持的语言
 ✓ tests/i18nFramework.test.ts > i18n 框架集成测试 > 应该正确加载现有翻译资源
 ✓ tests/i18nFramework.test.ts > i18n 框架集成测试 > 应该正确翻译游戏相关文本
 ✓ tests/i18nFramework.test.ts > i18n 框架集成测试 > 应该正确翻译UI配置文本
 ✓ tests/i18nFramework.test.ts > i18n 框架集成测试 > 应该正确翻译共享按钮文本
 ✓ tests/i18nFramework.test.ts > i18n 框架集成测试 > 应该支持多语言切换
 ✓ tests/i18nFramework.test.ts > 命名空间映射验证 > 应该正确映射共享命名空间
 ✓ tests/i18nFramework.test.ts > 命名空间映射验证 > 应该正确映射功能命名空间
 ✓ tests/i18nFramework.test.ts > 命名空间映射验证 > 应该正确映射组件命名空间
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 发牌随机性回归测试 > 发牌应该是随机的，不应该每次都一样
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 发牌随机性回归测试 > 发牌后不应该自动排序（保持随机顺序）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 大小王规则回归测试 > 4张以下大小王混合应该被拒绝（已修复）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 大小王规则回归测试 > 4张及以上大小王混合应该可以一起出（已修复）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 大小王规则回归测试 > 7张及以上大小王混合应该可以一起出作为墩（已修复）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 大小王规则回归测试 > 大小王不应该与普通牌混合（4张以下）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 牌型判断回归测试 > 不应该识别三带一（已移除）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 牌型判断回归测试 > 不应该识别三带二（已移除）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 牌型判断回归测试 > 不应该识别顺子（已移除）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 出牌规则回归测试 > 炸弹应该可以压过单张
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 出牌规则回归测试 > 墩应该可以压过炸弹
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 出牌规则回归测试 > 同类型炸弹，数量多的应该可以压过数量少的
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 发牌数量回归测试 > 4人游戏应该每人发54张牌（每人一副完整牌）
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 发牌数量回归测试 > 5人游戏应该每人发54张牌
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 发牌数量回归测试 > 8人游戏应该每人发54张牌
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 牌ID唯一性回归测试 > 每个玩家的牌ID应该是唯一的
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 边界情况回归测试 > 空数组应该返回null
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 边界情况回归测试 > 单张牌应该可以出
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 边界情况回归测试 > 最大单牌（2）应该可以压过其他单牌
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 轮次记录功能回归测试 > 玩家对象应该支持wonRounds字段
 ✓ tests/regression.test.ts > 回归测试 - 确保已修复的bug不会再次出现 > 轮次记录功能回归测试 > 分牌识别功能应该正常工作
stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stderr | tests/chatReply.test.ts > 聊天回复功能 > chatService.triggerReply > 应该触发回复并添加到消息列表
[ChatService] 当前策略不支持回复功能

stderr | tests/chatReply.test.ts > 聊天回复功能 > chatService.triggerReply > 应该标记回复消息的replyTo字段
[ChatService] 当前策略不支持回复功能

stderr | tests/chatReply.test.ts > 聊天回复功能 > 消息订阅机制 > 应该处理订阅回调中的错误
[ChatService] 消息订阅回调出错: Error: 测试错误
    at /home/jin/guozha_poker_game/tests/chatReply.test.ts:341:15
    at mockCall (file:///home/jin/guozha_poker_game/node_modules/@vitest/spy/dist/index.js:50:17)
    at spy (file:///home/jin/guozha_poker_game/node_modules/tinyspy/dist/index.js:42:80)
    at /home/jin/guozha_poker_game/src/services/chatService.ts:122:9
    at Set.forEach (<anonymous>)
    at ChatService.notifySubscribers (/home/jin/guozha_poker_game/src/services/chatService.ts:120:22)
    at ChatService.addMessage (/home/jin/guozha_poker_game/src/services/chatService.ts:146:10)
    at /home/jin/guozha_poker_game/tests/chatReply.test.ts:358:33
    at Proxy.assertThrows (/home/jin/guozha_poker_game/node_modules/chai/lib/chai/core/assertions.js:2644:7)
    at Proxy.methodWrapper (/home/jin/guozha_poker_game/node_modules/chai/lib/chai/utils/addMethod.js:57:25)

 × tests/chatReply.test.ts > 聊天回复功能 > LLMChatStrategy.generateReply > 应该生成回复消息
   → strategy.generateReply is not a function
 × tests/chatReply.test.ts > 聊天回复功能 > LLMChatStrategy.generateReply > 应该包含原消息信息在回复中
   → strategy.generateReply is not a function
 × tests/chatReply.test.ts > 聊天回复功能 > LLMChatStrategy.generateReply > 应该调用LLM API生成回复
   → strategy.generateReply is not a function
 × tests/chatReply.test.ts > 聊天回复功能 > LLMChatStrategy.generateReply > 应该处理南昌话方言转换
   → strategy.generateReply is not a function
 ✓ tests/chatReply.test.ts > 聊天回复功能 > RuleBasedStrategy.generateReply > 应该生成回复消息
 ✓ tests/chatReply.test.ts > 聊天回复功能 > RuleBasedStrategy.generateReply > 应该包含原消息信息
 ✓ tests/chatReply.test.ts > 聊天回复功能 > RuleBasedStrategy.generateReply > 应该生成不同的回复内容
 × tests/chatReply.test.ts > 聊天回复功能 > chatService.triggerReply > 应该触发回复并添加到消息列表
   → expected null not to be null
 ✓ tests/chatReply.test.ts > 聊天回复功能 > chatService.triggerReply > 应该根据概率决定是否回复
 ✓ tests/chatReply.test.ts > 聊天回复功能 > chatService.triggerReply > 应该标记回复消息的replyTo字段
 ✓ tests/chatReply.test.ts > 聊天回复功能 > 消息订阅机制 > 应该能够订阅消息通知
 ✓ tests/chatReply.test.ts > 聊天回复功能 > 消息订阅机制 > 应该支持多个订阅者
 ✓ tests/chatReply.test.ts > 聊天回复功能 > 消息订阅机制 > 应该处理订阅回调中的错误
 × tests/chatReply.test.ts > 聊天回复功能 > 回复消息的场景标记 > 回复消息应该标记为SPONTANEOUS场景
   → strategy.generateReply is not a function
stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[MultiChannelVoiceService] 使用声道调度器播放: 随机消息1... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "随机消息1..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "随机消息1..."
[MultiChannelVoiceService] 使用声道调度器播放: 对骂消息1... (channel: 1, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 1)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "对骂消息1..." (lang: en-US, provider: piper, channel: 1)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "对骂消息1..."
[MultiChannelVoiceService] 使用声道调度器播放: 事件消息1... (channel: 2, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 2)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "事件消息1..." (lang: en-US, provider: piper, channel: 2)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "事件消息1..."
[MultiChannelVoiceService] 使用声道调度器播放: 随机消息2... (channel: 3, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 3)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "随机消息2..." (lang: en-US, provider: piper, channel: 3)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "随机消息2..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "随机消息1..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "对骂消息1..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "事件消息1..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "随机消息2..."

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[PiperTTSClient] ✅ 收到音频数据: 63.54 KB
[PiperTTSClient] ✅ 音频生成成功: 对骂消息1... (时长: 2.00s, 大小: 63.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 63.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 63.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 63.54 KB
[TTSAudioService] 💾 已缓存音频: 对骂消息1... (provider: piper, channel: 1)
[TTSAudioService] TTS服务音频生成成功: 对骂消息1... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "对骂消息1..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家1（右）)
[TTSAudioService] 声道 玩家1（右） 空闲，立即播放: 对骂消息1
[TTSAudioService] 声道 玩家1（右） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家1（右）',
  segGain: 1,
  roleGain: 1,
  panner: 0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 57.04 KB
[PiperTTSClient] ✅ 音频生成成功: 随机消息1... (时长: 2.00s, 大小: 57.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 57.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 57.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 57.04 KB
[TTSAudioService] 💾 已缓存音频: 随机消息1... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 随机消息1... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "随机消息1..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 随机消息1
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 58.04 KB
[PiperTTSClient] ✅ 音频生成成功: 随机消息2... (时长: 2.00s, 大小: 58.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 58.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 58.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 58.04 KB
[TTSAudioService] 💾 已缓存音频: 随机消息2... (provider: piper, channel: 3)
[TTSAudioService] TTS服务音频生成成功: 随机消息2... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "随机消息2..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家3（右中）)
[TTSAudioService] 声道 玩家3（右中） 空闲，立即播放: 随机消息2
[TTSAudioService] 声道 玩家3（右中） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家3（右中）',
  segGain: 1,
  roleGain: 1,
  panner: 0.5,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 57.04 KB
[PiperTTSClient] ✅ 音频生成成功: 事件消息1... (时长: 2.00s, 大小: 57.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 57.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 57.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 57.04 KB
[TTSAudioService] 💾 已缓存音频: 事件消息1... (provider: piper, channel: 2)
[TTSAudioService] TTS服务音频生成成功: 事件消息1... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "事件消息1..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家2（左中）)
[TTSAudioService] 声道 玩家2（左中） 空闲，立即播放: 事件消息1
[TTSAudioService] 声道 玩家2（左中） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家2（左中）',
  segGain: 1,
  roleGain: 1,
  panner: -0.5,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > 初始化 > 应该初始化默认状态
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > 初始化 > 应该设置 Game 的更新回调
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > startGame > 应该调用 Game.startGameWithDealing 并创建新游戏
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > startGame > 应该保持托管状态
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > startGame > 应该设置新游戏的更新回调
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > resetGame > 应该调用 Game.reset()
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > toggleAutoPlay > 应该调用 Game.toggleAutoPlay()
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > toggleAutoPlay > 应该返回新的托管状态
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > handleDealingComplete > 应该在没有 pendingGameConfig 时只设置 isDealing 为 false
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > handleDealingComplete > 应该在有 pendingGameConfig 时创建新游戏
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > handleDealingComplete > 应该设置 isDealing 为 false，无论是否有 pendingGameConfig
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > handleDealingCancel > 应该调用 Game.handleDealingCancel()
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > handleDealingCancel > 应该清空 pendingGameConfig 和 isDealing
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > React 状态管理 > 应该正确管理 isDealing 状态
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > React 状态管理 > 应该正确管理 pendingGameConfig 状态
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > React 状态管理 > 应该从 Game 实例读取 isAutoPlay
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > createAndSetupGame 辅助函数 > 应该为新游戏设置更新回调
 ✓ tests/useMultiPlayerGame.test.ts > useMultiPlayerGame Hook > createAndSetupGame 辅助函数 > 应该更新 game 状态
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > dealCards 函数测试 > 发牌应该为每个玩家创建正确数量的牌
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > dealCards 函数测试 > 不同玩家数量的发牌测试 307ms
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > dealCards 函数测试 > 每个玩家的牌应该是唯一的
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > dealCards 函数测试 > 发牌应该是随机的
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > createAndStartNewGame > 应该创建新游戏实例
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > createAndStartNewGame > 应该保持托管状态
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > createAndStartNewGame > 应该初始化追踪模块（如果启用）
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > createAndStartNewGame > 应该不初始化追踪模块（如果禁用）
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > startGameWithDealing > 应该自动发牌并创建游戏
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > startGameWithDealing > 应该保持托管状态
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > handleDealingComplete > 应该使用指定手牌创建游戏
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > handleDealingComplete > 应该保持托管状态
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 静态方法 > handleDealingCancel > 应该是占位方法，不执行任何操作
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > reset > 应该重置游戏状态
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > reset > 应该清除聊天消息
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > reset > 应该触发更新回调
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > toggleAutoPlay > 应该切换托管状态
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > toggleAutoPlay > 应该切换托管状态并更新调度器
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > initializeTracking > 应该初始化追踪模块（如果启用）
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > initializeTracking > 应该从 localStorage 读取配置（如果配置中未指定）
 ✓ tests/gameState.test.ts > 游戏状态管理测试 > Game 实例方法 > initializeTracking > 应该不初始化追踪模块（如果禁用）
stdout | tests/gameState.test.ts
[SystemAnnouncement] announcePlay 被调用 {
  playType: 'triple',
  text: 'Three 5s',
  hasVoiceConfig: true,
  cardsCount: 3
}
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'Three 5s',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: Three 5s... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "Three 5s..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "Three 5s..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural
[SystemAnnouncement] announcePlay 被调用 {
  playType: 'triple',
  text: 'Three 8s',
  hasVoiceConfig: true,
  cardsCount: 3
}
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'Three 8s',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: Three 8s... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "Three 8s..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "Three 8s..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural
[SystemAnnouncement] announcePlay 被调用 {
  playType: 'pair',
  text: 'Pair of K',
  hasVoiceConfig: true,
  cardsCount: 2
}
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'Pair of K',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: Pair of K... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "Pair of K..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "Pair of K..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural
[SystemAnnouncement] announcePlay 被调用 {
  playType: 'triple',
  text: 'Three Ks',
  hasVoiceConfig: true,
  cardsCount: 3
}
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'Three Ks',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: Three Ks... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "Three Ks..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "Three Ks..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural
[SystemAnnouncement] announcePlay 被调用 { playType: 'single', text: '4', hasVoiceConfig: true, cardsCount: 1 }
[VoiceService] speakImmediate 被调用（报牌） {
  text: '4',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: 4... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "4..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "4..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural
[SystemAnnouncement] announcePlay 被调用 {
  playType: 'triple',
  text: 'Three 8s',
  hasVoiceConfig: true,
  cardsCount: 3
}
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'Three 8s',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: Three 8s... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "Three 8s..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "Three 8s..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural
[SystemAnnouncement] announcePlay 被调用 { playType: 'single', text: '5', hasVoiceConfig: true, cardsCount: 1 }
[VoiceService] speakImmediate 被调用（报牌） {
  text: '5',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: 5... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "5..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "5..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural

stderr | tests/gameState.test.ts
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用

stdout | SystemAnnouncementService.announcePlay (/home/jin/guozha_poker_game/src/services/systemAnnouncementService.ts:53:13)
[SystemAnnouncement] announcePlay 被调用 {
  playType: 'triple',
  text: 'Three 5s',
  hasVoiceConfig: true,
  cardsCount: 3
}
[SystemAnnouncement] announcePlay 被调用 {
  playType: 'triple',
  text: 'Three 2s',
  hasVoiceConfig: true,
  cardsCount: 3
}

stdout | VoiceService.speakImmediate (/home/jin/guozha_poker_game/src/services/voiceService.ts:93:13)
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'Three 5s',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[VoiceService] speakImmediate 被调用（报牌） {
  text: 'Three 2s',
  hasVoiceConfig: true,
  channel: 'ANNOUNCEMENT',
  priority: 4
}

stdout | MultiChannelVoiceService.speak (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:396:17)
[MultiChannelVoiceService] 使用声道调度器播放: Three 5s... (channel: 8, type: announcement)
[MultiChannelVoiceService] 使用声道调度器播放: Three 2s... (channel: 8, type: announcement)

stdout | TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:292:17)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)

stdout | TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:332:15)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "Three 5s..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "Three 2s..." (lang: en-US, provider: azure, channel: 8)

stdout | TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:336:17)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure

stderr | TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:166:15)
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用

stdout | TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:170:13)
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "Three 5s..."
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "Three 2s..."

stdout | AzureSpeechTTSClient.callAzureSpeechTTS (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:142:15)
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service

stdout | AzureSpeechTTSClient.callAzureSpeechTTS (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:143:15)
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语言: zh-CN

stdout | AzureSpeechTTSClient.callAzureSpeechTTS (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:144:15)
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural

stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 向后兼容性 > 应该保持原有聊天功能正常工作
[ChatService] 调用策略生成随机闲聊，策略: llm
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 玩家1
[LLMChatStrategy] 📝 生成的Prompt长度: 1188 字符
[LLMChatStrategy] 可用的Ollama模型: []
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 1188
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏规则：过炸/争上游\\n- 每人一副完整的牌（52张）\\n- 支持牌型：单张、对子、三张、炸弹（4张及以上相同）、墩（7张及以上相同）\\n- 分牌：5=5分，10=10分，K=10分\\n- 墩的计分：7张=1墩，8张=2墩，9张=4墩，10张=8墩（翻倍）\\n- 出墩时，每个墩从每个其他玩家扣除30分，出墩玩家获得相应分数\\n- 先出完牌的玩家获胜\\n\\n当前游戏状态：\\n- 玩家数量：2人\\n- 当前轮次：第1轮\\n- 当前轮次累计分数：50分\\n- 游戏总分数：100分\\n- 当前出牌玩家：玩家0\\n- 上家出牌：无（新轮次开始）\\n\\n## 当前玩家信息\\n玩家名称：玩家1\\n玩家类型：AI\\n方言：mandarin\\n性别：男\\n手牌数量：0张\\n手牌详情：无\\n当前得分：100分\\n出完牌名次：未出完\\n\\n所有玩家情况：\\n- 玩家1（当前玩家）：手牌0张，得分100分\\n- 玩家2：手牌0张，得分80分\\n\\n## 事件信息\\n事件类型：随机闲聊\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}
[LLMChatStrategy] API响应时间: 1 ms
[LLMChatStrategy] API响应数据: { message: { content: '测试回复' } }
[LLMChatStrategy] 收到大模型回复: 测试回复
[LLMChatStrategy] ✅ 成功生成聊天内容: 测试回复
[ChatService] ✅ 收到聊天消息: 测试回复

stdout | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 向后兼容性 > 旧消息不应该有replyTo字段
[ChatService] 调用策略生成随机闲聊，策略: llm
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 玩家1
[LLMChatStrategy] 📝 生成的Prompt长度: 1188 字符
[LLMChatStrategy] 可用的Ollama模型: []
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 1188
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏规则：过炸/争上游\\n- 每人一副完整的牌（52张）\\n- 支持牌型：单张、对子、三张、炸弹（4张及以上相同）、墩（7张及以上相同）\\n- 分牌：5=5分，10=10分，K=10分\\n- 墩的计分：7张=1墩，8张=2墩，9张=4墩，10张=8墩（翻倍）\\n- 出墩时，每个墩从每个其他玩家扣除30分，出墩玩家获得相应分数\\n- 先出完牌的玩家获胜\\n\\n当前游戏状态：\\n- 玩家数量：2人\\n- 当前轮次：第1轮\\n- 当前轮次累计分数：50分\\n- 游戏总分数：100分\\n- 当前出牌玩家：玩家0\\n- 上家出牌：无（新轮次开始）\\n\\n## 当前玩家信息\\n玩家名称：玩家1\\n玩家类型：AI\\n方言：mandarin\\n性别：男\\n手牌数量：0张\\n手牌详情：无\\n当前得分：100分\\n出完牌名次：未出完\\n\\n所有玩家情况：\\n- 玩家1（当前玩家）：手牌0张，得分100分\\n- 玩家2：手牌0张，得分80分\\n\\n## 事件信息\\n事件类型：随机闲聊\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}
[LLMChatStrategy] API响应时间: 0 ms
[LLMChatStrategy] API响应数据: { message: { content: '测试回复' } }
[LLMChatStrategy] 收到大模型回复: 测试回复
[LLMChatStrategy] ✅ 成功生成聊天内容: 测试回复
[ChatService] ✅ 收到聊天消息: 测试回复

stderr | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 回复功能不影响现有聊天流程 > 回复消息应该正常添加到消息列表
[ChatService] 当前策略不支持回复功能

stderr | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 回复功能不影响现有聊天流程 > 回复消息应该能够触发新的回复（回复链）
[ChatService] 当前策略不支持回复功能

stderr | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 消息类型完整性 > 回复消息应该包含所有必需字段
[ChatService] 当前策略不支持回复功能

stdout | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 消息类型完整性 > 非回复消息不应该有replyTo字段
[ChatService] 调用策略生成随机闲聊，策略: llm
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 玩家1
[LLMChatStrategy] 📝 生成的Prompt长度: 1188 字符
[LLMChatStrategy] 可用的Ollama模型: []
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 1188
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏规则：过炸/争上游\\n- 每人一副完整的牌（52张）\\n- 支持牌型：单张、对子、三张、炸弹（4张及以上相同）、墩（7张及以上相同）\\n- 分牌：5=5分，10=10分，K=10分\\n- 墩的计分：7张=1墩，8张=2墩，9张=4墩，10张=8墩（翻倍）\\n- 出墩时，每个墩从每个其他玩家扣除30分，出墩玩家获得相应分数\\n- 先出完牌的玩家获胜\\n\\n当前游戏状态：\\n- 玩家数量：2人\\n- 当前轮次：第1轮\\n- 当前轮次累计分数：50分\\n- 游戏总分数：100分\\n- 当前出牌玩家：玩家0\\n- 上家出牌：无（新轮次开始）\\n\\n## 当前玩家信息\\n玩家名称：玩家1\\n玩家类型：AI\\n方言：mandarin\\n性别：男\\n手牌数量：0张\\n手牌详情：无\\n当前得分：100分\\n出完牌名次：未出完\\n\\n所有玩家情况：\\n- 玩家1（当前玩家）：手牌0张，得分100分\\n- 玩家2：手牌0张，得分80分\\n\\n## 事件信息\\n事件类型：随机闲聊\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}
[LLMChatStrategy] API响应时间: 0 ms
[LLMChatStrategy] API响应数据: { message: { content: '测试回复' } }
[LLMChatStrategy] 收到大模型回复: 测试回复
[LLMChatStrategy] ✅ 成功生成聊天内容: 测试回复
[ChatService] ✅ 收到聊天消息: 测试回复

stderr | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 边界情况 > 应该处理空消息内容
[ChatService] 当前策略不支持回复功能

stderr | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 边界情况 > 应该处理自己回复自己的情况
[ChatService] 当前策略不支持回复功能

stderr | tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 边界情况 > 应该处理回复已回复的消息
[ChatService] 当前策略不支持回复功能

 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 向后兼容性 > 应该保持原有聊天功能正常工作
 × tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 向后兼容性 > 应该保持事件聊天功能正常工作
   → expected null not to be null
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 向后兼容性 > 旧消息不应该有replyTo字段
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 消息订阅不影响现有功能 > 订阅机制不应该影响消息添加
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 消息订阅不影响现有功能 > 多个订阅者不应该影响消息存储
 × tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 回复功能不影响现有聊天流程 > 回复消息应该正常添加到消息列表
   → expected null not to be null
 × tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 回复功能不影响现有聊天流程 > 回复消息应该能够触发新的回复（回复链）
   → expected null not to be null
 × tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 策略接口兼容性 > LLMChatStrategy应该实现generateReply方法
   → expected undefined not to be undefined
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 策略接口兼容性 > RuleBasedStrategy应该实现generateReply方法
 × tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 策略接口兼容性 > generateReply应该是可选方法（向后兼容）
   → expected undefined not to be undefined
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 消息类型完整性 > 回复消息应该包含所有必需字段
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 消息类型完整性 > 非回复消息不应该有replyTo字段
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 性能影响 > 订阅机制不应该显著影响消息添加性能
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 边界情况 > 应该处理空消息内容
 ✓ tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 边界情况 > 应该处理自己回复自己的情况
 × tests/chatReplyRegression.test.ts > 聊天回复功能回归测试 > 边界情况 > 应该处理回复已回复的消息
   → expected null not to be null
 × tests/gameController.test.ts > GameController 类单元测试 > 初始化 > 应该正确初始化游戏
   → this.game.finishOrder is not iterable
 ✓ tests/gameController.test.ts > GameController 类单元测试 > 轮次分数分配 > 应该正确分配轮次分数给接风玩家
 ✓ tests/gameController.test.ts > GameController 类单元测试 > 轮次分数分配 > 应该正确处理接风玩家已出完的情况
 ✓ tests/gameController.test.ts > GameController 类单元测试 > 轮次分数分配 > 应该正确处理轮次分数为0的情况
 × tests/gameController.test.ts > GameController 类单元测试 > 玩家出完牌记录 > 应该正确记录玩家出完牌
   → Cannot read properties of undefined (reading 'includes')
 × tests/gameController.test.ts > GameController 类单元测试 > 玩家出完牌记录 > 应该正确记录多个玩家出完牌的顺序
   → Cannot read properties of undefined (reading 'includes')
 × tests/gameController.test.ts > GameController 类单元测试 > 玩家出完牌记录 > 不应该重复记录已完成的玩家
   → Cannot read properties of undefined (reading 'includes')
 × tests/gameController.test.ts > GameController 类单元测试 > 最终分数和排名计算 > 应该正确计算最终分数和排名
   → Cannot read properties of undefined (reading 'includes')
 × tests/gameController.test.ts > GameController 类单元测试 > 最终分数和排名计算 > 应该正确处理最后一名剩余分牌
   → Cannot read properties of undefined (reading 'includes')
 ✓ tests/gameController.test.ts > GameController 类单元测试 > 回调机制 > 应该正确触发分数变化回调
 × tests/gameController.test.ts > GameController 类单元测试 > 回调机制 > 应该正确触发玩家完成回调
   → Cannot read properties of undefined (reading 'includes')
 ✓ tests/gameController.test.ts > GameController 类单元测试 > 状态查询 > 应该正确获取玩家分数
 × tests/gameController.test.ts > GameController 类单元测试 > 状态查询 > 应该正确获取完成顺序
   → this.game.finishOrder is not iterable
stdout | tests/gameController.test.ts > GameController 类单元测试 > 轮次分数分配 > 应该正确分配轮次分数给接风玩家
[allocateRoundScore] 轮次1结束，玩家1获得25分（从-100变为-75）

stdout | tests/gameController.test.ts > GameController 类单元测试 > 轮次分数分配 > 应该正确处理接风玩家已出完的情况
[allocateRoundScore] 轮次1结束，玩家1获得30分（从-100变为-70）

stdout | tests/gameController.test.ts > GameController 类单元测试 > 轮次分数分配 > 应该正确处理轮次分数为0的情况
[allocateRoundScore] 轮次1结束，玩家1获得0分（从-100变为-100）

stdout | tests/gameController.test.ts > GameController 类单元测试 > 最终分数和排名计算 > 应该正确计算最终分数和排名
[allocateRoundScore] 轮次1结束，玩家1获得50分（从-100变为-50）
[allocateRoundScore] 轮次2结束，玩家2获得30分（从-100变为-70）

stdout | tests/gameController.test.ts > GameController 类单元测试 > 回调机制 > 应该正确触发分数变化回调
[allocateRoundScore] 轮次1结束，玩家1获得25分（从-100变为-75）

stdout | tests/gameController.test.ts > GameController 类单元测试 > 状态查询 > 应该正确获取玩家分数
[allocateRoundScore] 轮次1结束，玩家1获得50分（从-100变为-50）

 × tests/dealingManualMode.test.ts > 手动发牌模式 > 应该显示手动/自动切换按钮 5114ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 单元测试：跳过已出完的玩家 > 应该正确跳过已出完的玩家，找到下一个还在游戏中的玩家
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 单元测试：跳过已出完的玩家 > 应该正确处理所有玩家都出完的情况
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 单元测试：跳过已出完的玩家 > 应该正确处理连续多个玩家出完的情况
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 单元测试：玩家出完牌后的状态更新 > 玩家出完牌后应该正确记录到finishOrder
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 单元测试：玩家出完牌后的状态更新 > 多个玩家出完牌后应该按顺序记录
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 回归测试：确保修复后的功能正常工作 > 玩家出完牌后，下一个玩家应该是AI时自动出牌（回归测试）
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 回归测试：确保修复后的功能正常工作 > 玩家出完牌后，不应该停留在已出完的玩家（回归测试）
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 回归测试：确保修复后的功能正常工作 > 所有玩家都出完牌后，游戏应该结束（回归测试）
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 边界情况测试 > 应该处理只有两个玩家，一个出完的情况
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 边界情况测试 > 应该处理8人游戏中多个玩家出完的情况
 ✓ tests/autoContinueAfterFinish.test.ts > 玩家出完牌后自动继续功能测试 > 集成测试：完整流程 > 应该能够模拟玩家出完牌后，游戏自动继续的完整流程
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > SpontaneousChatProcessor（自发聊天） > 应该正确标识场景类型
 × tests/chatSceneProcessors.test.ts > 聊天场景处理器 > SpontaneousChatProcessor（自发聊天） > 应该构建轻量级提示词
   → expected '你是一个过炸牌游戏的AI玩家，正在和其他玩家进行轻松的闲聊。\n\n⚠️ …' to contain '最多20个字'
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > SpontaneousChatProcessor（自发聊天） > 应该宽松处理内容
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > SpontaneousChatProcessor（自发聊天） > 应该匹配 RANDOM 和 DEALING 事件
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > SpontaneousChatProcessor（自发聊天） > 应该包含聊天历史（如果提供）
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > EventDrivenChatProcessor（事件触发） > 应该正确标识场景类型
 × tests/chatSceneProcessors.test.ts > 聊天场景处理器 > EventDrivenChatProcessor（事件触发） > 应该构建详细提示词
   → expected '你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\…' to contain '最多15个字'
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > EventDrivenChatProcessor（事件触发） > 应该严格处理内容
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > EventDrivenChatProcessor（事件触发） > 应该匹配除 RANDOM 和 DEALING 外的所有事件
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > EventDrivenChatProcessor（事件触发） > 应该包含事件详情
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > EventDrivenChatProcessor（事件触发） > 应该格式化手牌信息
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > TauntChatProcessor（对骂） > 应该正确标识场景类型
 × tests/chatSceneProcessors.test.ts > 聊天场景处理器 > TauntChatProcessor（对骂） > 应该构建对骂提示词
   → expected '你是一个过炸牌游戏的AI玩家，需要生成对骂/挑衅内容。\n\n重要要求：\…' to contain '最多15个字'
 × tests/chatSceneProcessors.test.ts > 聊天场景处理器 > TauntChatProcessor（对骂） > 应该保留对骂内容的原始性（不严格处理）
   → expected 21 to be less than or equal to 20
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > TauntChatProcessor（对骂） > 应该包含目标玩家信息（如果提供）
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > 场景配置差异 > 自发聊天应该使用更长的最大长度
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > 场景配置差异 > 事件触发应该包含完整游戏状态
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > 场景配置差异 > 事件触发应该包含详细事件信息
 ✓ tests/chatSceneProcessors.test.ts > 聊天场景处理器 > 场景配置差异 > 自发聊天应该使用更长的历史记录
 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 优先级排序 > 应该按优先级排序：对骂 > 事件 > 随机 5018ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音
[MultiChannelVoiceService] 使用声道调度器播放: 消息1... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "消息1..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "消息1..."
[MultiChannelVoiceService] 使用声道调度器播放: 消息2... (channel: 1, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 1)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "消息2..." (lang: en-US, provider: piper, channel: 1)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "消息2..."
[MultiChannelVoiceService] 使用声道调度器播放: 消息3... (channel: 2, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 2)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "消息3..." (lang: en-US, provider: piper, channel: 2)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "消息3..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "消息1..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "消息2..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "消息3..."

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 34.04 KB
[PiperTTSClient] ✅ 音频生成成功: 消息1... (时长: 1.20s, 大小: 34.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 34.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 34.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 34.04 KB
[TTSAudioService] 💾 已缓存音频: 消息1... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 消息1... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "消息1..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 消息1
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 43.54 KB
[PiperTTSClient] ✅ 音频生成成功: 消息3... (时长: 1.20s, 大小: 43.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 43.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 43.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 43.54 KB
[TTSAudioService] 💾 已缓存音频: 消息3... (provider: piper, channel: 2)
[TTSAudioService] TTS服务音频生成成功: 消息3... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "消息3..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家2（左中）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家2（左中）)
[TTSAudioService] 声道 玩家2（左中） 空闲，立即播放: 消息3
[TTSAudioService] 声道 玩家2（左中） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家2（左中）',
  segGain: 1,
  roleGain: 1,
  panner: -0.5,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 37.04 KB
[PiperTTSClient] ✅ 音频生成成功: 消息2... (时长: 1.20s, 大小: 37.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 37.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 37.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 37.04 KB
[TTSAudioService] 💾 已缓存音频: 消息2... (provider: piper, channel: 1)
[TTSAudioService] TTS服务音频生成成功: 消息2... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "消息2..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家1（右）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家1（右）)
[TTSAudioService] 声道 玩家1（右） 空闲，立即播放: 消息2
[TTSAudioService] 声道 玩家1（右） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家1（右）',
  segGain: 1,
  roleGain: 1,
  panner: 0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

 ✓ tests/dealingFeaturesRegression.test.ts > 发牌功能回归测试 > 叠放显示功能 > 应该正确显示叠放的卡牌
 ✓ tests/dealingFeaturesRegression.test.ts > 发牌功能回归测试 > 叠放显示功能 > 展开时应该显示所有牌（不叠放）
 ✓ tests/dealingFeaturesRegression.test.ts > 发牌功能回归测试 > 叠放显示功能 > 应该正确计算叠放偏移量
stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': 'Mock LLM strategy', '是否使用LLM': true }

stdout | tests/chatSystem.test.ts > 聊天系统 > triggerRandomChat > 应该根据概率触发随机闲聊
[ChatService] 调用策略生成随机闲聊，策略: llm
[ChatService] ✅ 收到聊天消息: 随机闲聊

stdout | tests/chatSystem.test.ts > 聊天系统 > triggerEventChat > 应该触发大墩事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatSystem.test.ts > 聊天系统 > triggerEventChat > 应该触发分牌被捡走事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 对骂内容

stdout | tests/chatSystem.test.ts > 聊天系统 > triggerEventChat > 应该触发好牌事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatSystem.test.ts > 聊天系统 > triggerBigDunReaction > 应该为大墩触发其他玩家的反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatSystem.test.ts > 聊天系统 > triggerScoreStolenReaction > 应该触发分牌被捡走反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 对骂内容

stdout | tests/chatSystem.test.ts > 聊天系统 > triggerGoodPlayReaction > 应该触发好牌反应
[ChatService] 调用策略生成事件聊天，策略: llm
[ChatService] ✅ 收到聊天消息: 事件聊天

 ✓ tests/chatSystem.test.ts > 聊天系统 > 消息管理 > 应该能够添加聊天消息
 ✓ tests/chatSystem.test.ts > 聊天系统 > 消息管理 > 应该能够获取所有聊天消息
 ✓ tests/chatSystem.test.ts > 聊天系统 > 消息管理 > 应该能够清空聊天消息
 ✓ tests/chatSystem.test.ts > 聊天系统 > 消息管理 > 应该限制消息数量在MAX_MESSAGES以内
 ✓ tests/chatSystem.test.ts > 聊天系统 > createChatMessage > 应该创建正确的聊天消息
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerRandomChat > 应该根据概率触发随机闲聊
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerRandomChat > 应该根据概率不触发随机闲聊
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerEventChat > 应该触发大墩事件聊天
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerEventChat > 应该触发分牌被捡走事件聊天
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerEventChat > 应该触发好牌事件聊天
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerEventChat > 应该触发对骂聊天（使用 triggerTaunt）
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerBigDunReaction > 应该为大墩触发其他玩家的反应
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerBigDunReaction > 不应该为小墩触发反应
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerScoreStolenReaction > 应该触发分牌被捡走反应
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerGoodPlayReaction > 应该触发好牌反应
 ✓ tests/chatSystem.test.ts > 聊天系统 > triggerTaunt > 应该触发对骂
 ✓ tests/i18n.test.ts > 多语言功能测试 > 语言切换 > 应该支持切换到英文
 ✓ tests/i18n.test.ts > 多语言功能测试 > 语言切换 > 应该支持切换到中文
 × tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > LLMChatStrategy 场景集成 > 应该为随机聊天标记 SPONTANEOUS 场景
   → expected undefined to be 'spontaneous' // Object.is equality
 × tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > LLMChatStrategy 场景集成 > 应该为事件聊天标记 EVENT_DRIVEN 场景
   → expected undefined to be 'event-driven' // Object.is equality
 × tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > LLMChatStrategy 场景集成 > 应该为对骂标记 TAUNT 场景
   → expected undefined to be 'taunt' // Object.is equality
 × tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > LLMChatStrategy 场景集成 > 应该根据事件类型选择正确的场景
   → expected undefined to be 'spontaneous' // Object.is equality
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > RuleBasedStrategy 场景标记 > 应该为随机聊天标记 SPONTANEOUS 场景
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > RuleBasedStrategy 场景标记 > 应该为事件聊天标记 EVENT_DRIVEN 场景
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > RuleBasedStrategy 场景标记 > 应该为对骂标记 TAUNT 场景
 × tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 向后兼容性 > 消息应该包含所有必需字段
   → expected { playerId: +0, …(4) } to have property "scene"
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 向后兼容性 > 场景字段应该是可选的（向后兼容）
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 场景处理器工厂集成 > 应该能够根据事件类型获取正确的场景
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 场景处理器工厂集成 > 应该能够获取所有场景的处理器
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 场景配置差异 > 不同场景应该使用不同的配置
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 内容处理差异化 > 自发聊天应该宽松处理内容
 ✓ tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 内容处理差异化 > 事件触发应该严格处理内容
stdout | tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > LLMChatStrategy 场景集成 > 应该为随机聊天标记 SPONTANEOUS 场景
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 测试玩家
[LLMChatStrategy] 📝 生成的Prompt长度: 923 字符
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着

stdout | tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > LLMChatStrategy 场景集成 > 应该为事件聊天标记 EVENT_DRIVEN 场景
[LLMChatStrategy] 生成事件聊天，玩家: 测试玩家 事件: good_play
[LLMChatStrategy] 生成的Prompt长度: 922
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着

stdout | tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > LLMChatStrategy 场景集成 > 应该根据事件类型选择正确的场景
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 测试玩家
[LLMChatStrategy] 📝 生成的Prompt长度: 923 字符
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着

stdout | tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 向后兼容性 > 消息应该包含所有必需字段
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 测试玩家
[LLMChatStrategy] 📝 生成的Prompt长度: 923 字符
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着

stdout | tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 场景配置差异 > 不同场景应该使用不同的配置
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 测试玩家
[LLMChatStrategy] 📝 生成的Prompt长度: 923 字符
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着
[LLMChatStrategy] 生成事件聊天，玩家: 测试玩家 事件: good_play
[LLMChatStrategy] 生成的Prompt长度: 922
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着

stdout | tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 内容处理差异化 > 自发聊天应该宽松处理内容
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 测试玩家
[LLMChatStrategy] 📝 生成的Prompt长度: 923 字符
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着

stdout | tests/chatSceneRegression.test.ts > 聊天场景化系统回归测试 > 内容处理差异化 > 事件触发应该严格处理内容
[LLMChatStrategy] 生成事件聊天，玩家: 测试玩家 事件: good_play
[LLMChatStrategy] 生成的Prompt长度: 922
[LLMChatStrategy] ✅ 成功生成聊天内容: 你妈逼，等着

 ✓ tests/i18n.test.ts > 多语言功能测试 > 语言切换 > 应该支持切换到韩文
 ✓ tests/i18n.test.ts > 多语言功能测试 > 语言切换 > 应该支持切换到日文
 ✓ tests/i18n.test.ts > 多语言功能测试 > 游戏文本翻译 > 应该正确翻译游戏操作按钮（中文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 游戏文本翻译 > 应该正确翻译游戏操作按钮（英文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 游戏文本翻译 > 应该正确翻译游戏状态
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换单张（中文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换单张（英文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换对子（中文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换对子（英文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换三张（中文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换三张（英文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换所有卡牌点数（中文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 卡牌语音转换多语言 > 应该正确转换所有卡牌点数（英文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > UI配置文本翻译 > 应该正确翻译配置项（中文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > UI配置文本翻译 > 应该正确翻译配置项（英文）
 ✓ tests/i18n.test.ts > 多语言功能测试 > 语言持久化 > 应该保存语言选择到 localStorage
stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'rule-based', '描述': 'Mock strategy', '是否使用LLM': false }

stdout | tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 功能完整性 > 应该能够处理多个玩家的聊天
[ChatService] 调用策略生成随机闲聊，策略: rule-based
[ChatService] ✅ 收到聊天消息: 随机闲聊
[ChatService] 调用策略生成随机闲聊，策略: rule-based
[ChatService] ✅ 收到聊天消息: 随机闲聊
[ChatService] 调用策略生成随机闲聊，策略: rule-based
[ChatService] ✅ 收到聊天消息: 随机闲聊

stdout | tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 功能完整性 > 应该能够处理不同方言的聊天
[ChatService] 调用策略生成随机闲聊，策略: rule-based
[ChatService] ✅ 收到聊天消息: 随机闲聊
[ChatService] 调用策略生成随机闲聊，策略: rule-based
[ChatService] ✅ 收到聊天消息: 随机闲聊

stdout | tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 功能完整性 > 应该能够处理所有事件类型
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 对骂内容
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天

stdout | tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 集成测试 > 应该能够同时使用聊天服务和内容库
[ChatService] 调用策略生成随机闲聊，策略: rule-based
[ChatService] ✅ 收到聊天消息: 随机闲聊

stdout | tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 集成测试 > 应该能够处理完整的聊天流程
[ChatService] 调用策略生成随机闲聊，策略: rule-based
[ChatService] ✅ 收到聊天消息: 随机闲聊
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 对骂内容
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天
[ChatService] 调用策略生成事件聊天，策略: rule-based
[ChatService] ✅ 收到聊天消息: 事件聊天

 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 向后兼容性 > 应该保持原有的API接口
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 向后兼容性 > 应该保持原有的消息结构
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 功能完整性 > 应该能够处理多个玩家的聊天
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 功能完整性 > 应该能够处理不同方言的聊天
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 功能完整性 > 应该能够处理所有事件类型
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 聊天内容库回归 > 应该能够获取所有类型的聊天内容
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 聊天内容库回归 > 应该支持普通话和粤语
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 集成测试 > 应该能够同时使用聊天服务和内容库
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 集成测试 > 应该能够处理完整的聊天流程
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 配置管理 > 应该能够更新服务配置
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 配置管理 > 应该能够更新大墩配置
 ✓ tests/chatServiceRegression.test.ts > 聊天服务回归测试 > 配置管理 > 应该能够更新对骂配置
stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/speechUtils.test.ts > 语音工具测试 > 语音合成 > 应该能够调用speakText
[MultiChannelVoiceService] 使用声道调度器播放: 测试... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "测试..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "测试..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "测试..."

 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换单张
   → expected '5' to be '五' // Object.is equality
 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换对子
   → expected 'Pair of 5' to be '对五' // Object.is equality
 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换三张
   → expected 'Three 5s' to be '三个五' // Object.is equality
 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换炸弹（4张）
   → expected '4 5s' to be '4个五' // Object.is equality
 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换炸弹（6张）
   → expected '6 5s' to be '6个五' // Object.is equality
 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换墩（7张）
   → expected '7 5s' to be '7个五' // Object.is equality
 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换墩（8张）
   → expected '8 5s' to be '8个五' // Object.is equality
 × tests/speechUtils.test.ts > 语音工具测试 > 牌型转语音文本 > 应该正确转换所有rank
   → expected '3' to be '三' // Object.is equality
 ✓ tests/speechUtils.test.ts > 语音工具测试 > 语音合成 > 应该检查浏览器是否支持语音合成
stdout | tests/speechUtils.test.ts > 语音工具测试 > 语音合成 > 应该能够调用speakText
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav

stderr | tests/speechUtils.test.ts > 语音工具测试 > 语音合成 > 应该能够调用speakText
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/speechUtils.test.ts > 语音工具测试 > 语音合成 > 应该能够调用speakText
[PiperTTSClient] ✅ 收到音频数据: 32.54 KB
[PiperTTSClient] ✅ 音频生成成功: 测试... (时长: 0.80s, 大小: 32.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 32.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 32.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 32.54 KB
[TTSAudioService] 💾 已缓存音频: 测试... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 测试... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "测试..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 测试
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该按顺序播放队列中的消息
[MultiChannelVoiceService] 使用声道调度器播放: 消息1（随机）... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "消息1（随机）..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "消息1（随机）..."
[MultiChannelVoiceService] 使用声道调度器播放: 消息2（事件）... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 1
[MultiChannelVoiceService] 使用声道调度器播放: 消息3（对骂）... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 2
[MultiChannelVoiceService] 使用声道调度器播放: 消息4（随机）... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 3
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "消息1（随机）..."

 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该一次只播放一个聊天语音 5017ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该按顺序播放队列中的消息
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该按顺序播放队列中的消息
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 55.54 KB
[PiperTTSClient] ✅ 音频生成成功: 消息1（随机）... (时长: 2.80s, 大小: 55.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 55.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 55.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 55.54 KB
[TTSAudioService] 💾 已缓存音频: 消息1（随机）... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 消息1（随机）... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "消息1（随机）..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 消息1（随机）
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/scoringServiceBalance.test.ts > scoringService - 分数守恒测试 > 游戏结束计分应该保持分数守恒
[calculateFinalRankings] 排序后的玩家顺序（按手牌数，然后按finishOrder）: {
  rankings: [
    {
      rank: 1,
      playerId: 0,
      playerName: '玩家1',
      handCount: 0,
      finishOrderIndex: 0,
      score: -100
    },
    {
      rank: 2,
      playerId: 1,
      playerName: '玩家2',
      handCount: 0,
      finishOrderIndex: 1,
      score: -100
    },
    {
      rank: 3,
      playerId: 2,
      playerName: '玩家3',
      handCount: 0,
      finishOrderIndex: 2,
      score: -100
    },
    {
      rank: 4,
      playerId: 3,
      playerName: '玩家4',
      handCount: 0,
      finishOrderIndex: 3,
      score: -100
    }
  ],
  finishOrder: [ 0, 1, 2, 3 ]
}
[calculateFinalRankings] 应用最终规则前: {
  firstPlayer: { id: 0, name: '玩家1', score: -100, handCount: 0 },
  lastPlayer: { id: 3, name: '玩家4', score: -100, handCount: 0 },
  isSamePlayer: false
}
[calculateFinalRankings] 应用最终规则后: {
  firstPlayer: { id: 0, name: '玩家1', score: -70, adjustment: '+30' },
  lastPlayer: { id: 3, name: '玩家4', score: -130, adjustment: '-30' },
  totalAdjustment: 0
}
[calculateFinalRankings] 排序后的玩家顺序（按手牌数，然后按finishOrder）: {
  rankings: [
    {
      rank: 1,
      playerId: 0,
      playerName: '玩家1',
      handCount: 0,
      finishOrderIndex: 0,
      score: -100
    },
    {
      rank: 2,
      playerId: 1,
      playerName: '玩家2',
      handCount: 0,
      finishOrderIndex: 1,
      score: -100
    },
    {
      rank: 3,
      playerId: 2,
      playerName: '玩家3',
      handCount: 0,
      finishOrderIndex: 2,
      score: -100
    },
    {
      rank: 4,
      playerId: 3,
      playerName: '玩家4',
      handCount: 0,
      finishOrderIndex: 3,
      score: -100
    }
  ],
  finishOrder: [ 0, 1, 2, 3 ]
}
[calculateFinalRankings] 应用最终规则前: {
  firstPlayer: { id: 0, name: '玩家1', score: -100, handCount: 0 },
  lastPlayer: { id: 3, name: '玩家4', score: -100, handCount: 0 },
  isSamePlayer: false
}
[calculateFinalRankings] 应用最终规则后: {
  firstPlayer: { id: 0, name: '玩家1', score: -70, adjustment: '+30' },
  lastPlayer: { id: 3, name: '玩家4', score: -130, adjustment: '-30' },
  totalAdjustment: 0
}

stderr | tests/scoringServiceBalance.test.ts > scoringService - 分数守恒测试 > 游戏结束计分应该保持分数守恒
[ScoreValidation] ⚠️ 分数总和不为0！总和=-400 {
  totalScore: -400,
  playerCount: 4,
  finishOrderLength: 4,
  finishOrder: [ 0, 1, 2, 3 ],
  missingInRankings: [],
  missingInFinishOrder: [],
  playerDetails: [
    {
      name: '玩家1',
      id: 0,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: 30,
      finalScore: -70,
      handCount: 0,
      finishOrder: 0,
      otherScoreSources: 0
    },
    {
      name: '玩家2',
      id: 1,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: 0,
      finalScore: -100,
      handCount: 0,
      finishOrder: 1,
      otherScoreSources: 0
    },
    {
      name: '玩家3',
      id: 2,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: 0,
      finalScore: -100,
      handCount: 0,
      finishOrder: 2,
      otherScoreSources: 0
    },
    {
      name: '玩家4',
      id: 3,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: -30,
      finalScore: -130,
      handCount: 0,
      finishOrder: 3,
      otherScoreSources: 0
    }
  ],
  summary: {
    totalInitialScore: -400,
    totalRoundScore: 0,
    totalFinalRuleAdjustment: 0,
    totalOtherScoreSources: 0,
    totalFinalScore: -400,
    expectedTotal: 0
  },
  allRoundsInfo: [
    { playerName: '玩家1', roundsWon: [] },
    { playerName: '玩家2', roundsWon: [] },
    { playerName: '玩家3', roundsWon: [] },
    { playerName: '玩家4', roundsWon: [] }
  ]
}
[ScoreValidation] ⚠️ 分数总和不为0！总和=-400 {
  totalScore: -400,
  playerCount: 4,
  finishOrderLength: 4,
  finishOrder: [ 0, 1, 2, 3 ],
  missingInRankings: [],
  missingInFinishOrder: [],
  playerDetails: [
    {
      name: '玩家1',
      id: 0,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: 30,
      finalScore: -70,
      handCount: 0,
      finishOrder: 0,
      otherScoreSources: 0
    },
    {
      name: '玩家2',
      id: 1,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: 0,
      finalScore: -100,
      handCount: 0,
      finishOrder: 1,
      otherScoreSources: 0
    },
    {
      name: '玩家3',
      id: 2,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: 0,
      finalScore: -100,
      handCount: 0,
      finishOrder: 2,
      otherScoreSources: 0
    },
    {
      name: '玩家4',
      id: 3,
      initialScore: -100,
      roundsWonCount: 0,
      totalRoundScore: 0,
      scoreBeforeFinalRules: -100,
      finalRuleAdjustment: -30,
      finalScore: -130,
      handCount: 0,
      finishOrder: 3,
      otherScoreSources: 0
    }
  ],
  summary: {
    totalInitialScore: -400,
    totalRoundScore: 0,
    totalFinalRuleAdjustment: 0,
    totalOtherScoreSources: 0,
    totalFinalScore: -400,
    expectedTotal: 0
  },
  allRoundsInfo: [
    { playerName: '玩家1', roundsWon: [] },
    { playerName: '玩家2', roundsWon: [] },
    { playerName: '玩家3', roundsWon: [] },
    { playerName: '玩家4', roundsWon: [] }
  ]
}

 ✓ tests/scoringServiceBalance.test.ts > scoringService - 分数守恒测试 > 初始分数总和应该是 0
 ✓ tests/scoringServiceBalance.test.ts > scoringService - 分数守恒测试 > 墩的计分应该保持分数守恒
 ✓ tests/scoringServiceBalance.test.ts > scoringService - 分数守恒测试 > 游戏结束计分应该保持分数守恒
stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 核心功能验证 > speakImmediate 应该仍然工作
[MultiChannelVoiceService] 使用声道调度器播放: 报牌测试... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "报牌测试..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "报牌测试..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural

stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 核心功能验证 > speakImmediate 应该仍然工作
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用

 ✓ tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 清理验证 > 应该不再导出 speakTextMultiChannel 函数
 ✓ tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 清理验证 > 应该不再导出 stopSpeechMultiChannel 函数
 ✓ tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 清理验证 > 应该仍然导出 getPlayerChannel 函数
 ✓ tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 清理验证 > 应该仍然导出 multiChannelVoiceService 实例
stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 核心功能验证 > speakImmediate 应该仍然工作
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at AzureSpeechTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:101:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 报牌播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:434:14)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 核心功能验证 > speakImmediate 应该仍然工作
[TTSServiceManager] ✅ 提供者 azure 成功生成音频: 9.84 KB
[TTSAudioService] ✅ 📢报牌场景 - TTS服务返回音频: 9.84 KB (provider: azure)
[TTSAudioService] TTS服务返回音频: 9.84 KB
[TTSAudioService] 💾 已缓存音频: 报牌测试... (provider: azure, channel: 8)
[TTSAudioService] TTS服务音频生成成功: 报牌测试... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "报牌测试..." (时长: 1.00s, 采样率: 44100Hz, 声道: 报牌（中央）)
[TTSAudioService] 🎯 报牌请求：使用独立报牌通道，与聊天通道隔离
[TTSAudioService] 声道 报牌（中央） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '报牌（中央）',
  segGain: 1.2,
  roleGain: 1.2,
  panner: 0,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

 × tests/dealingManualMode.test.ts > 手动发牌模式 > 应该能够切换到手动模式 10034ms
   → Test timed out in 10000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 × tests/speechUtils.test.ts > 语音工具测试 > 语音合成 > 应该能够调用speakText 5006ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 × tests/speechUtils.test.ts > 语音工具测试 > 语音合成 > 应该能够调用speakPlay（使用speakText + playToSpeechText）
   → expected '6 5s' to be '6个五' // Object.is equality
 ✓ tests/speechUtils.test.ts > 语音工具测试 > 语音配置 > 应该生成随机语音配置
 ✓ tests/speechUtils.test.ts > 语音工具测试 > 语音配置 > 应该为不同玩家生成不同的语音配置
 ✓ tests/speechUtils.test.ts > 语音工具测试 > 语音配置 > 应该为同一玩家生成相同的语音配置
 ✓ tests/speechUtils.test.ts > 语音工具测试 > 语音配置 > 应该只使用支持的方言（mandarin, cantonese, nanchang）
 ✓ tests/speechUtils.test.ts > 语音工具测试 > 语音配置 > 应该全用女声
stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
[MultiChannelVoiceService] 使用声道调度器播放: 聊天消息... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "聊天消息..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "聊天消息..."
[MultiChannelVoiceService] 使用声道调度器播放: 报牌消息... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] 🎯 📢报牌场景 - 开始生成音频: "报牌消息..." (lang: en-US, provider: azure, channel: 8)
[TTSAudioService] ✅ 📢报牌场景 - 使用指定TTS服务商: azure
[TTSServiceManager] 🎯 使用指定提供者 azure 生成语音: "报牌消息..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "聊天消息..."
[AzureSpeechTTSClient] 🔍 发送请求到 Azure Speech Service
[AzureSpeechTTSClient] 语言: zh-CN
[AzureSpeechTTSClient] 语音: zh-CN-XiaoxiaoNeural

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
[TTSServiceManager] ⚠️ 提供者 azure 未启用，尝试强制使用

 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 串行播放 > 应该按顺序播放队列中的消息 5004ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
[TTSServiceManager] ✅ 提供者 azure 成功生成音频: 9.56 KB
[TTSAudioService] ✅ 📢报牌场景 - TTS服务返回音频: 9.56 KB (provider: azure)
[TTSAudioService] TTS服务返回音频: 9.56 KB
[TTSAudioService] 💾 已缓存音频: 报牌消息... (provider: azure, channel: 8)
[TTSAudioService] TTS服务音频生成成功: 报牌消息... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "报牌消息..." (时长: 1.00s, 采样率: 44100Hz, 声道: 报牌（中央）)
[TTSAudioService] 调用 onStart 回调 (声道: 报牌（中央）)
[TTSAudioService] 🎯 报牌请求：使用独立报牌通道，与聊天通道隔离
[TTSAudioService] 声道 报牌（中央） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '报牌（中央）',
  segGain: 1.2,
  roleGain: 1.2,
  panner: 0,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at AzureSpeechTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:101:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 报牌播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:434:14)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
<empty line>
stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
[PiperTTSClient] ✅ 收到音频数据: 64.04 KB
[PiperTTSClient] ✅ 音频生成成功: 聊天消息... (时长: 1.60s, 大小: 64.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 64.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 64.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 64.04 KB
[TTSAudioService] 💾 已缓存音频: 聊天消息... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 聊天消息... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "聊天消息..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 聊天消息
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测炸弹并触发聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 测试玩家 事件: dealing_bomb_formed
[LLMChatStrategy] 生成的Prompt长度: 897

 ✓ tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 发牌算法 > 应该能够使用所有发牌算法
 ✓ tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 发牌算法 > 应该为每张牌生成唯一ID
 ✓ tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌排序 > 应该能够按不同规则排序
 ✓ tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌排序 > 应该能够按rank分组
stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测炸弹并触发聊天
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 897
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：测试玩家\\n玩家类型：真人\\n方言：mandarin\\n性别：女\\n手牌数量：0张\\n手牌详情：无\\n当前得分：0分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：理牌时形成炸弹\\n炸弹：4张5\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

 × tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 核心功能验证 > speakImmediate 应该仍然工作 5010ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 ✓ tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 核心功能验证 > stop 方法应该仍然工作
 ✓ tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 核心功能验证 > isCurrentlySpeaking 应该仍然工作
stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按顺序播放消息
[MultiChannelVoiceService] 使用声道调度器播放: 消息1... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "消息1..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "消息1..."
[MultiChannelVoiceService] 使用声道调度器播放: 消息2... (channel: 1, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 1)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "消息2..." (lang: en-US, provider: piper, channel: 1)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "消息2..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "消息1..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "消息2..."

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按顺序播放消息
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav

stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按顺序播放消息
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按顺序播放消息
[PiperTTSClient] ✅ 收到音频数据: 35.54 KB
[PiperTTSClient] ✅ 音频生成成功: 消息1... (时长: 1.20s, 大小: 35.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 35.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 35.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 35.54 KB
[TTSAudioService] 💾 已缓存音频: 消息1... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 消息1... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "消息1..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 消息1
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按顺序播放消息
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 34.54 KB
[PiperTTSClient] ✅ 音频生成成功: 消息2... (时长: 1.20s, 大小: 34.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 34.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 34.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 34.54 KB
[TTSAudioService] 💾 已缓存音频: 消息2... (provider: piper, channel: 1)
[TTSAudioService] TTS服务音频生成成功: 消息2... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "消息2..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家1（右）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家1（右）)
[TTSAudioService] 声道 玩家1（右） 空闲，立即播放: 消息2
[TTSAudioService] 声道 玩家1（右） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家1（右）',
  segGain: 1,
  roleGain: 1,
  panner: 0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按顺序播放消息
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 队列满时应该丢弃低优先级消息
[MultiChannelVoiceService] 使用声道调度器播放: 消息0... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "消息0..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "消息0..."
[MultiChannelVoiceService] 使用声道调度器播放: 消息1... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 4
[MultiChannelVoiceService] 使用声道调度器播放: 消息2... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 5
[MultiChannelVoiceService] 使用声道调度器播放: 消息3... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 6
[MultiChannelVoiceService] 使用声道调度器播放: 消息4... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 7
[MultiChannelVoiceService] 使用声道调度器播放: 消息5... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 8
[MultiChannelVoiceService] 使用声道调度器播放: 消息6... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 9
[MultiChannelVoiceService] 使用声道调度器播放: 消息7... (channel: 0, type: chat)
[ChannelScheduler] 通道 0 队列长度: 10
[MultiChannelVoiceService] 使用声道调度器播放: 消息8... (channel: 0, type: chat)
[MultiChannelVoiceService] 使用声道调度器播放: 消息9... (channel: 0, type: chat)
[MultiChannelVoiceService] 使用声道调度器播放: 消息10... (channel: 0, type: chat)
[MultiChannelVoiceService] 使用声道调度器播放: 消息11... (channel: 0, type: chat)
[MultiChannelVoiceService] 使用声道调度器播放: 消息12... (channel: 0, type: chat)
[MultiChannelVoiceService] 使用声道调度器播放: 消息13... (channel: 0, type: chat)
[MultiChannelVoiceService] 使用声道调度器播放: 消息14... (channel: 0, type: chat)
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "消息0..."

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 队列满时应该丢弃低优先级消息
[ChannelScheduler] 通道 0 队列已满，丢弃请求
[ChannelScheduler] 通道 0 队列已满，丢弃请求
[ChannelScheduler] 通道 0 队列已满，丢弃请求
[ChannelScheduler] 通道 0 队列已满，丢弃请求
[ChannelScheduler] 通道 0 队列已满，丢弃请求
[ChannelScheduler] 通道 0 队列已满，丢弃请求
[ChannelScheduler] 通道 0 队列已满，丢弃请求

 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 报牌中断 > 报牌应该可以中断聊天语音 5007ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 队列满时应该丢弃低优先级消息
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 40.04 KB
[PiperTTSClient] ✅ 音频生成成功: 消息0... (时长: 1.20s, 大小: 40.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 40.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 40.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 40.04 KB
[TTSAudioService] 💾 已缓存音频: 消息0... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 消息0... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "消息0..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 消息0
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 队列满时应该丢弃低优先级消息
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测墩并触发聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 测试玩家 事件: dealing_dun_formed
[LLMChatStrategy] 生成的Prompt长度: 896

 × tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测炸弹并触发聊天 5030ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测墩并触发聊天
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 896
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：测试玩家\\n玩家类型：真人\\n方言：mandarin\\n性别：女\\n手牌数量：0张\\n手牌详情：无\\n当前得分：0分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：理牌时形成墩\\n墩：7张10\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放
[MultiChannelVoiceService] 使用声道调度器播放: 低优先级... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "低优先级..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "低优先级..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "低优先级..."

 × tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按顺序播放消息 5005ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放
[MultiChannelVoiceService] 使用声道调度器播放: 高优先级... (channel: 1, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 1)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "高优先级..." (lang: en-US, provider: piper, channel: 1)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "高优先级..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "高优先级..."

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav

stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放
[PiperTTSClient] ✅ 收到音频数据: 46.04 KB
[PiperTTSClient] ✅ 音频生成成功: 低优先级... (时长: 1.60s, 大小: 46.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 46.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 46.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 46.04 KB
[TTSAudioService] 💾 已缓存音频: 低优先级... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 低优先级... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "低优先级..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 低优先级
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav
[PiperTTSClient] ✅ 收到音频数据: 44.04 KB
[PiperTTSClient] ✅ 音频生成成功: 高优先级... (时长: 1.60s, 大小: 44.04 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 44.04 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 44.04 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 44.04 KB
[TTSAudioService] 💾 已缓存音频: 高优先级... (provider: piper, channel: 1)
[TTSAudioService] TTS服务音频生成成功: 高优先级... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "高优先级..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家1（右）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家1（右）)
[TTSAudioService] 声道 玩家1（右） 空闲，立即播放: 高优先级
[TTSAudioService] 声道 玩家1（右） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家1（右）',
  segGain: 1,
  roleGain: 1,
  panner: 0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

 × tests/dealingManualMode.test.ts > 手动发牌模式 > 手动模式下点击抓牌按钮应该发一张牌 10026ms
   → Test timed out in 10000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 队列满时应该丢弃低优先级消息 5014ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 应该正确处理队列中的消息
[MultiChannelVoiceService] 使用声道调度器播放: 消息1... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] ✅ 使用缓存音频: 消息1... (provider: piper, channel: 0)
[MultiChannelVoiceService] 使用声道调度器播放: 消息2... (channel: 1, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 1)
[TTSAudioService] ✅ 使用缓存音频: 消息2... (provider: piper, channel: 1)
[MultiChannelVoiceService] 使用声道调度器播放: 消息3... (channel: 2, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 2)
[TTSAudioService] ✅ 使用缓存音频: 消息3... (provider: piper, channel: 2)
[TTSAudioService] ✅ 音频生成完成: "消息1..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 消息1
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}
[TTSAudioService] ✅ 音频生成完成: "消息2..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家1（右）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家1（右）)
[TTSAudioService] 声道 玩家1（右） 空闲，立即播放: 消息2
[TTSAudioService] 声道 玩家1（右） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家1（右）',
  segGain: 1,
  roleGain: 1,
  panner: 0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}
[TTSAudioService] ✅ 音频生成完成: "消息3..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家2（左中）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家2（左中）)
[TTSAudioService] 声道 玩家2（左中） 空闲，立即播放: 消息3
[TTSAudioService] 声道 玩家2（左中） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家2（左中）',
  segGain: 1,
  roleGain: 1,
  panner: -0.5,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 应该正确处理队列中的消息
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14

stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测超大牌并触发聊天
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 测试玩家 事件: dealing_huge_card
[LLMChatStrategy] 生成的Prompt长度: 898

 × tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测墩并触发聊天 5008ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测超大牌并触发聊天
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 898
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：测试玩家\\n玩家类型：真人\\n方言：mandarin\\n性别：女\\n手牌数量：0张\\n手牌详情：无\\n当前得分：0分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：理牌时抓到超大牌\\n超大牌：大王\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speak 应该接受 priority 参数
[MultiChannelVoiceService] 使用声道调度器播放: 测试... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "测试..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "测试..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "测试..."

 × tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 串行播放验证 > 应该按优先级排序播放 5015ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speak 应该接受 priority 参数
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav

stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speak 应该接受 priority 参数
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speak 应该接受 priority 参数
[PiperTTSClient] ✅ 收到音频数据: 29.54 KB
[PiperTTSClient] ✅ 音频生成成功: 测试... (时长: 0.80s, 大小: 29.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 29.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 29.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 29.54 KB
[TTSAudioService] 💾 已缓存音频: 测试... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 测试... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "测试..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 测试
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > onStart应该在语音真正开始时触发
[MultiChannelVoiceService] 使用声道调度器播放: 测试消息... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] 🎯 💬聊天场景 - 开始生成音频: "测试消息..." (lang: en-US, provider: piper, channel: 0)
[TTSAudioService] ✅ 💬聊天场景 - 使用指定TTS服务商: piper
[TTSServiceManager] 🎯 使用指定提供者 piper 生成语音: "测试消息..."
[PiperTTSClient] 🎯 调用 Piper TTS API: http://localhost:5000/api/tts, 文本: "测试消息..."

 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 队列管理 > 应该正确处理队列中的消息 5017ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > onStart应该在语音真正开始时触发
[PiperTTSClient] ✅ API 响应成功: 200, Content-Type: audio/wav

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > onStart应该在语音真正开始时触发
[AudioCache] 清理过期条目失败: ReferenceError: IDBKeyRange is not defined
    at AudioCache.cleanupExpiredEntries (/home/jin/guozha_poker_game/src/tts/audioCache.ts:402:40)
    at AudioCache.cleanupIfNeeded (/home/jin/guozha_poker_game/src/tts/audioCache.ts:339:18)
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at AudioCache.set (/home/jin/guozha_poker_game/src/tts/audioCache.ts:147:7)
    at PiperTTSClient.synthesize (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:62:11)
    at TTSServiceManager.synthesizeWithProvider (/home/jin/guozha_poker_game/src/tts/ttsServiceManager.ts:173:22)
    at TTSAudioService.generateAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:337:18)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:212:29
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
    at processTicksAndRejections (node:internal/process/task_queues:95:5)

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > onStart应该在语音真正开始时触发
[PiperTTSClient] ✅ 收到音频数据: 48.54 KB
[PiperTTSClient] ✅ 音频生成成功: 测试消息... (时长: 1.60s, 大小: 48.54 KB)
[TTSServiceManager] ✅ 提供者 piper 成功生成音频: 48.54 KB
[TTSAudioService] ✅ 💬聊天场景 - TTS服务返回音频: 48.54 KB (provider: piper)
[TTSAudioService] TTS服务返回音频: 48.54 KB
[TTSAudioService] 💾 已缓存音频: 测试消息... (provider: piper, channel: 0)
[TTSAudioService] TTS服务音频生成成功: 测试消息... (1.00s)
[TTSAudioService] ✅ 音频生成完成: "测试消息..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 测试消息
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该优先检测炸弹/墩
[ChatService] 调用策略生成事件聊天，策略: llm
[LLMChatStrategy] 生成事件聊天，玩家: 测试玩家 事件: dealing_bomb_formed
[LLMChatStrategy] 生成的Prompt长度: 897

 × tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该检测超大牌并触发聊天 5012ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该优先检测炸弹/墩
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 897
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：测试玩家\\n玩家类型：真人\\n方言：mandarin\\n性别：女\\n手牌数量：0张\\n手牌详情：无\\n当前得分：0分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：理牌时形成炸弹\\n炸弹：4张5\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

stdout | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speakImmediate 应该仍然工作
[VoiceService] speakImmediate 被调用（报牌） {
  text: '报牌测试',
  hasVoiceConfig: false,
  channel: 'ANNOUNCEMENT',
  priority: 4
}
[MultiChannelVoiceService] 使用声道调度器播放: 报牌测试... (channel: 8, type: announcement)
[TTSAudioService] 📢 报牌场景，使用TTS提供者: azure (channel: 8)
[TTSAudioService] ✅ 使用缓存音频: 报牌测试... (provider: azure, channel: 8)
[TTSAudioService] ✅ 音频生成完成: "报牌测试..." (时长: 1.00s, 采样率: 44100Hz, 声道: 报牌（中央）)
[TTSAudioService] 🎯 报牌请求：使用独立报牌通道，与聊天通道隔离
[TTSAudioService] 声道 报牌（中央） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '报牌（中央）',
  segGain: 1.2,
  roleGain: 1.2,
  panner: 0,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speakImmediate 应该仍然工作
[ChannelScheduler] 报牌播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:434:14)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14

 × tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speak 应该接受 priority 参数 5019ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该优先检测炸弹/墩
[LLMChatStrategy] API响应时间: 15779 ms
[LLMChatStrategy] API响应数据: {
  model: 'qwen2:0.5b',
  created_at: '2025-11-30T15:43:32.14777208Z',
  message: { role: 'assistant', content: '"好牌！这手不错，要不起。出得好。出得好！"' },
  done: true,
  done_reason: 'stop',
  total_duration: 15767513838,
  load_duration: 2858763046,
  prompt_eval_count: 945,
  prompt_eval_duration: 11430983420,
  eval_count: 19,
  eval_duration: 1351795261
}
[LLMChatStrategy] 收到大模型回复: "好牌！这手不错，要不起。出得好。出得好！"
[LLMChatStrategy] ✅ 成功生成聊天内容: 好牌！这手不错，要不起。出得好。出得好！
[ChatService] ✅ 收到聊天消息: 好牌！这手不错，要不起。出得好。出得好！

 × tests/dealingManualMode.test.ts > 手动发牌模式 > 手动模式下不应该自动发牌 10048ms
   → Test timed out in 10000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该优先检测炸弹/墩
[LLMChatStrategy] API响应时间: 12660 ms
[LLMChatStrategy] API响应数据: {
  model: 'qwen2:0.5b',
  created_at: '2025-11-30T15:43:34.060007076Z',
  message: { role: 'assistant', content: '测试玩家：哈哈！这是我的手牌。看，7张10！' },
  done: true,
  done_reason: 'stop',
  total_duration: 12630307228,
  load_duration: 377122703,
  prompt_eval_count: 946,
  prompt_eval_duration: 1310591615,
  eval_count: 18,
  eval_duration: 545415520
}
[LLMChatStrategy] 收到大模型回复: 测试玩家：哈哈！这是我的手牌。看，7张10！
[LLMChatStrategy] ✅ 成功生成聊天内容: 测试玩家：哈哈！这是我的手牌。看。
[ChatService] ✅ 收到聊天消息: 测试玩家：哈哈！这是我的手牌。看。

stdout | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > 队列中的消息也应该触发onStart
[MultiChannelVoiceService] 使用声道调度器播放: 消息1... (channel: 0, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 0)
[TTSAudioService] ✅ 使用缓存音频: 消息1... (provider: piper, channel: 0)
[MultiChannelVoiceService] 使用声道调度器播放: 消息2... (channel: 1, type: chat)
[TTSAudioService] 💬 聊天场景，使用TTS提供者: piper (channel: 1)
[TTSAudioService] ✅ 使用缓存音频: 消息2... (provider: piper, channel: 1)
[TTSAudioService] ✅ 音频生成完成: "消息1..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家0（左）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家0（左）)
[TTSAudioService] 声道 玩家0（左） 空闲，立即播放: 消息1
[TTSAudioService] 声道 玩家0（左） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家0（左）',
  segGain: 1,
  roleGain: 1,
  panner: -0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}
[TTSAudioService] ✅ 音频生成完成: "消息2..." (时长: 1.00s, 采样率: 44100Hz, 声道: 玩家1（右）)
[TTSAudioService] 调用 onStart 回调 (声道: 玩家1（右）)
[TTSAudioService] 声道 玩家1（右） 空闲，立即播放: 消息2
[TTSAudioService] 声道 玩家1（右） 空闲，可以与其他声道并行播放
[TTSAudioService] 音频连接验证: {
  channel: '玩家1（右）',
  segGain: 1,
  roleGain: 1,
  panner: 0.7,
  masterGain: 1,
  audioBufferDuration: 1,
  audioBufferSampleRate: 44100,
  audioBufferChannels: 2
}

stderr | tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > 队列中的消息也应该触发onStart
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:656:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14
[ChannelScheduler] 聊天播放失败: TypeError: gain.gain.setTargetAtTime is not a function
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:652:19
    at Map.forEach (<anonymous>)
    at TTSAudioService.duckOthers (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:642:23)
    at TTSAudioService.playAudio (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:556:14)
    at TTSAudioService.addToQueue (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:459:12)
    at /home/jin/guozha_poker_game/src/services/ttsAudioService.ts:251:14

 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > onStart应该在语音真正开始时触发 5008ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 × tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 理牌聊天触发 > 应该优先检测炸弹/墩 5007ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
 ✓ tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 集成测试 > 应该能够完成完整的发牌和理牌流程
 ✓ tests/dealingSortingRegression.test.ts > 发牌和理牌功能回归测试 > 集成测试 > 应该保持发牌算法的特性
 × tests/voiceServiceCleanup.test.ts > 语音服务清理后测试 > 向后兼容性 > voiceService.speakImmediate 应该仍然工作 5005ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stdout | Object.request.onsuccess (/home/jin/guozha_poker_game/src/tts/audioCache.ts:46:17)
[AudioCache] IndexedDB 初始化成功

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:69:15)
[AzureSpeechTTSClient] ✅ Subscription Key 已配置（长度: 84 ）

stdout | new AzureSpeechTTSClient (/home/jin/guozha_poker_game/src/tts/azureSpeechTTSClient.ts:70:15)
[AzureSpeechTTSClient] 🌍 使用区域: koreacentral

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:174:15)
[PiperTTSClient] 检查健康状态: http://localhost:5000/health

stdout | TTSAudioService.initAudioContext (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:145:15)
[TTSAudioService] Web Audio API 已初始化

stdout | PiperTTSClient.checkHealth (/home/jin/guozha_poker_game/src/tts/piperTTSClient.ts:180:15)
[PiperTTSClient] 健康检查响应: 200 OK (✅)

stdout | new MultiChannelVoiceService (/home/jin/guozha_poker_game/src/services/multiChannelVoiceService.ts:105:15)
[MultiChannelVoiceService] 已启用声道调度器

stdout | TTSAudioService.updateConfig (/home/jin/guozha_poker_game/src/services/ttsAudioService.ts:181:13)
[TTSAudioService] 配置已更新: {
  enabled: true,
  maxConcurrentSpeakers: 2,
  useTTS: true,
  ttsProvider: 'auto',
  enableDucking: true,
  duckingLevel: 0.25,
  enableAudioCache: true,
  cacheSize: 100
}

 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useGameConfig Hook > 应该初始化并管理游戏配置
 × tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useGameConfig Hook > 应该能够处理开始游戏
   → [vitest] No "updateChatLLMConfig" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ usePlayerHand Hook > 应该管理玩家手牌状态
 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ usePlayerHand Hook > 应该能够选择和取消选择卡片
 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useChatBubbles Hook > 应该管理聊天气泡
 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useChatBubbles Hook > 应该能够计算气泡位置
 × tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useGameActions Hook > 应该管理游戏操作
   → Cannot read properties of undefined (reading 'currentPlayerIndex')
 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ gameUtils 工具函数 > 应该正确获取牌型名称
 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ gameUtils 工具函数 > 应该正确获取点数显示
 ✓ tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ 集成测试 > 应该能够组合使用多个 hooks
stdout | tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useChatBubbles Hook > 应该管理聊天气泡
语音功能已就绪

stdout | tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useChatBubbles Hook > 应该能够计算气泡位置
语音功能已就绪

stderr | tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ useGameActions Hook > 应该管理游戏操作
Error: Uncaught [TypeError: Cannot read properties of undefined (reading 'currentPlayerIndex')]
    at reportException (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/helpers/runtime-script-errors.js:66:24)
    at innerInvokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:353:9)
    at invokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:286:3)
    at HTMLUnknownElementImpl._dispatch (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:233:9)
    at HTMLUnknownElementImpl.dispatchEvent (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:104:17)
    at HTMLUnknownElement.dispatchEvent (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js:241:34)
    at Object.invokeGuardedCallbackDev (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:4213:16)
    at invokeGuardedCallback (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:4277:31)
    at beginWork$1 (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:27490:7)
    at performUnitOfWork (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:26599:12) TypeError: Cannot read properties of undefined (reading 'currentPlayerIndex')
    at Module.useGameActions (/home/jin/guozha_poker_game/src/hooks/useGameActions.ts:48:12)
    at /home/jin/guozha_poker_game/tests/refactorRegression.test.ts:202:9
    at TestComponent (/home/jin/guozha_poker_game/node_modules/@testing-library/react/dist/pure.js:309:27)
    at renderWithHooks (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:15486:18)
    at mountIndeterminateComponent (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:20103:13)
    at beginWork (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:21626:16)
    at HTMLUnknownElement.callCallback (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:4164:14)
    at HTMLUnknownElement.callTheUserObjectsOperation (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/generated/EventListener.js:26:30)
    at innerInvokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:350:25)
    at invokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:286:3)
Error: Uncaught [TypeError: Cannot read properties of undefined (reading 'currentPlayerIndex')]
    at reportException (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/helpers/runtime-script-errors.js:66:24)
    at innerInvokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:353:9)
    at invokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:286:3)
    at HTMLUnknownElementImpl._dispatch (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:233:9)
    at HTMLUnknownElementImpl.dispatchEvent (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:104:17)
    at HTMLUnknownElement.dispatchEvent (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/generated/EventTarget.js:241:34)
    at Object.invokeGuardedCallbackDev (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:4213:16)
    at invokeGuardedCallback (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:4277:31)
    at beginWork$1 (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:27490:7)
    at performUnitOfWork (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:26599:12) TypeError: Cannot read properties of undefined (reading 'currentPlayerIndex')
    at Module.useGameActions (/home/jin/guozha_poker_game/src/hooks/useGameActions.ts:48:12)
    at /home/jin/guozha_poker_game/tests/refactorRegression.test.ts:202:9
    at TestComponent (/home/jin/guozha_poker_game/node_modules/@testing-library/react/dist/pure.js:309:27)
    at renderWithHooks (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:15486:18)
    at mountIndeterminateComponent (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:20103:13)
    at beginWork (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:21626:16)
    at HTMLUnknownElement.callCallback (/home/jin/guozha_poker_game/node_modules/react-dom/cjs/react-dom.development.js:4164:14)
    at HTMLUnknownElement.callTheUserObjectsOperation (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/generated/EventListener.js:26:30)
    at innerInvokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:350:25)
    at invokeEventListeners (/home/jin/guozha_poker_game/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js:286:3)
The above error occurred in the <TestComponent> component:

    at TestComponent (/home/jin/guozha_poker_game/node_modules/@testing-library/react/dist/pure.js:307:5)

Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.

stdout | tests/refactorRegression.test.ts > 重构回归测试 - 快速验证 > ✅ 集成测试 > 应该能够组合使用多个 hooks
语音功能已就绪

 ✓ tests/dealingAnimation.test.ts > 发牌动画组件 > 应该渲染发牌界面
 ✓ tests/dealingAnimation.test.ts > 发牌动画组件 > 应该显示所有玩家
 ✓ tests/dealingAnimation.test.ts > 发牌动画组件 > 应该显示进度条
 ✓ tests/dealingAnimation.test.ts > 发牌动画组件 > 应该支持取消发牌
stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

 × tests/serialVoicePlayback.test.ts > 串行播放单元测试 > 气泡同步 > 队列中的消息也应该触发onStart 5006ms
   → Test timed out in 5000ms.
If this is a long-running test, pass a timeout value as the last argument or configure it globally with "testTimeout".
stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5)
    at runNextTicks (node:internal/process/task_queues:64:3)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:182:30
    at processTicksAndRejections (node:internal/process/task_queues:95:5) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

 ✓ tests/channelScheduler.test.ts > ChannelScheduler > 声道分配 > 应该正确分配4个玩家到4个通道
 ✓ tests/channelScheduler.test.ts > ChannelScheduler > 声道分配 > 超过4个玩家时应该循环使用通道
stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30
    at runNextTicks (node:internal/process/task_queues:60:5)
    at processImmediate (node:internal/timers:454:9) {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Error: [vitest] No "getChatMessages" export is defined on the "../src/services/chatService" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:

    at VitestMocker.createError (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:79:19)
    at Object.get (file:///home/jin/guozha_poker_game/node_modules/vitest/dist/vendor/execute.fL3szUAI.js:153:22)
    at /home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:230:30 {
  codeFrame: 'vi.mock("../src/services/chatService", async (importOriginal) => {\n' +
    '  const actual = await importOriginal()\n' +
    '  return {\n' +
    '    ...actual,\n' +
    '    // your mocked methods\n' +
    '  }\n' +
    '})'
}
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

 ✓ tests/channelScheduler.test.ts > ChannelScheduler > 报牌播放 > 报牌应该使用ANNOUNCEMENT通道
stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

 × tests/channelScheduler.test.ts > ChannelScheduler > 报牌播放 > 报牌应该中断所有玩家聊天
   → expected "spy" to be called at least once
stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stdout | src/services/chatService.ts:593:9
📢 聊天服务初始化: { '策略': 'llm', '描述': '基于大语言模型的智能聊天策略', '是否使用LLM': true }

stdout | tests/chatAndVoiceRegression.test.ts > 聊天和语音系统回归测试 > 聊天功能回归 > 应该能够正常触发随机闲聊
[ChatService] 调用策略生成随机闲聊，策略: llm
[LLMChatStrategy] 🎲 生成随机闲聊，玩家: 测试玩家
[LLMChatStrategy] 📝 生成的Prompt长度: 887 字符

 × tests/chatAndVoiceRegression.test.ts > 聊天和语音系统回归测试 > 语音功能回归 > 应该保持原有的牌型转语音文本功能
   → expected 'Pair of 5' to be '对五' // Object.is equality
 ✓ tests/chatAndVoiceRegression.test.ts > 聊天和语音系统回归测试 > 语音功能回归 > 应该保持原有的语音配置生成功能
 × tests/chatAndVoiceRegression.test.ts > 聊天和语音系统回归测试 > 语音功能回归 > 应该保持原有的自定义rank发音
   → expected '7 Js' to contain '钩'
stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stdout | tests/chatAndVoiceRegression.test.ts > 聊天和语音系统回归测试 > 聊天功能回归 > 应该能够正常触发随机闲聊
[LLMChatStrategy] 可用的Ollama模型: [ 'qwen2:0.5b' ]
[LLMChatStrategy] 调用Ollama API: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  promptLength: 887
}
[LLMChatStrategy] 发送请求: {
  url: 'http://localhost:11434/api/chat',
  model: 'qwen2:0.5b',
  messagesCount: 2,
  requestBody: '{\n' +
    '  "model": "qwen2:0.5b",\n' +
    '  "messages": [\n' +
    '    {\n' +
    '      "role": "system",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played"\n` +
    '    },\n' +
    '    {\n' +
    '      "role": "user",\n' +
    `      "content": "你是一个过炸牌游戏的AI玩家，需要根据游戏情况生成自然、有趣的聊天内容。\\n\\n语言要求：\\n- 根据\\"语言要求\\"部分的指示，使用对应的语言回复\\n- 如果要求使用中文，使用中文回复\\n- 如果要求使用其他语言（如英语、日语、韩语等），使用对应语言回复\\n- 保持语言地道自然，符合该语言的表达习惯\\n\\n重要要求：\\n1. 只返回一句话（不要多句）\\n2. 最多15个字（必须严格遵守）\\n3. 简洁自然，不要\\"好的，\\"、\\"我觉得，\\"等冗余开头\\n4. 符合游戏场景，口语化表达\\n\\n规则：\\n1. 内容要符合游戏场景，简短有力（1-2句话，不超过20字）\\n2. 可以适当使用方言特色（如果玩家设置了方言且使用中文）\\n3. 要有个性，不同玩家有不同的说话风格\\n4. 对骂必须使用脏话和粗口，要激烈一些，符合打牌时的对骂场景\\n5. 根据游戏状态（领先、落后、出好牌等）调整语气\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n示例（中文）：\\n- 好牌！\\n- 这手不错\\n- 要不起\\n- 等等我\\n- 出得好\\n\\n示例（英文）：\\n- Good cards!\\n- Nice play\\n- Can't beat\\n- Wait for me\\n- Well played\\n\\n## 语言要求\\nUse English to reply\\n\\n## 游戏信息\\n游戏信息：暂无\\n\\n## 当前玩家信息\\n玩家名称：测试玩家\\n玩家类型：AI\\n方言：mandarin\\n性别：女\\n手牌数量：0张\\n手牌详情：无\\n当前得分：0分\\n出完牌名次：未出完\\n\\n## 事件信息\\n事件类型：随机闲聊\\n\\n## 任务\\n根据以上信息，生成符合当前游戏场景的聊天内容。要求：\\n1. 简短有力（1-2句话，总长度不超过20字）\\n2. 每句话不超过15字，使用标点符号断句（句号、问号、感叹号、逗号）\\n3. 如果内容较长，必须分段，每段之间用标点符号分隔\\n4. 符合玩家的性格和方言特色\\n5. 符合当前游戏状态和事件\\n6. 只返回要说的话，不要添加任何解释或标记\\n7. 必须严格遵守\\"语言要求\\"部分指定的语言\\n\\n聊天内容："\n` +
    '    }\n' +
    '  ],\n' +
    '  "stream": false\n' +
    '}'
}

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

stderr | tests/dealingAnimation.test.ts > 发牌动画组件 > 发牌完成后应该调用 onComplete
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)
Warning: An update to DealingAnimation inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
    at DealingAnimation (/home/jin/guozha_poker_game/src/components/game/DealingAnimation.tsx:28:3)

