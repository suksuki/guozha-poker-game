/**
 * Piniaæ¸¸æˆçŠ¶æ€Store
 * è¿æ¥åˆ°æ–°GameEngine
 */

import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import { Game } from '../../../src/game-engine/Game';
import { GameEngine } from '../../../src/game-engine/GameEngine';
import type { Card } from '../../../src/types/card';
import { simpleAIStrategy, hasPlayableCards } from '../../../src/utils/cardUtils';
import { showToast } from 'vant';

export const useGameStore = defineStore('game', () => {
  // æ¸¸æˆå¯¹è±¡ï¼ˆæ–°æ¶æ„ï¼ï¼‰
  const game = ref<Game | null>(null);
  
  // åˆå§‹åŒ–
  const initialize = () => {
    const config = {
      playerCount: 4,
      humanPlayerIndex: 0,
      teamMode: false,
      gameMode: 'individual' as 'individual' | 'team'
    };
    game.value = new Game(config);
  };
  
  // è®¡ç®—å±æ€§ï¼ˆé€šè¿‡Gameè®¿é—®ï¼‰
  const gameState = computed(() => game.value?.state || null);
  const status = computed(() => game.value?.status || 'waiting');
  const currentPlayerIndex = computed(() => game.value?.currentPlayerIndex || 0);
  const players = computed(() => game.value?.players || []);
  const humanPlayer = computed(() => game.value?.humanPlayer);
  const currentRound = computed(() => game.value?.currentRound);
  
  // åŠ¨ä½œ
  const startGame = () => {
    if (!game.value) {
      initialize();
    }
    
    game.value!.startGame();
    console.log('âœ… æ¸¸æˆå·²å¼€å§‹ï¼');
  };
  
  const playCards = (cards: Card[]) => {
    if (!game.value) return { success: false, message: 'æ¸¸æˆæœªå¼€å§‹' };
    
    // ä½¿ç”¨Game APIï¼ˆæ–°æ¶æ„ï¼ï¼‰
    const result = game.value.playCards(currentPlayerIndex.value, cards);
    return result;
  };
  
  const pass = () => {
    if (!game.value) return { success: false, message: 'æ¸¸æˆæœªå¼€å§‹' };
    
    // ä½¿ç”¨Game APIï¼ˆæ–°æ¶æ„ï¼ï¼‰
    const result = game.value.pass(currentPlayerIndex.value);
    return result;
  };
  
  const OLD_playCards_DEPRECATED = (cards: Card[]) => {
    // æ—§ä»£ç ï¼Œå·²åºŸå¼ƒï¼Œä¿ç•™ç”¨äºå‚è€ƒ
    /*
    try {
      const result = RoundModule.processPlay(
        currentRound.value,
        currentPlayerIndex.value,
        cards,
        gameState.value.players
      );
      
      let state = gameState.value;
      state = state.updateRound(state.currentRoundIndex, result.updatedRound);
      
      // æ›´æ–°ç©å®¶çŠ¶æ€ï¼ˆå¦‚æœprocessPlayè¿”å›äº†updatedPlayersï¼‰
      if (result.updatedPlayers && result.updatedPlayers.length > 0) {
        result.updatedPlayers.forEach((player, index) => {
          state = state.updatePlayer(index, player);
        });
      }
      
      // ç§»é™¤æ‰“å‡ºçš„ç‰Œï¼ˆå¦‚æœprocessPlayæ²¡æœ‰æ›´æ–°ç©å®¶æ‰‹ç‰Œï¼‰
      let currentPlayer = state.players[currentPlayerIndex.value];
      let newHand = currentPlayer.hand;
      
      if (currentPlayer.hand.some(c => cards.some(played => played.id === c.id))) {
        newHand = currentPlayer.hand.filter(c => 
          !cards.some(played => played.id === c.id)
        );
        state = state.updatePlayer(currentPlayerIndex.value, { hand: newHand });
        currentPlayer = state.players[currentPlayerIndex.value]; // æ›´æ–°å¼•ç”¨
      }
      
      // æ£€æŸ¥ç©å®¶æ˜¯å¦å‡ºå®Œç‰Œ
      if (newHand.length === 0) {
        // ç©å®¶å®Œæˆæ¸¸æˆ
        state = state.addToFinishOrder(currentPlayerIndex.value);
        const rank = state.finishOrder.length;
        
        // æ›´æ–°ç©å®¶æ’å
        state = state.updatePlayer(currentPlayerIndex.value, { 
          finishedRank: rank 
        });
        
        console.log(`ğŸ‰ ${currentPlayer.name} å‡ºå®Œç‰Œï¼æ’åï¼šç¬¬${rank}å`);
        showToast({ 
          type: 'success', 
          message: `ğŸ‰ ${currentPlayer.name} è·å¾—ç¬¬${rank}åï¼`,
          duration: 2000
        });
      }
      
      // æ³¨æ„ï¼šä¸è¦åœ¨è¿™é‡Œæ£€æŸ¥å›åˆç»“æŸ
      // å›åˆåº”è¯¥åœ¨æ¥é£è½®è§¦å‘æ—¶ç»“æŸï¼Œè€Œä¸æ˜¯æœ‰äººå‡ºå®Œç‰Œå°±ç»“æŸ
      // è¿™é‡Œæ³¨é‡Šæ‰é”™è¯¯çš„é€»è¾‘
      // const roundEndResult = RoundModule.checkRoundEnd(result.updatedRound, state.players);
      // if (roundEndResult.isFinished) {
      //   console.log('ğŸ”„ å›åˆç»“æŸï¼Œå¼€å§‹æ–°å›åˆ');
      //   state = state.addRound(new RoundData(state.rounds.length + 1));
      // }
      
      // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸï¼ˆåœ¨åˆ‡æ¢ç©å®¶å‰ï¼‰
      const isGameEnd = GameFlowModule.checkGameEnd(state);
      console.log(`æ¸¸æˆæ˜¯å¦ç»“æŸ: ${isGameEnd}, finishOrderé•¿åº¦: ${state.finishOrder.length}`);
      
      if (isGameEnd) {
        // æ¸¸æˆç»“æŸï¼Œè®¡ç®—æœ€ç»ˆåˆ†æ•°å’Œæ’å
        state = GameFlowModule.endGame(state, state.finishOrder[0]);
        gameState.value = state;
        
        console.log('ğŸŠ æ¸¸æˆç»“æŸï¼æœ€ç»ˆæ’å:', state.finishOrder);
        showToast({ type: 'success', message: 'ğŸŠ æ¸¸æˆç»“æŸï¼', duration: 3000 });
        
        return { success: true, message: 'å‡ºç‰ŒæˆåŠŸï¼Œæ¸¸æˆç»“æŸ' };
      }
      
      // æ¸¸æˆç»§ç»­ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç©å®¶
      let nextPlayerIndex = (currentPlayerIndex.value + 1) % state.players.length;
      let attempts = 0;
      
      // è·³è¿‡å·²å®Œæˆçš„ç©å®¶
      while (state.players[nextPlayerIndex].hand.length === 0 && attempts < state.players.length) {
        console.log(`è·³è¿‡å·²å®Œæˆçš„ç©å®¶${nextPlayerIndex}`);
        nextPlayerIndex = (nextPlayerIndex + 1) % state.players.length;
        attempts++;
      }
      
      console.log(`åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç©å®¶: ${nextPlayerIndex}, æ‰‹ç‰Œ: ${state.players[nextPlayerIndex].hand.length}å¼ `);
      state = state.updateCurrentPlayer(nextPlayerIndex);
      
      gameState.value = state;
      
      console.log('âœ… å‡ºç‰ŒæˆåŠŸ');
      return { success: true, message: 'å‡ºç‰ŒæˆåŠŸ' };
    } catch (error: any) {
      console.error('âŒ å‡ºç‰Œå¤±è´¥:', error);
      return { success: false, message: error.message || 'å‡ºç‰Œæ— æ•ˆ' };
    }
  };
  
  const pass = () => {
    if (!gameState.value || !currentRound.value) return { success: false, message: 'æ¸¸æˆæœªå¼€å§‹' };
    
    console.log(`ğŸ¯ ç©å®¶${currentPlayerIndex.value}å°è¯•ä¸è¦`);
    console.log('å½“å‰å›åˆæ˜¯å¦å·²ç»“æŸ:', currentRound.value.isFinished);
    console.log('å½“å‰lastPlay:', currentRound.value.lastPlay);
    console.log('å½“å‰lastPlayPlayerIndex:', currentRound.value.lastPlayPlayerIndex);
    
    // å›åˆå·²ç»“æŸä¸èƒ½ä¸è¦
    if (currentRound.value.isFinished) {
      console.log('âŒ å›åˆå·²ç»“æŸï¼Œè·³è¿‡ä¸è¦');
      return { success: false, message: 'å›åˆå·²ç»“æŸ' };
    }
    
    // é¦–å®¶ä¸èƒ½ä¸è¦
    if (!currentRound.value.lastPlay || currentRound.value.lastPlay.length === 0) {
      console.log('âŒ é¦–å®¶ä¸èƒ½ä¸è¦');
      return { success: false, message: 'é¦–å®¶å¿…é¡»å‡ºç‰Œ' };
    }
    
    // å¦‚æœæ˜¯æ¥é£è½®ï¼Œä¸èƒ½ä¸è¦
    if (currentRound.value.isTakeoverRound) {
      console.log('âŒ æ¥é£è½®ä¸èƒ½ä¸è¦');
      return { success: false, message: 'æ¥é£è½®å¿…é¡»å‡ºç‰Œ' };
    }
    
    try {
      const result = RoundModule.processPass(
        currentRound.value,
        currentPlayerIndex.value,
        gameState.value.players
      );
      
      console.log('processPassç»“æœ:', result);
      console.log('æ˜¯å¦è§¦å‘æ¥é£è½®:', result.isTakeover);
      
      let state = gameState.value;
      state = state.updateRound(state.currentRoundIndex, result.updatedRound);
      
      // å¦‚æœè§¦å‘äº†æ¥é£è½®ï¼Œåº”è¯¥å¼€å§‹æ–°å›åˆ
      if (result.isTakeover) {
        console.log('ğŸ”„ è§¦å‘æ¥é£è½®ï¼å›åˆç»“æŸï¼Œå¼€å§‹è®¡åˆ†');
        const winnerIndex = currentRound.value.lastPlayPlayerIndex || 0;
        const winner = state.players[winnerIndex];
        
        // 1. èµ¢å®¶è·å¾—æœ¬å›åˆæ‰€æœ‰æ‰‹ç‰Œåˆ†ï¼ˆ5/10/Kï¼‰
        const roundScore = result.updatedRound.roundScore || 0;
        let winnerNewScore = (winner.score || 0) + roundScore;
        console.log(`ğŸ’° ${winner.name} è·å¾—æœ¬å›åˆæ‰‹ç‰Œåˆ†: ${roundScore}åˆ†`);
        
        // 2. è®¡ç®—å¹¶ç»“ç®—æœ¬å›åˆæ‰€æœ‰å¢©åˆ†
        console.log('ğŸ† å¼€å§‹ç»“ç®—å¢©åˆ†...');
        const roundPlays = result.updatedRound.plays;
        
        // éå†æœ¬å›åˆæ‰€æœ‰å‡ºç‰Œï¼Œæ‰¾å‡ºæ‰€æœ‰å‡ºå¢©çš„
        roundPlays.forEach(play => {
          if (play.cards.length >= 7) {
            const dunCount = Math.pow(2, play.cards.length - 7);
            const dunPlayerScore = dunCount * 30 * 3; // å‡ºå¢©è€…è·å¾—
            const otherPlayersScore = dunCount * 30; // å…¶ä»–äººæ‰£é™¤
            
            console.log(`ğŸ† ç©å®¶${play.playerId}å‡º${play.cards.length}å¼ (${dunCount}å¢©), è·å¾—${dunPlayerScore}åˆ†ï¼Œå…¶ä»–äººå„æ‰£${otherPlayersScore}åˆ†`);
            
            // å‡ºå¢©è€…åŠ åˆ†
            if (play.playerId === winnerIndex) {
              winnerNewScore += dunPlayerScore;
            } else {
              const dunPlayer = state.players[play.playerId];
              const dunPlayerNewScore = (dunPlayer.score || 0) + dunPlayerScore;
              state = state.updatePlayer(play.playerId, { score: dunPlayerNewScore });
            }
            
            // å…¶ä»–äººæ‰£åˆ†
            state.players.forEach((p, idx) => {
              if (idx !== play.playerId) {
                const newScore = (p.score || 0) - otherPlayersScore;
                state = state.updatePlayer(idx, { score: newScore });
              }
            });
          }
        });
        
        // æ›´æ–°èµ¢å®¶åˆ†æ•°ï¼ˆåŒ…å«æ‰‹ç‰Œåˆ†å’Œå¢©åˆ†ï¼‰
        state = state.updatePlayer(winnerIndex, { score: winnerNewScore });
        
        console.log(`âœ… ${winner.name} æœ¬å›åˆæœ€ç»ˆå¾—åˆ†: ${winnerNewScore}`);
        
        // æ˜¾ç¤ºæ‰€æœ‰ç©å®¶å½“å‰åˆ†æ•°
        state.players.forEach((p, idx) => {
          console.log(`   ç©å®¶${idx} ${p.name}: ${p.score}åˆ†, ${p.dunCount}å¢©`);
        });
        
        // ç»“æŸå½“å‰å›åˆ
        const finishedRound = result.updatedRound.finish({
          winnerId: winnerIndex,
          winnerName: winner.name
        });
        state = state.updateRound(state.currentRoundIndex, finishedRound);
        
        // åˆ›å»ºæ–°å›åˆï¼ˆé¦–å®¶æ˜¯æ¥é£è€…ï¼‰
        const newRound = new RoundData(state.rounds.length + 1);
        state = state.addRound(newRound);
        
        // è®¾ç½®å½“å‰ç©å®¶ä¸ºæ¥é£è€…
        state = state.updateCurrentPlayer(winnerIndex);
        
        console.log(`ğŸ†• æ–°å›åˆ${state.rounds.length}å¼€å§‹ï¼Œç©å®¶${winnerIndex}(${winner.name})æ¥é£`);
      } else {
        // ä¸‹ä¸€ä¸ªç©å®¶
        let nextPlayerIndex = (currentPlayerIndex.value + 1) % state.players.length;
        // è·³è¿‡å·²å®Œæˆçš„ç©å®¶
        while (state.players[nextPlayerIndex].hand.length === 0 && state.finishOrder.length < state.players.length - 1) {
          nextPlayerIndex = (nextPlayerIndex + 1) % state.players.length;
        }
        
        state = state.updateCurrentPlayer(nextPlayerIndex);
      }
      
      gameState.value = state;
      
      return { success: true, message: 'ä¸è¦' };
    } catch (error: any) {
      console.error('âŒ ä¸è¦å¤±è´¥:', error);
      return { success: false, message: error.message || 'æ— æ³•ä¸è¦' };
    }
  };
  
  // æ‰˜ç®¡çŠ¶æ€
  const isAutoPlay = ref(false);
  const toggleAutoPlay = () => {
    isAutoPlay.value = !isAutoPlay.value;
    
    // å¦‚æœå¼€å¯æ‰˜ç®¡ä¸”å½“å‰æ˜¯äººç±»ç©å®¶å›åˆï¼Œç«‹å³è§¦å‘æ‰˜ç®¡å‡ºç‰Œ
    if (isAutoPlay.value && gameState.value && status.value === 'playing') {
      const currentPlayer = gameState.value.players[currentPlayerIndex.value];
      if (currentPlayer && currentPlayer.isHuman) {
        console.log('ğŸ¤– æ‰˜ç®¡å¼€å¯ï¼Œç«‹å³è§¦å‘è‡ªåŠ¨å‡ºç‰Œ');
        // å»¶è¿Ÿä¸€ä¸‹è®©UIæ›´æ–°
        setTimeout(() => {
          autoPlayTurn();
        }, 500);
      }
    }
  };
  
  // æ‰˜ç®¡è‡ªåŠ¨å‡ºç‰Œçš„é€»è¾‘
  const autoPlayTurn = async () => {
    if (!gameState.value || !humanPlayer.value) return;
    
    console.log('ğŸ¤– æ‰˜ç®¡è‡ªåŠ¨å‡ºç‰Œä¸­...');
    console.log('å½“å‰å›åˆlastPlay:', currentRound.value?.lastPlay);
    console.log('å½“å‰å›åˆplaysæ•°:', currentRound.value?.plays.length);
    console.log('æ˜¯å¦æ¥é£è½®:', currentRound.value?.isTakeoverRound);
    
    const suggestion = getAIRecommendation();
    console.log('AIæ¨è:', suggestion);
    
    const isFirstPlay = !currentRound.value?.lastPlay || currentRound.value.lastPlay.length === 0;
    const isTakeover = currentRound.value?.isTakeoverRound || false;
    
    console.log(`é¦–å®¶: ${isFirstPlay}, æ¥é£è½®: ${isTakeover}`);
    
    // å¦‚æœæ˜¯æ¥é£è½®æˆ–é¦–å®¶ï¼Œå¿…é¡»å‡ºç‰Œ
    if (isFirstPlay || isTakeover) {
      console.log('ğŸ¯ å¿…é¡»å‡ºç‰Œï¼ˆé¦–å®¶æˆ–æ¥é£è½®ï¼‰');
      
      if (suggestion && suggestion.cards && suggestion.cards.length > 0) {
        const result = playCards(suggestion.cards);
        if (result.success) {
          showToast({ 
            type: 'success', 
            message: `ğŸ¤– æ‰˜ç®¡å‡ºç‰Œ: ${suggestion.cards.length}å¼ `,
            duration: 1500
          });
        } else {
          console.error('ğŸ¤– AIæ¨èå‡ºç‰Œå¤±è´¥ï¼Œå¼ºåˆ¶å‡ºå•å¼ ');
          // å‡ºç‰Œå¤±è´¥ï¼Œå¼ºåˆ¶å‡ºä¸€å¼ å•ç‰Œ
          const singleCard = playCards([humanPlayer.value.hand[0]]);
          if (singleCard.success) {
            showToast({ 
              type: 'success', 
              message: 'ğŸ¤– æ‰˜ç®¡å‡ºå•å¼ ',
              duration: 1500
            });
          }
        }
      } else {
        // AIæ²¡æœ‰æ¨èï¼Œå¼ºåˆ¶å‡ºä¸€å¼ 
        console.log('ğŸ¤– AIæ— æ¨èï¼Œå¼ºåˆ¶å‡ºå•å¼ ');
        const result = playCards([humanPlayer.value.hand[0]]);
        if (result.success) {
          showToast({ 
            type: 'success', 
            message: 'ğŸ¤– æ‰˜ç®¡å‡ºå•å¼ ',
            duration: 1500
          });
        }
      }
    } else {
      // éé¦–å®¶ï¼Œå¯ä»¥é€‰æ‹©å‡ºç‰Œæˆ–ä¸è¦
      if (suggestion && suggestion.cards && suggestion.cards.length > 0) {
        console.log('ğŸ¯ å°è¯•å‡ºç‰Œ');
        const result = playCards(suggestion.cards);
        if (result.success) {
          showToast({ 
            type: 'success', 
            message: `ğŸ¤– æ‰˜ç®¡å‡ºç‰Œ: ${suggestion.cards.length}å¼ `,
            duration: 1500
          });
        } else {
          console.log('ğŸ¯ å‡ºç‰Œå¤±è´¥ï¼Œé€‰æ‹©ä¸è¦');
          const passResult = pass();
          if (passResult.success) {
            showToast({ 
              type: 'warning', 
              message: 'ğŸ¤– æ‰˜ç®¡è‡ªåŠ¨ä¸è¦',
              duration: 1500
            });
          }
        }
      } else {
        console.log('ğŸ¯ AIå»ºè®®ä¸è¦');
        const passResult = pass();
        if (passResult.success) {
          showToast({ 
            type: 'warning', 
            message: 'ğŸ¤– æ‰˜ç®¡è‡ªåŠ¨ä¸è¦',
            duration: 1500
          });
        }
      }
    }
  };
  
  // AIæ¨è
  const getAIRecommendation = () => {
    if (!gameState.value || !humanPlayer.value) {
      return null;
    }
    
    try {
      const cards = simpleAIStrategy(
        humanPlayer.value.hand,
        currentRound.value?.lastPlay || null,
        'balanced'
      );
      return cards ? { cards } : null;
    } catch (error) {
      console.error('AIæ¨èå¤±è´¥:', error);
      return null;
    }
  };
  
  // AIè‡ªåŠ¨å‡ºç‰Œ
  const aiPlay = async (playerId: number) => {
    if (!gameState.value) return;
    
    const player = gameState.value.players[playerId];
    if (!player || player.isHuman) return;
    
    // æ£€æŸ¥å›åˆæ˜¯å¦å·²ç»“æŸ
    if (currentRound.value?.isFinished) {
      console.log(`â­ï¸ å›åˆå·²ç»“æŸï¼Œè·³è¿‡AI ${player.name}çš„æ“ä½œ`);
      return;
    }
    
    // æ¨¡æ‹Ÿæ€è€ƒæ—¶é—´
    await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
    
    // å†æ¬¡æ£€æŸ¥å›åˆçŠ¶æ€ï¼ˆå¯èƒ½åœ¨ç­‰å¾…æœŸé—´ç»“æŸäº†ï¼‰
    if (currentRound.value?.isFinished) {
      console.log(`â­ï¸ ç­‰å¾…æœŸé—´å›åˆå·²ç»“æŸï¼Œè·³è¿‡AI ${player.name}çš„æ“ä½œ`);
      return;
    }
    
    try {
      const cards = simpleAIStrategy(
        player.hand,
        currentRound.value?.lastPlay || null,
        'balanced'
      );
      
      const isFirstPlay = !currentRound.value?.lastPlay || currentRound.value.lastPlay.length === 0;
      
      if (cards && cards.length > 0) {
        // AIå‡ºç‰Œ
        const result = playCards(cards);
        if (result.success) {
          console.log(`ğŸ¤– ${player.name} å‡ºç‰Œ:`, cards.length, 'å¼ ');
        } else if (isFirstPlay) {
          // é¦–å®¶å‡ºç‰Œå¤±è´¥ï¼Œå¼ºåˆ¶å‡ºä¸€å¼ 
          console.log(`ğŸ¤– ${player.name} AIæ¨èå‡ºç‰Œå¤±è´¥ï¼Œå¼ºåˆ¶å‡ºå•å¼ `);
          playCards([player.hand[0]]);
        }
      } else if (!isFirstPlay) {
        // AIä¸è¦ï¼ˆä»…å½“ä¸æ˜¯é¦–å®¶ï¼‰
        const result = pass();
        if (result.success) {
          console.log(`ğŸ¤– ${player.name} ä¸è¦`);
        }
      } else {
        // é¦–å®¶æ²¡æœ‰æ¨èï¼Œå¼ºåˆ¶å‡ºä¸€å¼ 
        console.log(`ğŸ¤– ${player.name} é¦–å®¶æ— æ¨èï¼Œå¼ºåˆ¶å‡ºå•å¼ `);
        playCards([player.hand[0]]);
      }
    } catch (error) {
      console.error(`AI ${player.name} å‡ºç‰Œå¤±è´¥:`, error);
    }
  };
  
  // ç›‘å¬å½“å‰ç©å®¶å˜åŒ–ï¼Œè§¦å‘AIå‡ºç‰Œ
  watch(currentPlayerIndex, async (newIndex) => {
    if (!gameState.value || status.value !== 'playing') return;
    
    const currentPlayer = gameState.value.players[newIndex];
    if (!currentPlayer) return;
    
    // å¦‚æœæ˜¯AIç©å®¶ï¼Œè‡ªåŠ¨å‡ºç‰Œ
    if (!currentPlayer.isHuman) {
      await aiPlay(newIndex);
    } 
    // å¦‚æœæ˜¯äººç±»ç©å®¶ä¸”æ‰˜ç®¡ï¼Œä¹Ÿè‡ªåŠ¨å‡ºç‰Œ
    else if (isAutoPlay.value) {
      console.log('ğŸ¤– æ‰˜ç®¡æ¨¡å¼æ¿€æ´»ï¼Œè½®æ¬¡å˜åŒ–è§¦å‘è‡ªåŠ¨å‡ºç‰Œ');
      
      // ç¨å¾®å»¶è¿Ÿï¼Œè®©ç©å®¶çœ‹åˆ°æ˜¯è‡ªå·±çš„å›åˆ
      await new Promise(resolve => setTimeout(resolve, 800));
      
      await autoPlayTurn();
    }
  });
  
  initialize();
  
  return {
    gameState,
    status,
    currentPlayerIndex,
    players,
    humanPlayer,
    currentRound,
    isAutoPlay,
    startGame,
    playCards,
    pass,
    toggleAutoPlay,
    getAIRecommendation,
    aiPlay
  };
});

